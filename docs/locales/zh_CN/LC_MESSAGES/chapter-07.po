# Py4web 中文文档
# Copyright (C) 2020, BSDv3 License
# This file is distributed under the same license as the py4web package.
# 杨文增 <1528046831@qq.com>, 2025.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: py4web 20250908\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-12-18 20:25+0800\n"
"PO-Revision-Date: 2025-12-19 20:19+0800\n"
"Last-Translator: 杨文增 <1528046831@qq.com>\n"
"Language: zh_CN\n"
"Language-Team: zh_CN <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../chapter-07.rst:3
msgid "The Database Abstraction Layer (DAL)"
msgstr "数据库抽象层（DAL）"

#: ../../chapter-07.rst:6
msgid "DAL introduction"
msgstr "DAL 简介"

#: ../../chapter-07.rst:8
msgid ""
"py4web rely on a database abstraction layer (**DAL**), an API that maps "
"Python objects into database objects such as queries, tables, and "
"records. The DAL dynamically generates the SQL in real time using the "
"specified dialect for the database back end, so that you do not have to "
"write SQL code or learn different SQL dialects (the term SQL is used "
"generically), and the application will be portable among different types "
"of databases. The DAL choosen is a pure Python one called `pyDAL "
"<https://github.com/web2py/pydal>`__. It was conceived in the web2py "
"project but it's a standard python module: you can use it in any Python "
"context."
msgstr ""
"py4web 依赖于数据库抽象层（**DAL**），这是一种将 Python 对象映射到数据库对象（如查询、表和记录）的 API。DAL "
"使用数据库后端特定的方言实时动态生成 SQL，这样您就不必编写 SQL 代码或学习不同的 SQL 方言（通常使用术语 SQL "
"），并且应用程序可以在不同类型的数据库之间移植。选用的 DAL 是一个名为 `pyDAL "
"<https://github.com/web2py/pydal>`__ 的纯 Python 库。它是在 web2py "
"项目中构思的，但它是一个标准的 python 模块：你可以在任何 python 环境中使用它。"

#: ../../chapter-07.rst:20
msgid ""
"What makes pyDAL different from most of the other DALs is the syntax: it "
"maps records to python dictionaries, which is simpler and closer to SQL. "
"Other famous frameworks instead strictly rely on an Object Relational "
"Mapping (**ORM**) like the Django ORM or the SQL Alchemy ORM, that maps "
"tables to Python classes and rows to Objects."
msgstr ""
"pyDAL 与大多数其他 DAL 的不同之处在于语法：它将记录映射到 python 字典，这更简单，更接近 SQL。其他著名的框架严格依赖于 "
"**对象关系映射** （ **ORM** ），如 Django ORM 或 SQL Alchemy ORM，它们将表映射到 Python "
"类，将行映射到对象。"

#: ../../chapter-07.rst:26
msgid "A little taste of pyDAL features:"
msgstr "pyDAL 的部分特点："

#: ../../chapter-07.rst:28
msgid "Transactions"
msgstr "事务"

#: ../../chapter-07.rst:29
msgid "Aggregates"
msgstr "聚合"

#: ../../chapter-07.rst:30
msgid "Inner & Outer Joins"
msgstr "内联、外联"

#: ../../chapter-07.rst:31
msgid "Nested Selects"
msgstr "嵌套查询"

#: ../../chapter-07.rst:35
msgid ""
"An important difference between py4web and web2py is that only some few "
"Field attributes are safe to modify in actions. See :ref:`Thread safety "
"and Field attributes` for more info, and :ref:`From web2py to py4web` for"
" a general list of differences."
msgstr ""
"py4web 和 web2py 之间一个重要的区别是，只有少数几个字段属性可以在 actions 中安全地修改。更多信息请参见 "
":ref:`Thread safety and Field attributes` ，以及从 :ref:`From web2py to "
"py4web` 的一般差异列表。"

#: ../../chapter-07.rst:40
msgid "Supported databases"
msgstr "支持的数据库"

#: ../../chapter-07.rst:42
msgid ""
"A partial list of supported databases is show in the table below. Please "
"check on the py4web/pyDAL web site and mailing list for more recent "
"adapters."
msgstr "下面的表格显示了支持的数据库的部分列表。请查看 py4web/pyDAL 网站和邮件列表，以获取更新的适配器信息。"

#: ../../chapter-07.rst:48
msgid ""
"In any modern python distribution **SQLite** is actually built-in as a "
"Python library. The SQLite driver (sqlite3) is also included: you don't "
"need to install it. Hence this is the most popular database for testing "
"and development."
msgstr ""
"在任何现代的 Python 发行版中，**SQLite** 实际上成为 Python 的内置库。SQLite 驱动程序 (sqlite3) "
"也包含在内：您无需安装它。因此，它是用于测试和开发的最常用的数据库。"

#: ../../chapter-07.rst:52
msgid ""
"The Windows and the Mac binary distribution work out of the box with "
"SQLite and PostgreSQL only. To use any other database back end, run a "
"full py4web distribution and install the appropriate driver for the "
"required back end. Once the proper driver is installed, start py4web and "
"it will automatically find the driver."
msgstr ""
"Windows 和 Mac 的二进制版本开箱即用，仅支持 SQLite 和 PostgreSQL。在后端，要使用其他数据库，请运行完整的 "
"py4web 发行版，并安装后端所需的相应驱动程序。一旦正确的驱动程序安装完成，启动 py4web，它将自动检测到驱动程序。"

#: ../../chapter-07.rst:58
msgid "Here is a list of the drivers py4web can use:"
msgstr "这里是一份 py4web 能够使用的驱动列表："

#: ../../chapter-07.rst:61 ../../chapter-07.rst:317 ../../chapter-07.rst:505
msgid "Database"
msgstr "数据库"

#: ../../chapter-07.rst:61
msgid "Drivers (source)"
msgstr "驱动程序"

#: ../../chapter-07.rst:63 ../../chapter-07.rst:4956
msgid "SQLite"
msgstr ""

#: ../../chapter-07.rst:63
msgid "sqlite3 or pysqlite2 or zxJDBC (on Jython)"
msgstr ""

#: ../../chapter-07.rst:64
msgid "PostgreSQL"
msgstr ""

#: ../../chapter-07.rst:64
msgid "psycopg2 or zxJDBC (on Jython)"
msgstr ""

#: ../../chapter-07.rst:65 ../../chapter-07.rst:4977
msgid "MySQL"
msgstr ""

#: ../../chapter-07.rst:65
msgid "pymysql or MySQLdb"
msgstr ""

#: ../../chapter-07.rst:66 ../../chapter-07.rst:5049
msgid "Oracle"
msgstr ""

#: ../../chapter-07.rst:66
msgid "cx_Oracle"
msgstr ""

#: ../../chapter-07.rst:67
msgid "MSSQL"
msgstr ""

#: ../../chapter-07.rst:67
msgid "pyodbc or pypyodbc"
msgstr ""

#: ../../chapter-07.rst:68
msgid "FireBird"
msgstr ""

#: ../../chapter-07.rst:68
msgid "kinterbasdb or fdb or pyodbc"
msgstr ""

#: ../../chapter-07.rst:69
msgid "DB2"
msgstr ""

#: ../../chapter-07.rst:69 ../../chapter-07.rst:74
msgid "pyodbc"
msgstr ""

#: ../../chapter-07.rst:70
msgid "Informix"
msgstr ""

#: ../../chapter-07.rst:70
msgid "informixdb"
msgstr ""

#: ../../chapter-07.rst:71
msgid "Ingres"
msgstr ""

#: ../../chapter-07.rst:71
msgid "ingresdbi"
msgstr ""

#: ../../chapter-07.rst:72
msgid "Cubrid"
msgstr ""

#: ../../chapter-07.rst:72
msgid "cubriddb"
msgstr ""

#: ../../chapter-07.rst:73
msgid "Sybase"
msgstr ""

#: ../../chapter-07.rst:74
msgid "Teradata"
msgstr ""

#: ../../chapter-07.rst:75
msgid "SAPDB"
msgstr ""

#: ../../chapter-07.rst:75 ../../chapter-07.rst:4904
msgid "sapdb"
msgstr ""

#: ../../chapter-07.rst:76
msgid "MongoDB"
msgstr ""

#: ../../chapter-07.rst:76
msgid "pymongo"
msgstr ""

#: ../../chapter-07.rst:77
msgid "IMAP"
msgstr ""

#: ../../chapter-07.rst:77
msgid "imaplib"
msgstr ""

#: ../../chapter-07.rst:80
msgid ""
"Support of MongoDB is experimental. Google NoSQL is treated as a "
"particular case. The Gotchas_ section at the end of this chapter has some"
" more information about specific databases."
msgstr ""
"对 MongoDB 的支持是实验性的。Google NoSQL 被视为一个特例。本章末尾的 **陷阱** ( Gotchas_ "
")部分提供了有关特定数据库的更多信息。"

#: ../../chapter-07.rst:85
msgid "The DAL: a quick tour"
msgstr "DAL: 快速预览"

#: ../../chapter-07.rst:87
msgid "py4web defines the following classes that make up the DAL:"
msgstr "py4web 定义了构成 DAL 的以下类："

#: ../../chapter-07.rst:89
msgid "DAL"
msgstr ""

#: ../../chapter-07.rst:90
msgid "represents a database connection. For example:"
msgstr "表示数据库连接。例如："

#: ../../chapter-07.rst:96
msgid "Table"
msgstr ""

#: ../../chapter-07.rst:97
msgid ""
"represents a database table. You do not directly instantiate Table; "
"instead, ``DAL.define_table`` does."
msgstr "表示一个数据库 **表** 。你不能直接实例化表， ``DAL.define_table`` 会实现："

#: ../../chapter-07.rst:104
msgid "The most important methods of a Table are:"
msgstr "**表** 的非常重要的方法是："

#: ../../chapter-07.rst:106
msgid "``insert``, ``truncate``, ``drop``, and ``import_from_csv_file``."
msgstr "``insert`` 、 ``truncate`` 、 ``drop`` 、 和 ``import_from_csv_file`` 。"

#: ../../chapter-07.rst:108
msgid "Field"
msgstr ""

#: ../../chapter-07.rst:109
msgid ""
"represents a database field. It can be instantiated and passed as an "
"argument to ``DAL.define_table``."
msgstr "表示一个数据库 **字段** 。它可以被实例化，也可以作为  ``DAL.define_table`` 的参数。"

#: ../../chapter-07.rst:112
msgid "Rows"
msgstr ""

#: ../../chapter-07.rst:113
msgid ""
"is the object returned by a database select. It can be thought of as a "
"list of ``Row`` rows:"
msgstr "Rows 是数据库查询返回的一个对象。可以认为它是由多个 ``Row`` 构成的一个列表："

#: ../../chapter-07.rst:120
msgid "Row"
msgstr ""

#: ../../chapter-07.rst:121
msgid "contains field values:"
msgstr "包含字段值"

#: ../../chapter-07.rst:128
msgid "Query"
msgstr ""

#: ../../chapter-07.rst:129
msgid "is an object that represents a SQL “where” clause:"
msgstr "Query 是一个表示 SQL “where” 子句的对象"

#: ../../chapter-07.rst:135
msgid "Set"
msgstr ""

#: ../../chapter-07.rst:136
msgid ""
"is an object that represents a set of records. Its most important methods"
" are ``count``, ``select``, ``update``, and ``delete``. For example:"
msgstr ""
"Set 是一组记录的集合的对象。它最重要的方法是 ``count`` 、 ``select`` 、 ``update`` 和 ``delete``"
" 。例如："

#: ../../chapter-07.rst:147
msgid "Expression"
msgstr "表达式"

#: ../../chapter-07.rst:148
msgid ""
"is something like an ``orderby`` or ``groupby`` expression. The Field "
"class is derived from the Expression. Here is an example."
msgstr ""
"**表达式(expression)** 是用于类似 orderby 或 groupby 使用的东西，它们使用的 Field 来自 **表达式** "
"。这里有一个例子。"

#: ../../chapter-07.rst:158
msgid "Using the DAL “stand-alone”"
msgstr "单独使用 DAL"

#: ../../chapter-07.rst:160
msgid ""
"pyDAL is an independent python package. As such, it can be used without "
"the web2py/py4web environment; you just need to install it with ``pip``. "
"Then import the pydal module when needed:"
msgstr ""
"pyDAL 是一个独立的 python 包。因此，它可以在没有 web2py/py4web 环境的情况下使用；你只需要使用 pip "
"安装它，然后在需要的地方导入 pydal 模块："

#: ../../chapter-07.rst:171
msgid ""
"Even if you can import modules directly from pydal, this is not advisable"
" from within py4web applications. Remember that ``py4web.DAL`` is a "
"fixture, ``pydal.DAL`` is not. In this context, the last command should "
"better be:"
msgstr ""
"即使您可以直接从 pydal 导入模块，也不建议在 py4web 的应用程序中导入。记住 ``py4web.DAL`` 是一个 **夹具** ，而"
" ``pydal.DAL`` 不是。在本文中，上面的导入命令因该是："

#: ../../chapter-07.rst:180
msgid "Experiment with the py4web shell"
msgstr "使用 py4web shell 进行实验"

#: ../../chapter-07.rst:182
msgid ""
"You can also experiment with the pyDAL API using the py4web shell, that "
"is available using the :ref:`shell command option`."
msgstr "你还可以借助 py4web shell 来试验 pyDAL API， :ref:`shell command option` 也可以使用。"

#: ../../chapter-07.rst:187
msgid ""
"Mind that database changes may be persistent. So be careful and do NOT "
"hesitate to create a new application for doing testing instead of "
"tampering with an existing one. The only exception is the showcase db: in"
" case of problems you can recreate it by simply deleting the database "
"folder and restarting py4web. This will re-create the database with all "
"the example data."
msgstr ""
"请注意，数据库更改可能是持久的。因此，要小心，要毫不犹豫地创建一个新的应用程序进行测试，而不是篡改现有的应用程序。唯一的例外是 showcase "
"数据库：如果出现问题，您可以通过删除数据库文件夹并重新启动 py4web 来重新创建它。这将使用所有示例数据重新创建数据库。"

#: ../../chapter-07.rst:196
msgid ""
"Note that most of the code snippets that contain the python prompt "
"``>>>`` are also directly executable via a py4web shell."
msgstr "请注意，包含 python 提示符 ``>>>`` 的大多数代码片段也可以通过 py4web shell 直接执行。"

#: ../../chapter-07.rst:199
msgid "This is a simple example, using the provided ``showcase`` app:"
msgstr "这里是一个简单地示例，它使用 py4web 提供的 ``showcase`` 应用程序"

#: ../../chapter-07.rst:210
msgid ""
"You can also start by creating a connection from zero. For the sake of "
"simplicity, you can use SQLite. Nothing in this discussion changes when "
"you switch the back-end engine."
msgstr "您还可以从零开始创建连接。为了简单起见，您可以使用 SQLite。当您切换后端数据库引擎时，数据库中的任何内容都不会改变。"

#: ../../chapter-07.rst:215
msgid "Using the dashboard app with databases"
msgstr "使用带有数据的 dashboard 应用程序"

#: ../../chapter-07.rst:217
msgid ""
"Generally you can use the dashboard app for viewing and modifying the "
"databases of a particular app. However this is not bulletproof, so for "
"security reason this by default is not applied to the showcase app. But "
"if your installation is local (not exposed to public networks), you can "
"enable it by simply adding to the file``apps/showcase/__init__.py`` the "
"line:"
msgstr ""
"通常，您可以使用 dashboard 应用程序查看和修改特定应用程序的数据库。然而，这是危险的，因此出于安全原因，默认情况下这不适用于 "
"showcase 应用程序。但是，如果你的 py4web 在本地（不暴露在公共网络中），你可以通过在文件 "
"``apps/showcase/__init__.py`` 中简单地添加以下行来启用它："

#: ../../chapter-07.rst:228
msgid ""
"This allow you to look graphically inside the showcase application "
"database:"
msgstr "这允许您以图形方式查看 showcase 应用程序内部的数据库："

#: ../../chapter-07.rst:234
msgid "DAL constructor"
msgstr "DAL 的构造函数"

#: ../../chapter-07.rst:236
msgid "Basic use:"
msgstr "基本用法："

#: ../../chapter-07.rst:242
msgid ""
"The database is now connected and the connection is stored in the global "
"variable ``db``."
msgstr "现在，连接了数据库，并且 **连接** 被存储在全局变量 ``db`` 中"

#: ../../chapter-07.rst:245
msgid "At any time you can retrieve the connection string."
msgstr "您可以随时检索连接字符串。"

#: ../../chapter-07.rst:252
msgid "and the database name"
msgstr "也可以获取数据库名称"

#: ../../chapter-07.rst:259
msgid ""
"The connection string is called ``_uri`` because it is an instance of a "
"uniform resource identifier."
msgstr "连接字符串称为 ``_uri`` ，因为它是统一资源标识符的实例。"

#: ../../chapter-07.rst:262
msgid ""
"The DAL allows multiple connections with the same database or with "
"different databases, even databases of different types. For now, we will "
"assume the presence of a single database since this is the most common "
"situation."
msgstr "DAL 允许与同一数据库或不同数据库，甚至不同类型的数据库进行多个连接。目前，我们将假设存在一个数据库，因为这是最常见的情况。"

#: ../../chapter-07.rst:268
msgid "DAL signature"
msgstr "DAL 的签名"

#: ../../chapter-07.rst:298
msgid "Connection strings (the uri parameter)"
msgstr "连接字符串（参数 uri）"

#: ../../chapter-07.rst:300
msgid ""
"A connection with the database is established by creating an instance of "
"the DAL object:"
msgstr "通过创建 DAL 对象的实例来建立与数据库的连接："

#: ../../chapter-07.rst:307
msgid ""
"``db`` is not a keyword; it is a local variable that stores the "
"connection object ``DAL``. You are free to give it a different name. The "
"constructor of ``DAL`` requires a single argument, the connection string."
" The connection string is the only py4web code that depends on a specific"
" back-end database. Here are examples of connection strings for specific "
"types of supported back-end databases (in all cases, we assume the "
"database is running from localhost on its default port and is named "
"“test”):"
msgstr ""
"``db`` 不是关键字；它是存储连接对象 ``DAL`` 的局部变量。你可以自由地给它起一个不同的名字。DAL "
"的构造函数至少需要一个参数，即连接字符串。连接字符串是唯一依赖于特定后端数据库的 py4web "
"代码。以下是受支持的特定类型的后端数据库的连接字符串示例（在所有情况下，我们假设数据库以 localhost 方式运行在其默认端口上，并命名为 "
"“test” ）："

#: ../../chapter-07.rst:317
msgid "Connection string"
msgstr "连接字符串"

#: ../../chapter-07.rst:319
msgid "**SQLite**"
msgstr ""

#: ../../chapter-07.rst:319
msgid "``sqlite://storage.sqlite``"
msgstr ""

#: ../../chapter-07.rst:320 ../../chapter-07.rst:508
msgid "**MySQL**"
msgstr ""

#: ../../chapter-07.rst:320
msgid "``mysql://username:password@localhost/test?set_encoding=utf8mb4``"
msgstr ""

#: ../../chapter-07.rst:321 ../../chapter-07.rst:507
msgid "**PostgreSQL**"
msgstr ""

#: ../../chapter-07.rst:321
msgid "``postgres://username:password@localhost/test``"
msgstr ""

#: ../../chapter-07.rst:322
msgid "**MSSQL (legacy)**"
msgstr ""

#: ../../chapter-07.rst:322
msgid "``mssql://username:password@localhost/test``"
msgstr ""

#: ../../chapter-07.rst:323
msgid "**MSSQL (>=2005)**"
msgstr ""

#: ../../chapter-07.rst:323
msgid "``mssql3://username:password@localhost/test``"
msgstr ""

#: ../../chapter-07.rst:324
msgid "**MSSQL (>=2012)**"
msgstr ""

#: ../../chapter-07.rst:324
msgid "``mssql4://username:password@localhost/test``"
msgstr ""

#: ../../chapter-07.rst:325 ../../chapter-07.rst:509
msgid "**FireBird**"
msgstr ""

#: ../../chapter-07.rst:325
msgid "``firebird://username:password@localhost/test``"
msgstr ""

#: ../../chapter-07.rst:326 ../../chapter-07.rst:511
msgid "**Oracle**"
msgstr ""

#: ../../chapter-07.rst:326
msgid "``oracle://username/password@test``"
msgstr ""

#: ../../chapter-07.rst:327
msgid "**DB2**"
msgstr ""

#: ../../chapter-07.rst:327
msgid "``db2://username:password@test``"
msgstr ""

#: ../../chapter-07.rst:328
msgid "**Ingres**"
msgstr ""

#: ../../chapter-07.rst:328
msgid "``ingres://username:password@localhost/test``"
msgstr ""

#: ../../chapter-07.rst:329
msgid "**Sybase**"
msgstr ""

#: ../../chapter-07.rst:329
msgid "``sybase://username:password@localhost/test``"
msgstr ""

#: ../../chapter-07.rst:330
msgid "**Informix**"
msgstr ""

#: ../../chapter-07.rst:330
msgid "``informix://username:password@test``"
msgstr ""

#: ../../chapter-07.rst:331
msgid "**Teradata**"
msgstr ""

#: ../../chapter-07.rst:331
msgid "``teradata://DSN=dsn;UID=user;PWD=pass;DATABASE=test``"
msgstr ""

#: ../../chapter-07.rst:332
msgid "**Cubrid**"
msgstr ""

#: ../../chapter-07.rst:332
msgid "``cubrid://username:password@localhost/test``"
msgstr ""

#: ../../chapter-07.rst:333
msgid "**SAPDB**"
msgstr ""

#: ../../chapter-07.rst:333
msgid "``sapdb://username:password@localhost/test``"
msgstr ""

#: ../../chapter-07.rst:334
msgid "**IMAP**"
msgstr ""

#: ../../chapter-07.rst:334
msgid "``imap://user:password@server:port``"
msgstr ""

#: ../../chapter-07.rst:335
msgid "**MongoDB**"
msgstr ""

#: ../../chapter-07.rst:335
msgid "``mongodb://username:password@localhost/test``"
msgstr ""

#: ../../chapter-07.rst:336
msgid "**Google/SQL**"
msgstr ""

#: ../../chapter-07.rst:336
msgid "``google:sql://project:instance/database``"
msgstr ""

#: ../../chapter-07.rst:337
msgid "**Google/NoSQL**"
msgstr ""

#: ../../chapter-07.rst:337
msgid "``google:datastore``"
msgstr ""

#: ../../chapter-07.rst:338
msgid "**Google/NoSQL/NDB**"
msgstr ""

#: ../../chapter-07.rst:338
msgid "``google:datastore+ndb``"
msgstr ""

#: ../../chapter-07.rst:341
msgid ""
"in SQLite the database consists of a single file. If it does not exist, "
"it is created. This file is locked every time it is accessed. In addition"
" to the file 'storage.sqlite' that contains the data, there will be also "
"a sql.log file plus one additional file called longhash_tablename.table "
"for every table definition. The table definition files are used during "
"migrations; in case of problems they could be deleted (they'll be "
"automatically recreated)."
msgstr ""
"在 SQLite 中，数据库由单个文件组成。如果它不存在，则创建它。每次访问此文件时都会将其锁定。除了一个 sql.log "
"文件，对于每个表定义，还有一个名为 longhash_tablename.table "
"的附加文件。表定义文件在迁移过程中使用；如果出现问题，可以删除它们（它们将自动重新创建）。"

#: ../../chapter-07.rst:347
msgid ""
"in the case of MySQL, PostgreSQL, MSSQL, FireBird, Oracle, DB2, Ingres "
"and Informix the database “test” must be created outside py4web. Once the"
" connection is established, py4web will create, alter, and drop tables "
"appropriately."
msgstr ""
"对于 MySQL、PostgreSQL、MSSQL、FireBird、Oracle、DB2、Ingres 和 Informix  的情况，必须在 "
"py4web 之外单独创建数据库  “test” 。 连接建立后，py4web 将恰当地创建、更改和删除表。"

#: ../../chapter-07.rst:351
msgid ""
"in the MySQL connection string, the ``?set_encoding=utf8mb4`` at the end "
"sets the encoding to UTF-8 and avoids an ``Invalid utf8 character "
"string:`` error on Unicode characters that consist of four bytes, as by "
"default, MySQL can only handle Unicode characters that consist of one to "
"three bytes."
msgstr ""
"默认情况下，MySQL 只能处理由 1 到 3 个字节构成的 Unicode 字符，因此在 MySQL 连接字符串中末尾的  "
"``?set_encoding=utf8mb4`` 将编码设置为UTF-8，这将避免在由 4 个字节组成的 Unicode 字符上出现 "
"``Invalid utf8 character string:`` 错误."

#: ../../chapter-07.rst:356
msgid ""
"in the Google/NoSQL case the ``+ndb`` option turns on NDB. NDB uses a "
"Memcache buffer to read data that is accessed often. This is completely "
"automatic and done at the datastore level, not at the py4web level."
msgstr ""
"在 Google/NoSQL 的情况下，选项 ``+ndb`` 会启用 NDB。NDB 使用 Memcache "
"缓冲区读取经常访问的数据。这是完全自动的，在数据存储级别完成，而不是在 py4web 级别。"

#: ../../chapter-07.rst:359
msgid ""
"it is also possible to set the connection string to ``None``. In this "
"case DAL will not connect to any back-end database, but the API can still"
" be accessed for testing."
msgstr "也可以将连接字符串设置为 ``None`` 。这种情况下，DAL 不会连接任何后端数据库，但是依然可以访问 DAL 的有关 API 进行测试。"

#: ../../chapter-07.rst:363
msgid ""
"Some times you may also need to generate SQL as if you had a connection "
"but without actually connecting to the database. This can be done with"
msgstr "有时，您可能还需要生成 SQL 语句，就像您有连接但没有实际连接到数据库一样。这可以通过以下方式完成："

#: ../../chapter-07.rst:370
msgid ""
"In this case you will be able to call ``_select``, ``_insert``, "
"``_update``, and ``_delete`` to generate SQL but not call ``select``, "
"``insert``, ``update``, and ``delete``; see `Generating raw SQL`_ for "
"details. In most of the cases you can use ``do_connect=False`` even "
"without having the required database drivers."
msgstr ""
"在这种情况下，你可以调用 ``_select`` 、 ``_insert`` 、 ``_update`` 和 ``_delete`` 来生成 "
"SQL 语句，但是不能调用  ``select`` 、 ``_insert`` 、 ``update`` 、 和 ``delete`` "
"；有关详细信息，请参阅  `Generating raw SQL`_ 。在大多数情况下，即使没有所需的数据库驱动程序，也可以使用 "
"``do_connect=False`` 。"

#: ../../chapter-07.rst:376
msgid ""
"Notice that by default py4web uses utf8 character encoding for databases."
" If you work with existing databases that behave differently, you have to"
" change it with the optional parameter ``db_codec`` like"
msgstr "请注意，py4web 默认数据库使用 utf8 字符编码。如果你使用编码不同的已有数据库，就必须使用 ``db_codec`` 参数选项改变设置："

#: ../../chapter-07.rst:384
msgid "Otherwise you’ll get UnicodeDecodeError tickets."
msgstr "否则，你将收到 UnicodeDecodeError  tickets 。"

#: ../../chapter-07.rst:387
msgid "Connection pooling"
msgstr "连接池"

#: ../../chapter-07.rst:389
msgid ""
"A common argument of the DAL constructor is the ``pool_size``; it "
"defaults to zero."
msgstr "DAL 构造函数的一个常用参数是  ``pool_size``，其默认值是 0 。"

#: ../../chapter-07.rst:392
msgid ""
"As it is rather slow to establish a new database connection for each "
"request, py4web implements a mechanism for connection pooling. Once a "
"connection is established and the page has been served and the "
"transaction completed, the connection is not closed but goes into a pool."
" When the next request arrives, py4web tries to recycle a connection from"
" the pool and use that for the new transaction. If there are no available"
" connections in the pool, a new connection is established."
msgstr ""
"由于为每个请求建立新的数据库连接相当缓慢，所以 py4web "
"实现了一种连接池机制。一旦建立了一个连接，页面被提供并且事务完成后，这个连接不会被关闭，而是进入池中。当下一个请求到达时，py4web "
"会尝试从池中回收连接，并将其用于新事务。如果池中没有可用连接，那么再建立新的连接。"

#: ../../chapter-07.rst:401
msgid ""
"When py4web starts, the pool is always empty. The pool grows up to the "
"minimum between the value of ``pool_size`` and the max number of "
"concurrent requests. This means that if ``pool_size=10`` but our server "
"never receives more than 5 concurrent requests, then the actual pool size"
" will only grow to 5. If ``pool_size=0`` then connection pooling is not "
"used."
msgstr ""
"py4web 刚启动时，连接池总是空的。池中的连接数量增长到 ``pool_size`` 的值和并发请求的最大数量中的最小值。这意味着，如果  "
"``pool_size=10`` ，但我们的服务器从未收到超过5个并发请求，那么池中实际的连接数量只会增长到 5。如果 "
"``pool_size=0`` ，则不使用连接池。"

#: ../../chapter-07.rst:408
msgid ""
"Connections in the pools are shared sequentially among threads, in the "
"sense that they may be used by two different but not simultaneous "
"threads. There is only one pool for each py4web process."
msgstr "池中的连接在线程之间按顺序共享，也就是说，它们可能由两个不同但不同时的线程使用。每个 py4web 进程只有一个池。"

#: ../../chapter-07.rst:412
msgid ""
"The ``pool_size`` parameter is ignored by SQLite and Google App Engine. "
"Connection pooling is ignored for SQLite, since it would not yield any "
"benefit."
msgstr ""
"``pool_size`` 参数会被 SQLite 和 Google App Engine 忽略。SQLite 忽略了连接池，因为连接池对 "
"SQLite 不会产生任何好处。"

#: ../../chapter-07.rst:417
msgid "Connection failures (attempts parameter)"
msgstr "连接失败（attempts 参数）"

#: ../../chapter-07.rst:419
msgid ""
"If py4web fails to connect to the database it waits 1 second and by "
"default tries again up to 5 times before declaring a failure. In case of "
"connection pooling it is possible that a pooled connection that stays "
"open but unused for some time is closed by the database end. Thanks to "
"the retry feature py4web tries to re-establish these dropped connections."
" The number of attempts is set via the attempts parameter."
msgstr ""
"如果 py4web 无法连接到数据库，它会等待 1 秒后重试，默认情况下会在声明失败之前最多重试 5 "
"次。在有连接池的情况下，数据库端可能会关闭在一段时间内保持打开但未使用 的连接。由于重试功能，py4web "
"会尝试重新建立这些断开的连接。尝试次数通过 ``attempts`` 参数设置。"

#: ../../chapter-07.rst:427
msgid "Lazy Tables"
msgstr "懒惰表"

#: ../../chapter-07.rst:429
msgid ""
"Setting ``lazy_tables = True`` provides a major performance boost (but "
"not with py4web). It means that table creation is deferred until the "
"table is actually referenced."
msgstr "设置 ``lazy_tables = True`` ，可以显著提高性能（但在 py4web 中不会）。这意味着表的创建被推迟，直到表被实际引用。"

#: ../../chapter-07.rst:435
msgid ""
"You should never use lazy tables in py4web. There is no advantage, no "
"need, and possibly concurrency problems."
msgstr "你永远不应该在 py4web 中使用懒惰表。那既没优势也没必要，还可能存在并发问题。"

#: ../../chapter-07.rst:439
msgid "Model-less applications"
msgstr "“无模型” 应用程序"

#: ../../chapter-07.rst:441
msgid ""
"Normally in py4web the code that define DAL tables lives in the file "
"``models.py``, hence it's only executed at startup because it's outside "
"of actions."
msgstr ""
"在 py4web 中，定义 DAL 表的代码通常位于 models.py 文件中。因为 models.py 在 **actions** "
"之外，所以只在 py4web 启动时，它才被运行一次。"

#: ../../chapter-07.rst:444
msgid ""
"However, it is possible to define DAL tables on demand inside actions. "
"This is referred to as “model-less” development by the py4web community."
msgstr "但是，依然可以在 **actions** 内部按需定义 DAL 表。这被 py4web 社区称为 “无模型” 开发。"

#: ../../chapter-07.rst:447
msgid ""
"To use the “model-less” approach, you take responsibility for doing all "
"the housekeeping tasks. You call the table definitions when you need "
"them, and provide database connection passed as parameter. Also, remember"
" maintainability: other py4web developers expect to find database "
"definitions in the ``models.py`` file."
msgstr ""
"使用 “无模型” 方式，您需要负责完成所有内置的管理任务。需要时，调用表定义，并提供数据库连接作为参数传递。此外，请记住可维护性：其他 "
"py4web 开发人员希望在 models.py 文件中找到数据库及表的定义。"

#: ../../chapter-07.rst:454
msgid "Replicated databases"
msgstr "多个数据库"

#: ../../chapter-07.rst:456
msgid ""
"The first argument of ``DAL(...)`` can be a list of URIs. In this case "
"py4web tries to connect to each of them. The main purpose for this is to "
"deal with multiple database servers and distribute the workload among "
"them. Here is a typical use case:"
msgstr ""
"``DAL(...)`` 的第一个参数可以是 URI 列表。在这种情况下，py4web 试图连接到每个 "
"URI。其主要目的是处理多个数据库服务器，并在它们之间分配工作负载。以下是一个典型的用例："

#: ../../chapter-07.rst:465
msgid ""
"In this case the DAL tries to connect to the first and, on failure, it "
"will try the second and the third. This can also be used to distribute "
"load in a database master-slave configuration."
msgstr "在这种情况下，DAL 尝试连接到第一个，如果失败，它将尝试第二个和第三个。这也可用于在数据库主从配置中分配负载。"

#: ../../chapter-07.rst:470
msgid "Reserved keywords"
msgstr "保留的关键字"

#: ../../chapter-07.rst:472
msgid ""
"``check_reserved`` tells the constructor to check table names and column "
"names against reserved SQL keywords in target back-end databases. "
"``check_reserved`` defaults to None."
msgstr "``check_reserved`` 告诉构造函数，根据后端数据库中保留的 SQL 关键字检查表名和列名，其默认值为 None。"

#: ../../chapter-07.rst:476
msgid ""
"This is a list of strings that contain the database back-end adapter "
"names."
msgstr "``check_reserved`` 的值是一个包含数据库后端适配器名称的字符串列表。"

#: ../../chapter-07.rst:479
msgid ""
"The adapter name is the same as used in the DAL connection string. So if "
"you want to check against PostgreSQL and MSSQL then your db connection "
"would look as follows:"
msgstr "适配器名称与 DAL 连接字符串中使用的名称相同。因此，如果你想检查 PostgreSQL 和 MSSQ L，那么你的 ``db`` 定义如下："

#: ../../chapter-07.rst:487
msgid "The DAL will scan the keywords in the same order as of the list."
msgstr "DAL 将按照列表中的顺序检查关键字。"

#: ../../chapter-07.rst:489
msgid ""
"There are two extra options “all” and “common”. If you specify all, it "
"will check against all known SQL keywords. If you specify common, it will"
" only check against common SQL keywords such as ``SELECT``, ``INSERT``, "
"``UPDATE``, etc."
msgstr ""
"有两个额外的选项 “all” 和 “common”。如果指定  “all” ，它将检查所有已知的 SQL关键字。如果指定 "
"“common”，它将只检查常见的 SQL 关键字，如 ``SELECT`` 、 ``INSERT`` 、 ``UPDATE`` 等。"

#: ../../chapter-07.rst:494
msgid ""
"For supported back ends you may also specify if you would like to check "
"against the non-reserved SQL keywords as well. In this case you would "
"append ``_nonreserved`` to the name. For example:"
msgstr ""
"对于支持的后端，您还可以指定是否也要检查非保留的 SQL 关键字。在这种情况下，您应该在数据库适配器名称后附加 ``_nonreserved`` "
"。例如："

#: ../../chapter-07.rst:502
msgid "The following database backends support reserved words checking."
msgstr "以下后端数据库支持保留字检查。"

#: ../../chapter-07.rst:505
msgid "check_reserved"
msgstr "check_reserved 参数"

#: ../../chapter-07.rst:507
msgid "``postgres(_nonreserved)``"
msgstr ""

#: ../../chapter-07.rst:508
msgid "``mysql``"
msgstr ""

#: ../../chapter-07.rst:509
msgid "``firebird(_nonreserved)``"
msgstr ""

#: ../../chapter-07.rst:510
msgid "**MSSQL**"
msgstr ""

#: ../../chapter-07.rst:510
msgid "``mssql``"
msgstr ""

#: ../../chapter-07.rst:511
msgid "``oracle``"
msgstr ""

#: ../../chapter-07.rst:515
msgid "Database quoting and case settings"
msgstr "数据库中的引号和大小写设置"

#: ../../chapter-07.rst:517
msgid "Quoting of SQL entities are enabled by default in DAL, that is:"
msgstr "DAL 中默认启用 SQL 实体的引号，即"

#: ../../chapter-07.rst:519
msgid "``entity_quoting = True``"
msgstr ""

#: ../../chapter-07.rst:521
msgid ""
"This way identifiers are automatically quoted in SQL generated by DAL. At"
" SQL level keywords and unquoted identifiers are case insensitive, thus "
"quoting an SQL identifier makes it case sensitive."
msgstr ""
"这样，DAL 生成的 SQL 中会自动把标识符放在一对引号内。在 SQL 级别，关键字和未加引号的标识符不区分大小写，因此加引号的 SQL "
"标识符会使其区分大小写。"

#: ../../chapter-07.rst:525
msgid ""
"Notice that unquoted identifiers should always be folded to lower case by"
" the back-end engine according to SQL standard but not all engines are "
"compliant with this (for example PostgreSQL default folding is upper "
"case)."
msgstr "请注意，根据 SQL 标准，后端引擎应始终将未引用的标识符处理为小写，但并非所有引擎都符合此标准（例如 PostgreSQL 默认处理为大写）"

#: ../../chapter-07.rst:530
msgid "By default DAL ignores field case too, to change this use:"
msgstr "默认情况下，DAL 也忽略字段大小写，要更改此用法，请如下设置："

#: ../../chapter-07.rst:532
msgid "``ignore_field_case = False``"
msgstr ""

#: ../../chapter-07.rst:534
msgid ""
"To be sure of using the same names in python and in the DB schema, you "
"must arrange for both settings above. Here is an example:"
msgstr "为了确保在 python 和 DB 模式中使用相同的名称，您必须做好上述两个设置。以下是一个示例："

#: ../../chapter-07.rst:544
msgid "Making a secure connection"
msgstr "建立安全连接"

#: ../../chapter-07.rst:546
msgid ""
"Sometimes it is necessary (and advised) to connect to your database using"
" secure connection, especially if your database is not on the same server"
" as your application. In this case you need to pass additional parameters"
" to the database driver. You should refer to database driver "
"documentation for details."
msgstr ""
"有时，有必要（并建议）使用 **安全连接** "
"连接到数据库，特别是如果数据库与应用程序不在同一服务器上。在这种情况下，您需要将其他参数传递给数据库驱动程序。有关详细信息，请参阅数据库驱动程序文档。"

#: ../../chapter-07.rst:552
msgid "For PostgreSQL with psycopg2 it should look like this:"
msgstr "对于带有 psycopg2 的 PostgreSQL ，它应该看起来像这样："

#: ../../chapter-07.rst:560
msgid ""
"where parameters ``sslrootcert``, ``sslcert`` and ``sslkey`` should "
"contain the full path to the files. You should refer to PostgreSQL "
"documentation on how to configure PostgreSQL server to accept secure "
"connections."
msgstr ""
"其中参数 ``sslrootcert`` 、 ``sslcert`` 和 ``sslkey`` 应包含文件的完整路径。您应该参考 "
"PostgreSQL 文档，了解如何配置 PostgreSQL 服务器以接受安全连接。"

#: ../../chapter-07.rst:566
msgid "Other DAL constructor parameters"
msgstr "DAL 构造函数的其它参数"

#: ../../chapter-07.rst:569
msgid "Database folder location"
msgstr "数据库文件夹的位置"

#: ../../chapter-07.rst:571
msgid ""
"``folder`` sets the place where migration files will be created (see "
"Migrations_ for details). By default it's automatically set within py4web"
" on the same folder of the database itself, but you have to specify it "
"when using DAL outside py4web."
msgstr ""
"``folder`` 设置创建迁移文件的位置（有关详细信息，请参阅 Migrations_ ）。默认情况下，它在 py4web "
"中自动设置为数据库自身所在的那个文件夹，但在 py4web 外使用 DAL 时必须指定它。"

#: ../../chapter-07.rst:575
msgid ""
"Note that for SQLite databases it's normally necessary, otherwise you'll "
"implicitly choose an in memory database (where folder and migrations "
"don't have any sense). So these constructors have the same meaning:"
msgstr ""
"请注意，这对于 SQLite "
"数据库通常是必要的，否则您将隐式选择内存中的数据库（其中文件夹和迁移没有任何意义）。因此，下面的构造函数具有相同的含义："

#: ../../chapter-07.rst:586
msgid "Default migration settings"
msgstr "默认迁移设置"

#: ../../chapter-07.rst:588
msgid ""
"The DAL constructor migration settings are booleans affecting defaults "
"and global behaviour (again, see Migrations_ for details)"
msgstr "DAL 构造函数的迁移设置是布尔值，会影响默认值和全局行为（详情请参见 Migrations_ ）"

#: ../../chapter-07.rst:591
msgid "``migrate = True`` sets default migrate behavior for all tables"
msgstr "``migrate = True`` 为所有表设置为开启默认迁移行为"

#: ../../chapter-07.rst:593
msgid "``fake_migrate = False`` sets default fake_migrate behavior for all tables"
msgstr ""
"``fake_migrate = False`` 为所有表设置 **模拟迁移** 行为（False ，表示进行“真实迁移”，不仅更新 DAL "
"结构，也会同步更新数据库的表结构；True ，表示进行 “模拟迁移”，仅更新 DAL 结构，不对数据库进行任何修改）"

#: ../../chapter-07.rst:596
msgid "``migrate_enabled = True`` If set to False disables ALL migrations"
msgstr "``migrate_enabled = True`` 设置为 False ，将禁用所有迁移"

#: ../../chapter-07.rst:598
msgid "``fake_migrate_all = False`` If set to True fake migrates ALL tables"
msgstr "``fake_migrate_all = False`` 设置为 True，对所有表执行 “模拟迁移”"

#: ../../chapter-07.rst:601
msgid "``commit`` and ``rollback``"
msgstr "``commit`` 和 ``rollback``"

#: ../../chapter-07.rst:603
msgid ""
"The insert, truncate, delete, and update operations aren't actually "
"committed until py4web issues the commit command. The create and drop "
"operations may be executed immediately, depending on the database engine."
msgstr ""
"在 py4web 发出 commit 命令之前，insert、 truncate、 delete 和 update 操作实际上不会被提交。 "
"create 和 drop 操作可能立即执行，具体取决于数据库引擎。"

#: ../../chapter-07.rst:608
msgid ""
"If you pass ``db`` in an ``action.uses`` decorator, you don't need to "
"call commit in the controller, it is automatically done for you (also, if"
" you use ``authenticated`` or ``unauthenticated`` decorator.)"
msgstr ""
"如果你在 ``action.uses()`` 装饰器中传递 ``db`` 参数，那么你不需要在控制器中调用 "
"commit，它会自动为你完成（如果你使用 ``authenticated`` 或 ``unauthenticated`` 装饰器，也是一样的。）"

#: ../../chapter-07.rst:614
msgid ""
"always add ``db`` in an ``action.uses`` decorator (or use the "
"``authenticated`` or ``unauthenticated`` decorator). Otherwise you have "
"to add ``db.commit()`` in every define_table and in every table "
"activities: insert(), update(), delete()"
msgstr ""
"始终在 ``action.uses`` 装饰器中添加 ``db`` 参数（或使用 ``authenticated`` 或 "
"``unauthenticated`` 装饰器时）。否则，您必须在每个 define_table() "
"中和每个表的操作（insert()、update()、delete()）中添加 ``db.commit()`` "

#: ../../chapter-07.rst:619
msgid ""
"So in actions there is normally no need to ever call ``commit`` or "
"``rollback`` explicitly in py4web unless you need more granular control."
msgstr "因此，在 py4web 的 actions 中，通常不需要显式调用 ``commit`` 或 ``rollback`` ，除非您需要更精细的控制。"

#: ../../chapter-07.rst:623
msgid ""
"But if you executed commands via the shell, you are required to manually "
"commit:"
msgstr "但是，如果你使用 shell 执行命令，就需要手动显示地执行 commit："

#: ../../chapter-07.rst:630
msgid "To check it let’s insert a new record:"
msgstr "要检查它，让我们插入一条新记录："

#: ../../chapter-07.rst:637
msgid "and roll back, i.e., ignore all operations since the last commit:"
msgstr "现在 **回滚**，即忽略自上次提交以来的所有操作："

#: ../../chapter-07.rst:643
msgid ""
"If you now insert again, the counter will again be set to 2, since the "
"previous insert was rolled back."
msgstr "如果重新插入数据，计数器将再次被设置为 2，因为前面地插入被回滚了。"

#: ../../chapter-07.rst:651
msgid ""
"Code in models, views and controllers is enclosed in py4web code that "
"looks like this (pseudo code):"
msgstr "models、 views 和 controllers 中的代码被封装在 py4web 代码中，看起来像这样（伪代码）："

#: ../../chapter-07.rst:668
msgid "Table constructor"
msgstr "“Table” 的构造函数"

#: ../../chapter-07.rst:670
msgid "Tables are defined in the DAL via ``define_table``."
msgstr "**表** （Table），由 DAL 中的 ``define_table()`` 来定义。"

#: ../../chapter-07.rst:673
msgid "define_table signature"
msgstr "define_table 的签名"

#: ../../chapter-07.rst:675
msgid "The signature for define_table method is:"
msgstr "define_table() 的签名是："

#: ../../chapter-07.rst:681
msgid ""
"It accepts a mandatory table name and an optional number of ``Field`` "
"instances (even none). You can also pass a ``Table`` (or subclass) object"
" instead of a ``Field`` one, this clones and adds all the fields (but the"
" “id”) to the defining table. Other optional keyword args are: ``rname``,"
" ``redefine``, ``common_filter``, ``fake_migrate``, ``fields``, "
"``format``, ``migrate``, ``on_define``, ``plural``, ``polymodel``, "
"``primarykey``, ``sequence_name``, ``singular``, ``table_class``, and "
"``trigger_name``, which are discussed below."
msgstr ""
"它接受一个必须有的表名和可选数量的 ``Field`` 实例（也可以没有）。 除了 ``Field`` 对象，您还可以传递一个 ``Table``"
" （或子类）对象，这将克隆并添加所有字段（但 “id” 除外）到定义的表中。其他可选关键字参数包括： ``rname`` 、 "
"``redefine`` 、 ``common_filter`` 、 ``fake_migrate`` 、 ``fields`` 、 "
"``format`` 、 ``migrate`` 、 ``on_define`` 、 ``plural`` 、 ``polymodel`` 、 "
"``primarykey`` 、 ``sequence_name`` 、 ``singular`` 、 ``table_class`` 和 "
"``trigger_name``，下文将对这些进行讨论。"

#: ../../chapter-07.rst:690 ../../chapter-07.rst:4715
msgid "For example:"
msgstr "例如："

#: ../../chapter-07.rst:697
msgid ""
"It defines, stores and returns a ``Table`` object called “person” "
"containing a field (column) “name”. This object can also be accessed via "
"``db.person``, so you do not need to catch the value returned by "
"define_table."
msgstr ""
"这同时定义、存储并返回一个被称为  “person” 的 ``Table`` 对象，里面包含一个 “name” 字段（列）。这个对象也能够通过 "
"``db.person`` 访问，因此不需要捕获 ``define_table()`` 的返回值。"

#: ../../chapter-07.rst:703
msgid "``id``: Notes about the primary key"
msgstr "``id`` : 关于主键的说明"

#: ../../chapter-07.rst:705
msgid ""
"Do not declare a field called “id”, because one is created by py4web "
"anyway. Every table has a field called “id” by default. It is an auto-"
"increment integer field (usually starting at 1) used for cross-reference "
"and for making every record unique, so “id” is a primary key. (Note: the "
"id counter starting at 1 is back-end specific. For example, this does not"
" apply to the Google App Engine NoSQL.)"
msgstr ""
"不要声明一个名为 “id” 的字段，因为它是由 py4web 创建的。默认情况下，每个表都有一个名为 “id” "
"的字段。它是一个自动递增的整数字段（通常从 1 开始），这用于交叉引用和确保每条记录是唯一的，因此 “id” 是主键。（注意：从 1 开始的 id"
" 计数器是由后端数据库决定的。例如，这不适用于 Google App Engine NoSQL。）"

#: ../../chapter-07.rst:712
msgid ""
"Optionally you can define a field of ``type='id'`` and py4web will use "
"this field as auto-increment id field. This is not recommended except "
"when accessing legacy database tables which have a primary key under a "
"different name. With some limitation, you can also use different primary "
"keys using the ``primarykey`` parameter."
msgstr ""
"您可以选择定义一个类型为 “id” 的字段，py4web 会将此字段用作自动递增的 id 字段。不建议这样做，除非访问的旧数据库表具有名称不是 "
"id 的主键。在某些限制下，您还可以设置 primarykey 参数来使用不同的主键。"

#: ../../chapter-07.rst:719
msgid "``plural`` and ``singular``"
msgstr "``plural`` 和 ``singular``"

#: ../../chapter-07.rst:721
msgid ""
"As pyDAL is a general DAL, it includes plural and singular attributes to "
"refer to the table names so that external elements can use the proper "
"name for a table."
msgstr ""
"由于 pyDAL 是一个通用的 DAL，因此它包括 ``plural`` 和 ``singular`` "
"属性来引用表名，以便外部元素可以使用表的正确名称。"

#: ../../chapter-07.rst:726
msgid "``redefine``"
msgstr ""

#: ../../chapter-07.rst:728
msgid ""
"Tables can be defined only once but you can force py4web to redefine an "
"existing table:"
msgstr "表只能定义一次，但是您可以强制 py4web 重新定义一个已存在的表："

#: ../../chapter-07.rst:736
msgid "The redefinition may trigger a migration if table definition changes."
msgstr "如果表定义有变化，那么 “重新定义表” 会导致 “迁移”。"

#: ../../chapter-07.rst:739
msgid "``format``: Record representation"
msgstr "``format``: 代表记录的显示格式"

#: ../../chapter-07.rst:741
msgid ""
"It is optional but recommended to specify a format representation for "
"records with the ``format`` parameter."
msgstr "这是可选的，但建议使用 ``format`` 参数指定代表记录的显示格式。"

#: ../../chapter-07.rst:748
msgid "or"
msgstr "或者"

#: ../../chapter-07.rst:754
msgid "or even more complex ones using a function:"
msgstr "或者更复杂的情况是使用一个函数："

#: ../../chapter-07.rst:761
msgid "The format attribute will be used for two purposes:"
msgstr "``format`` 属性被用于两个目的："

#: ../../chapter-07.rst:763
msgid "To represent referenced records in select/option drop-downs."
msgstr "在 select/option 下拉菜单中表示引用的记录。"

#: ../../chapter-07.rst:764
msgid ""
"To set the ``db.othertable.otherfield.represent`` attribute for all "
"fields referencing this table. This means that the ``Form`` constructor "
"will not show references by id but will use the preferred format "
"representation instead."
msgstr ""
"为引用此表的所有字段设置 ``db.othertable.otherfield.represent`` 属性。这意味着 ``Form`` "
"构造函数不会按 id 显示引用的记录，而是以预设的格式表示。"

#: ../../chapter-07.rst:770
msgid "``rname``: Real name"
msgstr "``rname``: 真实名称"

#: ../../chapter-07.rst:772
msgid ""
"``rname`` sets a database backend name for the table. This makes the "
"py4web table name an alias, and ``rname`` is the real name used when "
"constructing the query for the backend. To illustrate just one use, "
"``rname`` can be used to provide MSSQL fully qualified table names "
"accessing tables belonging to other databases on the server: ``rname = "
"'db1.dbo.table1'``"
msgstr ""
"``rname`` 为表设置数据库后端名称。这使得 py4web 中定义的表名成为别名，而 ``rname`` "
"是构建后端查询时使用的真实名称。仅举一个例子， ``rname`` 可用于为 MSSQL 提供完全限定表名，以访问属于服务器上其他数据库的表： "
"``rname = 'db1.dbo.table1'``"

#: ../../chapter-07.rst:780
msgid "``primarykey``: Support for legacy tables"
msgstr "``primarykey``: 支持已有的旧表"

#: ../../chapter-07.rst:782
msgid ""
"``primarykey`` helps support legacy tables with existing primary keys, "
"even multi-part. See `Legacy databases and keyed tables`_."
msgstr ""
"``primarykey`` 有助于支持具有现有主键的遗留表，甚至是多字段组成主键的表。请参见 `Legacy databases and "
"keyed tables`_ 。"

#: ../../chapter-07.rst:786
msgid "``migrate``, ``fake_migrate``"
msgstr ""

#: ../../chapter-07.rst:788
msgid ""
"``migrate`` sets migration options for the table. Refer to `Migrations`_ "
"for details."
msgstr ""
"``migrate`` 设置 “表” 的 “迁移选项” ，migrate 默认值是 True ，表示 web "
"应用启动时自动对比模型与数据库中的表结构，自动添加新字段（不会修改已有字段的某些属性，也不会删除已有不用的字段）。fake_migrate "
"设置是否进行虚拟迁移，默认值是 False ，即不实际修改数据库结构，仅更新应用中的模型数据。详情请参阅 `Migrations`_ "

#: ../../chapter-07.rst:792
msgid "``table_class``"
msgstr ""

#: ../../chapter-07.rst:794
msgid ""
"If you define your own table class as a sub-class of pydal.objects.Table,"
" you can provide it here; this allows you to extend and override methods."
" Example:"
msgstr "如果定义了一个 pydal.objects.Table 的子类，你可以设置给这个参数；这允许你扩展和重写方法，例如："

#: ../../chapter-07.rst:808
msgid "``sequence_name``"
msgstr ""

#: ../../chapter-07.rst:810
msgid ""
"The name of a custom table sequence (if supported by the database). Can "
"create a SEQUENCE (starting at 1 and incrementing by 1) or use this for "
"legacy tables with custom sequences."
msgstr "自定义表序列的名称（如果数据库支持）。可以创建 SEQUENCE（从 1 开始，每次递增 1），也可以将其用于具有自定义序列的旧表。"

#: ../../chapter-07.rst:814
msgid ""
"Note that when necessary, py4web will create sequences automatically by "
"default."
msgstr "请注意，默认情况下 py4web 会在必要时自动创建序列。"

#: ../../chapter-07.rst:818
msgid "``trigger_name``"
msgstr ""

#: ../../chapter-07.rst:820
msgid ""
"Relates to ``sequence_name``. Relevant for some backends which do not "
"support auto-increment numeric fields."
msgstr "与 ``sequence_name`` 相关。与某些不支持自动递增数字字段的后端相关。"

#: ../../chapter-07.rst:824
msgid "``polymodel``"
msgstr ""

#: ../../chapter-07.rst:826
msgid "For use with Google App Engine."
msgstr "用于 Google App Engine 。"

#: ../../chapter-07.rst:829
msgid "``on_define``"
msgstr ""

#: ../../chapter-07.rst:831
msgid ""
"``on_define`` is a callback triggered when a lazy_table is instantiated, "
"although it is called anyway if the table is not lazy. This allows "
"dynamic changes to the table without losing the advantages of delayed "
"instantiation."
msgstr ""
"``on_define`` 是一个在实例化 lazy_table 时触发的回调，即使表不是 “懒惰” "
"的，它仍会被调用。这允许对表进行动态更改，而不会失去延迟实例化的优点。"

#: ../../chapter-07.rst:836
msgid "Example:"
msgstr "例如："

#: ../../chapter-07.rst:848
msgid ""
"Note this example shows how to use ``on_define`` but it is not actually "
"necessary. The simple ``requires`` values could be added to the Field "
"definitions and the table would still be lazy. However, ``requires`` "
"which take a Set object as the first argument, such as IS_IN_DB, will "
"make a query like ``db.sometable.somefield == some_value`` which would "
"cause ``sometable`` to be defined early. This is the situation saved by "
"``on_define``."
msgstr ""
"注意，这个例子展示了如何使用 ``on_define`` ，但实际上是没必要的。简单的 ``requires`` 参数值可以添加到 Field "
"的定义中，而表仍会保持 “懒惰”。然而， ``requires`` 以 Set 对象作为第一个参数的话，如 IS_IN_DB，将发出类似 "
"``db.sometable.somefield == some_value`` 的查询，这会导致 ``sometable`` "
"提前按定义被创建。这种情况下，就要保留 ``on_define`` 。"

#: ../../chapter-07.rst:857
msgid "Adding attributes to fields and tables"
msgstr "向字段和表添加属性"

#: ../../chapter-07.rst:859
#, python-brace-format
msgid ""
"If you need to add custom attributes to fields, you can simply do this: "
"``db.table.field.extra = {}``"
msgstr "如果需要向字段添加自定义的属性，只需简单地这样做：``db.table.field.extra = {}``"

#: ../../chapter-07.rst:862
msgid ""
"“extra” is not a keyword; it’s a custom attribute now attached to the "
"field object. You can do it with tables too but they must be preceded by "
"an underscore to avoid naming conflicts with fields:"
msgstr ""
"“extra” "
"不是一个关键字；现在，它是一个被附加到字段对象的自定义的属性。对于表也可以这样处理，但是表的自定义属性必须以下划线开始，以避免与字段发生命名冲突。"

#: ../../chapter-07.rst:871
msgid "Legacy databases and keyed tables"
msgstr "已有的数据库和指定主键的表"

#: ../../chapter-07.rst:873
msgid "py4web can connect to legacy databases under some conditions."
msgstr "在某些情况下，py4web 可以连接到已有的数据库"

#: ../../chapter-07.rst:875
msgid "The easiest way is when these conditions are met:"
msgstr "最简单的方法是满足以下条件："

#: ../../chapter-07.rst:877
msgid "Each table must have a unique auto-increment integer field called “id”."
msgstr "每个表都必须有一个名为 “id” 的唯一自动递增的整数字段。"

#: ../../chapter-07.rst:878
msgid "Records must be referenced exclusively using the “id” field."
msgstr "必须仅使用 “id” 字段引用记录。"

#: ../../chapter-07.rst:880
msgid ""
"When accessing an existing table, i.e., a table not created by py4web in "
"the current application, always set ``migrate=False``."
msgstr "访问现有表（即不是由 py4web 在当前应用程序中创建的表）时，始终设置参数 ``migrate=False``。"

#: ../../chapter-07.rst:883
msgid ""
"If the legacy table has an auto-increment integer field but it is not "
"called “id”, py4web can still access it but the table definition must "
"declare the auto-increment field with ‘id’ type (that is using "
"``Field('...', 'id')``)."
msgstr ""
"如果旧表有一个自动递增的整数字段，但它没有被命名为 “id” ，py4web 仍然可以访问它，但表定义必须用 “id” "
"类型声明自动递增字段（即使用 ``Field('...', 'id')`` ）。"

#: ../../chapter-07.rst:888
msgid ""
"Finally if the legacy table uses a primary key that is not an auto-"
"increment id field it is possible to use a “keyed table”, for example:"
msgstr "最后，如果遗留表使用的主键不是自动递增的 id 字段，则可以使用 “指定主键的表”，例如："

#: ../../chapter-07.rst:901
msgid "``primarykey`` is a list of the field names that make up the primary key."
msgstr "``primarykey`` 是构成主键的字段名列表。"

#: ../../chapter-07.rst:903
msgid "All primarykey fields have a ``NOT NULL`` set even if not specified."
msgstr "即使未指定，所有主键字段都被设置为 ``NOT NULL`` 。"

#: ../../chapter-07.rst:904
msgid "Keyed tables can only reference other keyed tables."
msgstr "“指定主键的表” 只能引用其它 “指定主键的表” 。"

#: ../../chapter-07.rst:905
msgid "Referencing fields must use the ``reference tablename.fieldname`` format."
msgstr "引用字段必须使用 ``reference tablename.fieldname`` 格式。"

#: ../../chapter-07.rst:907
msgid "The ``update_record`` function is not available for Rows of keyed tables."
msgstr "``update_record`` 函数不适用于 “指定主键的表” 的数据行。"

#: ../../chapter-07.rst:912
msgid ""
"Currently keyed tables are only supported for DB2, MSSQL, Ingres and "
"Informix, but others engines will be added."
msgstr "目前， “指定主键的表” 仅支持 DB2、MSSQL、Ingres 和 Informix ，但会继续添加其他引擎。"

#: ../../chapter-07.rst:915
msgid ""
"At the time of writing, we cannot guarantee that the ``primarykey`` "
"attribute works with every existing legacy table and every supported "
"database backend. For simplicity, we recommend, if possible, creating a "
"database view that has an auto-increment id field."
msgstr ""
"在撰写本文时，我们无法保证 ``primarykey`` "
"属性适用于每个现有的遗留表和每个支持的数据库后端。为了简单起见，如果可能的话，我们建议创建一个具有自动递增 id 字段的数据库视图。"

#: ../../chapter-07.rst:922
msgid "Field constructor"
msgstr "“Field” 的构造函数"

#: ../../chapter-07.rst:924
msgid "These are the default values of a Field constructor:"
msgstr "下面是 “Field” 的构造函数的默认值"

#: ../../chapter-07.rst:938
msgid ""
"where DEFAULT is a special value used to allow the value None for a "
"parameter."
msgstr "其中，DEFAULT 是个特殊的值，它允许参数的值是 None。"

#: ../../chapter-07.rst:941
msgid ""
"Not all of them are relevant for every field. ``length`` is relevant only"
" for fields of type “string”. ``uploadfield``, ``authorize``, and "
"``autodelete`` are relevant only for fields of type “upload”. "
"``ondelete`` is relevant only for fields of type “reference” and "
"“upload”."
msgstr ""
"并非所有的参数对每个字段都有意义。``length`` 仅适用于 “string” 类型的字段。``uploadfield`` 、 "
"``authorize`` 和 ``autodelete`` 仅适用于 “upload” 类型的字段。``ondelete`` 仅适用于 "
"“reference” 或 “upload” 类型的字段。"

#: ../../chapter-07.rst:947
msgid ""
"``length`` sets the maximum length of a “string”, “password” or “upload” "
"field. If ``length`` is not specified a default value is used but the "
"default value is not guaranteed to be backward compatible. *To avoid "
"unwanted migrations on upgrades, we recommend that you always specify the"
" length for string, password and upload fields.*"
msgstr ""
"``length`` 设置 “string”、 “password” 或 “upload” 字段的最大长度。如果未指定 ``length`` "
"，则使用默认值，但不能保证默认值向后兼容。 *为了避免升级时产生未知的 “迁移”，我们建议您始终指定 “string”、 “password” 或"
" “upload” 字段的长度。* "

#: ../../chapter-07.rst:953
msgid ""
"``default`` sets the default value for the field. The default value is "
"used when performing an insert if a value is not explicitly specified. It"
" is also used to pre-populate forms built from the table using ``Form``. "
"Note, rather than being a fixed value, the default can instead be a "
"function (including a lambda function) that returns a value of the "
"appropriate type for the field. In that case, the function is called once"
" for each record inserted, even when multiple records are inserted in a "
"single transaction."
msgstr ""
"``default`` 设置字段的 “默认值”。当插入数据但未明确指定字段值的时候，就使用 “默认值”。它还用于使用 ``Form`` 从 "
"“Table” 构建预填充的表单。请注意，默认值不是固定值，它可以是一个函数（包括 lambda "
"函数），它为字段返回适当类型的值。在这种情况下，即使在单个事务中插入了多条记录，该函数也会为插入的每条记录调用一次。"

#: ../../chapter-07.rst:961
msgid ""
"``required`` tells the DAL that no insert should be allowed on this table"
" if a value for this field is not explicitly specified."
msgstr "``required`` 告知 DAL，如果没有明确指定字段的值，那么不允许在表内插入数据。"

#: ../../chapter-07.rst:963
msgid ""
"``requires`` is a **validator** or a list of validators. This is not used"
" by the DAL, but instead it is used by ``Form`` (this will be explained "
"better on the :ref:`Forms` chapter). The default validators for the given"
" types are shown in the next section :ref:`Field types and validators`."
msgstr ""
"``requires`` 一个 **验证器**，或是多个验证器的列表。DAL 中不使用这里指定的验证器，相反，它们在 ``Form`` "
"里面被使用。（ :ref:`Forms` 章节由更好的解释）在后面的 :ref:`Field types and validators` "
"部分，给出了各种已知字段类型的默认验证器。详细内容请参考 `web2py 框架中 pyDAL 模块的验证器 "
"<https://web2py.com/books/default/chapter/29/07/forms-and-"
"validators#Validators>`_"

#: ../../chapter-07.rst:971
msgid ""
"while ``requires=...`` is enforced at the level of forms, "
"``required=True`` is enforced at the level of the DAL (insert). In "
"addition, ``notnull``, ``unique`` and ``ondelete`` are enforced at the "
"level of the database. While they sometimes may seem redundant, it is "
"important to maintain the distinction when programming with the DAL."
msgstr ""
"``requires=...`` 是在 form 级别被强制执行，而 ``required=True`` 在 "
"DAL（插入）级别被强制执行。此外，在数据库级别强制执行 ``notnull`` 、 ``unique`` 和 ``ondelete`` "
"。虽然它们有时看起来是多余的，但在使用 DAL 编程时保持这种区别很重要。"

#: ../../chapter-07.rst:978
msgid ""
"``rname`` provides the field with a “real name”, a name for the field "
"known to the database adapter; when the field is used, it is the rname "
"value which is sent to the database. The py4web name for the field is "
"then effectively an alias."
msgstr ""
"``rname`` 为字段提供 “真实名称”，一个数据库适配已知的字段名称；当使用字段时，发送到数据库的是 “rname” 值。字段的 "
"py4web 名称会失效，就变成了字段的别名。"

#: ../../chapter-07.rst:983
msgid ""
"``ondelete`` translates into the “ON DELETE” SQL statement. By default it"
" is set to “CASCADE”. This tells the database that when it deletes a "
"record, it should also delete all records that refer to it. To disable "
"this feature, set ``ondelete`` to “NO ACTION” or “SET NULL”."
msgstr ""
"``ondelete`` 被转换为 “ON DELETE” SQ L语句。默认情况下，它设置为 "
"“CASCADE”。这告诉数据库，当它删除记录时，还应该删除引用它的所有记录。若要禁用此功能，请将 ``ondelete`` 设置为 “NO "
"ACTION” 或 “set NULL” 。"

#: ../../chapter-07.rst:989
msgid ""
"``notnull=True`` translates into the “NOT NULL” SQL statement. It "
"prevents the database from inserting null values for the field."
msgstr "``notnull=True`` 被转换为  “NOT NULL” SQ L语句。这阻止数据库为字段插入 null 值。"

#: ../../chapter-07.rst:992
msgid ""
"``unique=True`` translates into the “UNIQUE” SQL statement and it makes "
"sure that values of this field are unique within the table. It is "
"enforced at the database level."
msgstr "``unique=True``  被转换为  “UNIQUE”  SQ L语句，它确保字段的值在表里是唯一的。这在数据库级别强制执行。"

#: ../../chapter-07.rst:996
msgid ""
"``uploadfield`` applies only to fields of type “upload”. A field of type "
"“upload” stores the name of a file saved somewhere else, by default on "
"the filesystem under the application “uploads/” folder. If "
"``uploadfield`` is set to True, then the file is stored in a blob field "
"within the same table and the value of ``uploadfield`` is the name of the"
" blob field. This will be discussed in more detail later in `More on "
"uploads`_."
msgstr ""
"``uploadfield`` 仅适用于 “upload” 类型的字段。“upload” "
"类型的字段存储已保存在其它地方的文件名，默认是在文件系统中 “应用程序” 的 “uploads/” 目录下。如果 ``uploadfield`` "
"设置为 True，那么文件被存储在同一个表的二进制字段内， ``uploadfield`` 的值是二进制字段的名称。稍后，在 `More on "
"uploads`_ 中进行更详细地讨论。"

#: ../../chapter-07.rst:1003
#, python-brace-format
msgid ""
"``uploadfolder`` must be set to a location where to store uploaded files."
" The scaffolding app defines a folder ``settings.UPLOAD_FOLDER`` which "
"points to ``apps/{app_name}/uploads`` so you can set, for example, "
"``Field(... uploadfolder=settings.UPLOAD_FOLDER)``."
msgstr ""
"``uploadfolder`` 必须被设置为一个存储已上传文件的位置。 scaffolding 应用程序定义了一个文件夹 "
"``settings.UPLOAD_FOLDER`` ，它指向 ``apps/{app_name}/uploads`` ，因此，你能这样设置： "
"``Field(... uploadfolder=settings.UPLOAD_FOLDER)``。"

#: ../../chapter-07.rst:1007
msgid ""
"``uploadseparate`` if set to True will upload files under different "
"subfolders of the *uploadfolder* folder. This is optimized to avoid too "
"many files under the same folder/subfolder. ATTENTION: You cannot change "
"the value of ``uploadseparate`` from True to False without breaking links"
" to existing uploads. pydal either uses the separate subfolders or it "
"does not. Changing the behavior after files have been uploaded will "
"prevent pydal from being able to retrieve those files. If this happens it"
" is possible to move files and fix the problem but this is not described "
"here."
msgstr ""
"如果设置 ``uploadseparate`` 为 True，那么将会把文件上传到  *uploadfolder* "
"指定的文件夹下的不同的子文件夹下。这是为了避免同一文件夹/子文件夹下有太多文件而优化的。注意：如果不断开现有已上传的文件链接，则无法将  "
"``uploadseparate``  的值从 True 更改为 False。pydal "
"要么使用单独的子文件夹，要么不使用。在文件上传后的更改行为将阻止 pydal "
"检索到这些文件。如果发生这种情况，可以移动文件并修复问题，但这里没有描述。"

#: ../../chapter-07.rst:1016
msgid ""
"``uploadfs`` allows you specify a different file system where to upload "
"files, including an Amazon S3 storage or a remote SFTP storage."
msgstr "``uploadfs`` 允许你为上传文件指定一个不同的文件系统，包括 Amazon S3 存储系统或者远程 SFTP 存储系统。"

#: ../../chapter-07.rst:1022
msgid ""
"You need to have PyFileSystem installed for this to work. ``uploadfs`` "
"must point to PyFileSystem."
msgstr "您需要安装 PyFileSystem 才能正常工作。 ``uploadfs`` 必须指向 PyFileSystem。"

#: ../../chapter-07.rst:1025
msgid ""
"``autodelete`` determines if the corresponding uploaded file should be "
"deleted when the record referencing the file is deleted. For “upload” "
"fields only. However, records deleted by the database itself due to a "
"CASCADE operation will not trigger py4web’s autodelete."
msgstr ""
"``autodelete`` 确定在删除引用文件的记录时是否应删除相应的上传文件，这仅适用于 “upload” 字段。但是，因 CASCADE "
"操作导致由数据库本身删除记录时不会触发 py4web 的自动删除。"

#: ../../chapter-07.rst:1030
msgid ""
"``label`` is a string (or a helper or something that can be serialized to"
" a string that contains the label to be used for this field in auto-"
"generated forms.) that contains a comment associated with this field, and"
" will be displayed to the right of the input field in the autogenerated "
"forms."
msgstr ""
"``label`` "
"是一个字符串（或辅助程序，或可以序列化为字符串的东西，它包含自动生成的表单中用于此字段的标签），该字符串包含与此字段相关联的说明文字，且会显示在自动生成表单的输入框右侧。"

#: ../../chapter-07.rst:1035
msgid "``writable`` declares whether a field is writable in forms."
msgstr "``writable`` 声明一个字段的值在表单中是否可写（编辑）。"

#: ../../chapter-07.rst:1036
msgid ""
"``readable`` declares whether a field is readable in forms. If a field is"
" neither readable nor writable, it will not be displayed in create and "
"update forms."
msgstr ""
"``readable`` 声明一个字段的值在表单中是否可读（是否显示）。如果一个字段既不可读也不可写，它将不会在 create 或 update "
"类型的表单中显示。"

#: ../../chapter-07.rst:1039
msgid ""
"``update`` contains the default value for this field when the record is "
"updated."
msgstr "``update`` 包含更新记录时这个字段的默认更新的值。"

#: ../../chapter-07.rst:1041
msgid ""
"``compute`` is an optional function. If a record is inserted or updated, "
"the compute function will be executed and the field will be populated "
"with the function result. The record is passed to the compute function as"
" a ``dict``, and the dict will not include the current value of that, or "
"any other compute field."
msgstr ""
"``compute`` 是一个可选函数。插入或更新记录后，compute 函数将被执行，然后以函数的返回值作为字段的值。当前记录以一个 "
"``dict`` 的形式被传给 compute 函数时，被传递的 “字典” 里不包含这个 compute 字段的当前值，也不包含其它 "
"compute 字段。"

#: ../../chapter-07.rst:1046
msgid ""
"``authorize`` can be used to require access control on the corresponding "
"field, for “upload” fields only. It will be discussed more in detail in "
"the context of Authentication and Authorization."
msgstr "``authorize`` 可用于要求对相应字段进行访问控制，仅适用于 “upload”  字段。这将在身份验证和授权的部分进行更详细的讨论。"

#: ../../chapter-07.rst:1049
msgid ""
"``widget`` Do NOT use the widget parameter in py4web for a Field "
"definition. (This was a feature of web2py and is not to be used in "
"py4web) See :ref:`Widgets` later."
msgstr ""
"``widget`` 注意，在 py4web 中，字段定义 **不要使用 widget 参数** 。（这是 web2py 的特性，而且在 "
"py4web 里未被使用）请参阅后面的 :ref:`Widgets` "

#: ../../chapter-07.rst:1052
msgid ""
"``represent`` can be None or can point to a function that takes a field "
"value and returns an alternate representation for the field value."
msgstr "``represent`` 可以是 None，也可以指向一个函数，该函数接受字段当前值并返回字段值的替代表示形式。"

#: ../../chapter-07.rst:1057
msgid "Thread safety and Field attributes"
msgstr "线程安全和字段属性"

#: ../../chapter-07.rst:1059
msgid ""
"Even though py4web and web2py use the same pyDAL, there is an important "
"difference which stems from the core architecture of py4web. In py4web "
"only the following ``Field`` attributes can be changed inside an action:"
msgstr ""
"尽管 py4web 和 web2py 使用相同的 pyDAL，但是由 py4web 的核心架构导致了存在重要差异。在 py4web 中，只有以下 "
"``Field`` 属性可以在 action 中更改："

#: ../../chapter-07.rst:1063
msgid "``readable``"
msgstr ""

#: ../../chapter-07.rst:1064
msgid "``writable``"
msgstr ""

#: ../../chapter-07.rst:1065
msgid "``default``"
msgstr ""

#: ../../chapter-07.rst:1066
msgid "``filter_in``"
msgstr ""

#: ../../chapter-07.rst:1067
msgid "``filter_out``"
msgstr ""

#: ../../chapter-07.rst:1068
msgid "``label``"
msgstr ""

#: ../../chapter-07.rst:1069
msgid "``update``"
msgstr ""

#: ../../chapter-07.rst:1070
msgid "``requires``"
msgstr ""

#: ../../chapter-07.rst:1071
msgid "``widget``"
msgstr ""

#: ../../chapter-07.rst:1072
msgid "``represent``"
msgstr ""

#: ../../chapter-07.rst:1074
msgid ""
"These are reset to their original values before each action is called. "
"All other ``Field``, ``DAL``, and ``Table`` attributes are global and "
"non-thread-safe."
msgstr ""
"在调用每个 action 之前，这些值都将重置为原始值。所有其他 ``Field``、 ``DAL`` 和 ``Table`` "
"都是全局的、非线程安全的。"

#: ../../chapter-07.rst:1077
msgid ""
"This limitation exists because py4web executes table definitions only at "
"startup, unlike web2py which re-defines tables on each request. This "
"makes py4web a lot faster than web2py, but you need to be careful as "
"modifying non-thread-safe attributes in actions can cause race conditions"
" and bugs."
msgstr ""
"这种限制的存在是因为 py4web 只在启动时执行表定义，而 web2py 在每次请求时都会重新定义表。这使得 py4web 比 web2py "
"快得多，但你需要小心，因为修改 actions 中的非线程安全属性可能会导致冲突和错误。"

#: ../../chapter-07.rst:1084
msgid "Field types and validators"
msgstr "字段的类型和验证器"

#: ../../chapter-07.rst:1087
msgid "Type"
msgstr "类型"

#: ../../chapter-07.rst:1087
msgid "Default validators"
msgstr "默认验证器"

#: ../../chapter-07.rst:1089
msgid "``string``"
msgstr ""

#: ../../chapter-07.rst:1089 ../../chapter-07.rst:1099
msgid "``IS_LENGTH(length)`` default length is 512"
msgstr "``IS_LENGTH(length)`` 默认长度为 512"

#: ../../chapter-07.rst:1090
msgid "``text``"
msgstr ""

#: ../../chapter-07.rst:1090
msgid "``IS_LENGTH(length)`` default length is 32768"
msgstr "``IS_LENGTH(length)`` 默认长度为 32768"

#: ../../chapter-07.rst:1091
msgid "``blob``"
msgstr ""

#: ../../chapter-07.rst:1091
msgid "``None`` default length is 2**31 (2 GiB)"
msgstr "``None``  默认长度为 2**31（2 GiB）"

#: ../../chapter-07.rst:1092
msgid "``boolean``"
msgstr ""

#: ../../chapter-07.rst:1092 ../../chapter-07.rst:1102
#: ../../chapter-07.rst:1103 ../../chapter-07.rst:1107
#: ../../chapter-07.rst:1108
msgid "``None``"
msgstr ""

#: ../../chapter-07.rst:1093
msgid "``integer``"
msgstr ""

#: ../../chapter-07.rst:1093
msgid "``IS_INT_IN_RANGE(-2**31, 2**31)``"
msgstr ""

#: ../../chapter-07.rst:1094
msgid "``double``"
msgstr ""

#: ../../chapter-07.rst:1094
msgid "``IS_FLOAT_IN_RANGE(-1e100, 1e100)``"
msgstr ""

#: ../../chapter-07.rst:1095
msgid "``decimal(n,m)``"
msgstr ""

#: ../../chapter-07.rst:1095
msgid "``IS_DECIMAL_IN_RANGE(-10**10, 10**10)``"
msgstr ""

#: ../../chapter-07.rst:1096
msgid "``date``"
msgstr ""

#: ../../chapter-07.rst:1096
msgid "``IS_DATE()``"
msgstr ""

#: ../../chapter-07.rst:1097
msgid "``time``"
msgstr ""

#: ../../chapter-07.rst:1097
msgid "``IS_TIME()``"
msgstr ""

#: ../../chapter-07.rst:1098
msgid "``datetime``"
msgstr ""

#: ../../chapter-07.rst:1098
msgid "``IS_DATETIME()``"
msgstr ""

#: ../../chapter-07.rst:1099
msgid "``password``"
msgstr ""

#: ../../chapter-07.rst:1100
msgid "``upload``"
msgstr ""

#: ../../chapter-07.rst:1100
msgid "``None`` default length is 512"
msgstr "``None`` 默认长度是512"

#: ../../chapter-07.rst:1101
msgid "``reference <table>``"
msgstr ""

#: ../../chapter-07.rst:1101
msgid "``IS_IN_DB(db, table.field, format)``"
msgstr ""

#: ../../chapter-07.rst:1102
msgid "``list:string``"
msgstr ""

#: ../../chapter-07.rst:1103
msgid "``list:integer``"
msgstr ""

#: ../../chapter-07.rst:1104
msgid "``list:reference <table>``"
msgstr ""

#: ../../chapter-07.rst:1104
msgid "``IS_IN_DB(db, table._id, format, multiple=True)``"
msgstr ""

#: ../../chapter-07.rst:1105
msgid "``json``"
msgstr ""

#: ../../chapter-07.rst:1105
msgid "``IS_EMPTY_OR(IS_JSON())`` default length is 512"
msgstr "``IS_EMPTY_OR(IS_JSON())``  默认长度是512"

#: ../../chapter-07.rst:1106
msgid "``bigint``"
msgstr ""

#: ../../chapter-07.rst:1106
msgid "``IS_INT_IN_RANGE(-2**63, 2**63)``"
msgstr ""

#: ../../chapter-07.rst:1107
msgid "``big-id``"
msgstr ""

#: ../../chapter-07.rst:1108
msgid "``big-reference``"
msgstr ""

#: ../../chapter-07.rst:1111
msgid ""
"Decimal requires and returns values as ``Decimal`` objects, as defined in"
" the Python ``decimal`` module. SQLite does not handle the ``decimal`` "
"type so internally we treat it as a ``double``. The (n,m) are the number "
"of digits in total and the number of digits after the decimal point "
"respectively."
msgstr ""
"Decimal 要求值是 Decimal 对象，返回值也是，在 Python 的 ``decimal`` 模块中有定义。SQLite 不处理 "
"``decimal`` 类型，因此在 SQLite 内部将其视为 ``double``。（n，m）分别是总数和小数点后的位数。"

#: ../../chapter-07.rst:1117
msgid ""
"The ``big-id`` and, ``big-reference`` are only supported by some of the "
"database engines and are experimental. They are not normally used as "
"field types unless for legacy tables, however, the DAL constructor has a "
"``bigint_id`` argument that when set to ``True`` makes the ``id`` fields "
"and ``reference`` fields ``big-id`` and ``big-reference`` respectively."
msgstr ""
"``big-id`` 和 ``big-reference`` "
"仅有一些数据库引擎支持，并且是实验性的。它们通常不用作字段类型，除非用于已有的旧表，但是，DAL 构造函数有一个 ``bigint_id`` "
"参数，当设置为 True 时，``id`` 字段和 ``reference`` 字段分别为 ``big-id`` 和 ``big-"
"reference`` 。"

#: ../../chapter-07.rst:1123
msgid ""
"The ``list:<type>`` fields are special because they are designed to take "
"advantage of certain denormalization features on NoSQL (in the case of "
"Google App Engine NoSQL, the field types ``ListProperty`` and "
"``StringListProperty``) and back-port them all the other supported "
"relational databases. On relational databases lists are stored as a "
"``text`` field. The items are separated by a ``|`` and each ``|`` in "
"string item is escaped as a ``||``. They are discussed in :ref:`list_type"
" and contains`."
msgstr ""
"``list:<type>`` 字段是特殊的，因为它们被设计为利用 NoSQL 上的某些非规范化特性（在 Google App Engine "
"NoSQL 的情况下，字段类型 ``ListProperty`` 和 "
"``StringListProperty``），并将它们移植到所有其他支持的关系数据库中。在关系数据库中，列表存储为文本字段。这些项用 ``|``"
" 分隔，而字符串项中的每个 ``|`` 都转义为 ``||`` 。它们在 :ref:`list_type and contains` 中讨论。"

#: ../../chapter-07.rst:1132
msgid ""
"The ``json`` field type is pretty much explanatory. It can store any JSON"
" serializable object. It is designed to work specifically for MongoDB and"
" backported to the other database adapters for portability."
msgstr ""
"``json`` 字段类型的含义相当直观。它可以存储任何可 JSON 序列化的对象。该字段类型专为 MongoDB "
"设计以实现特定适配，同时为确保可移植性，也反向兼容了其他数据库适配器。"

#: ../../chapter-07.rst:1136
msgid ""
"``blob`` fields are also special. By default, binary data is encoded in "
"base64 before being stored into the actual database field, and it is "
"decoded when extracted. This has the negative effect of using 33% more "
"storage space than necessary in blob fields, but has the advantage of "
"making the communication independent of the back-end specific escaping "
"conventions."
msgstr ""
"``blob`` 字段同样具有特殊性。默认情况下，二进制数据在存入实际数据库字段之前会先进行 Base64 "
"编码，提取数据时则会进行解码。这种处理方式的缺点是，会导致 Blob 字段占用比实际所需多 33% "
"的存储空间；但优点在于，能让数据传输摆脱后端特定转义规则的限制，实现解耦。"

#: ../../chapter-07.rst:1144
msgid "Run-time field and table modification"
msgstr "在运行时修改字段和表"

#: ../../chapter-07.rst:1146
msgid ""
"Most attributes of fields and tables can be modified after they are "
"defined:"
msgstr "字段和表的大部分属性都可以在它们的定义后进行修改。"

#: ../../chapter-07.rst:1156
msgid ""
"notice that attributes of tables are usually prefixed by an underscore to"
" avoid conflict with possible field names."
msgstr "请注意，表的属性通常以下划线作为前缀，以避免与可能的字段名冲突。"

#: ../../chapter-07.rst:1159
msgid ""
"You can list the tables that have been defined for a given database "
"connection:"
msgstr "您可以由给定数据库连接列出已定义的表："

#: ../../chapter-07.rst:1167
msgid "You can query for the type of a table:"
msgstr "您可以查询表的类型："

#: ../../chapter-07.rst:1174
msgid "You can access a table using different syntaxes:"
msgstr "你可以使用不同的语法访问表："

#: ../../chapter-07.rst:1181
msgid "You can also list the fields that have been defined for a given table:"
msgstr "您还可以由给定的表列出已定义的字段："

#: ../../chapter-07.rst:1188
msgid ""
"Similarly you can access fields from their name in multiple equivalent "
"ways:"
msgstr "同样，您可以通过多种等效的方式依据字段名称访问字段："

#: ../../chapter-07.rst:1198
msgid "Given a field, you can access the attributes set in its definition:"
msgstr "给定一个字段，您可以访问其定义中的属性集："

#: ../../chapter-07.rst:1211
msgid "including its parent table, tablename, and parent connection:"
msgstr "包括它所属的表、表名称和所属的连接"

#: ../../chapter-07.rst:1222
msgid ""
"A field also has methods. Some of them are used to build queries and we "
"will see them later. A special method of the field object is ``validate``"
" and it calls the validators for the field."
msgstr "字段也有方法。其中一些用于构建查询，我们稍后会看到它们。字段对象的一种特殊方法是 ``validate`` ，它调用字段的验证器。"

#: ../../chapter-07.rst:1231
msgid ""
"which returns a tuple ``(value, error)``. ``error`` is ``None`` if the "
"input passes validation."
msgstr "验证器发回一个元组  ``(value, error)``。如果验证成功通过 ``error`` 的值是 None。"

#: ../../chapter-07.rst:1235
msgid "More on uploads"
msgstr "“上传” 的更多内容"

#: ../../chapter-07.rst:1239
msgid "Consider the following model:"
msgstr "考虑以下模型："

#: ../../chapter-07.rst:1246
msgid ""
"In the case of an “upload” field, the default value can optionally be set"
" to a path (an absolute path or a path relative to the current app "
"folder), the default value is then assigned to each new record that does "
"not specify an image."
msgstr ""
"在 “upload” "
"字段的情况下，可选择将默认值设为一个路径（可以是绝对路径，也可以是相对于当前应用文件夹的相对路径）；对于包含未指定路径的图片的每条新记录，系统会自动为其分配该默认值。"

#: ../../chapter-07.rst:1251
msgid ""
"Notice that this way multiple records may end to reference the same "
"default image file and this could be a problem on a Field having "
"``autodelete`` enabled. When you do not want to allow duplicates for the "
"image field (i.e. multiple records referencing the same file) but still "
"want to set a default value for the “upload” then you need a way to copy "
"the default file for each new record that does not specify an image. This"
" can be obtained using a file-like object referencing the default file as"
" the ``default`` argument to Field, or even with:"
msgstr ""
"请注意，这样多条记录可能会引用同一个默认图像文件，这在启用了 ``autodelete`` "
"的字段上可能会出现问题。当您不想允许图像字段重复（即多个记录引用同一文件），但仍想为 “upload” "
"设置默认值时，就需要一种方法为每条包含未指路径的图像的新记录复制默认文件。这可以通过使用引用默认文件的 “类文件对象” 作为字段的 "
"``default`` 参数值，甚至可以使用："

#: ../../chapter-07.rst:1264
msgid ""
"Normally an insert is handled automatically via a ``Form`` but "
"occasionally you already have the file on the filesystem and want to "
"upload it programmatically. This can be done in this way:"
msgstr "通常，“插入” 是通过 ``Form`` 自动处理的，但有时您已经在文件系统上拥有该文件，并希望以编程方式上传它。这可以通过以下方式完成："

#: ../../chapter-07.rst:1273
msgid ""
"It is also possible to insert a file in a simpler way and have the insert"
" method call ``store`` automatically:"
msgstr "也可以以更简单的方式插入文件，并使插入方法自动调用 ``store`` ："

#: ../../chapter-07.rst:1281
msgid "In this case the filename is obtained from the stream object if available."
msgstr "在这种情况下，文件名是从流对象（如果可用）中获得的。"

#: ../../chapter-07.rst:1284
msgid ""
"The ``store`` method of the upload field object takes a file stream and a"
" filename. It uses the filename to determine the extension (type) of the "
"file, creates a new temp name for the file (according to py4web upload "
"mechanism) and loads the file content in this new temp file (under the "
"uploads folder unless specified otherwise). It returns the new temp name,"
" which is then stored in the ``image`` field of the ``db.myfile`` table."
msgstr ""
"上传字段对象的 ``store`` 方法接受一个文件流和一个文件名。它使用文件名来确定文件的扩展名（文件类型），为文件创建一个新的临时名称（根据 "
"py4web 上传机制），并将文件内容加载到这个新的临时文件中（若无额外说明，则自动在 uploads "
"文件夹下保存临时文件）。它返回新的临时名称，然后将其存储在 ``db.myfile`` 表的 ``image`` 字段中。"

#: ../../chapter-07.rst:1292
msgid ""
"Note, if the file is to be stored in an associated blob field rather than"
" the file system, the ``store`` method will not insert the file in the "
"blob field (because ``store`` is called before the insert), so the file "
"must be explicitly inserted into the blob field:"
msgstr ""
"请注意，如果文件要存储在关联的二进制字段而不是文件系统中，则 ``store`` 方法不会将文件插入二进制字段中（因为 ``store`` "
"在插入之前被调用），因此必须将文件显式插入二进制字段："

#: ../../chapter-07.rst:1306
msgid "The ``retrieve`` method does the opposite of ``store``."
msgstr "``retrieve`` 方法与 ``store`` 的作用相反。"

#: ../../chapter-07.rst:1308
msgid ""
"When uploaded files are stored on filesystem (as in the case of a plain "
"``Field('image', 'upload')``) the code:"
msgstr "当上传的文件存储在文件系统中时（如普通的 ``Field('image', 'upload')`` 情况），代码："

#: ../../chapter-07.rst:1316
msgid ""
"retrieves the original file name (filename) as seen by the user at upload"
" time and the name of stored file (fullname, with path relative to "
"application folder). While in general the call:"
msgstr "检索用户在上传时看到的原始文件名（文件名）和存储文件的名称（全名，带有相对于应用程序文件夹的路径）。而一般地调用："

#: ../../chapter-07.rst:1324
msgid ""
"retrieves the original file name (filename) and a file-like object ready "
"to access uploaded file data (stream)."
msgstr "将检索原始文件名（文件名）和类文件对象，以准备访问上传文件数据（流）。"

#: ../../chapter-07.rst:1327
msgid ""
"Notice that the stream returned by ``retrieve`` is a real file object in "
"the case that uploaded files are stored on filesystem. In that case "
"remember to close the file when you are done, calling ``stream.close()``."
msgstr ""
"请注意，在上传的文件存储在文件系统上的情况下， ``retrieve`` 返回的流是一个真实的文件对象。在这种情况下，记得在完成后调用  "
"``stream.close()`` 关闭文件。"

#: ../../chapter-07.rst:1332
msgid "Here is an example of safe usage of ``retrieve``:"
msgstr "这里的例子是 ``retrieve`` 的安全用法："

#: ../../chapter-07.rst:1345
msgid "Migrations"
msgstr "迁移"

#: ../../chapter-07.rst:1347
msgid "With our example table definition:"
msgstr "使用我们示例的表定义："

#: ../../chapter-07.rst:1353
msgid ""
"``define_table`` checks whether or not the corresponding table exists. If"
" it does not, it generates the SQL to create it and executes the SQL. If "
"the table does exist but differs from the one being defined, it generates"
" the SQL to alter the table and executes it. If a field has changed type "
"but not name, it will try to convert the data (If you do not want this, "
"you need to redefine the table twice, the first time, letting py4web drop"
" the field by removing it, and the second time adding the newly defined "
"field so that py4web can create it). If the table exists and matches the "
"current definition, it will leave it alone. In all cases it will create "
"the ``db.person`` object that represents the table."
msgstr ""
"``define_table`` 检查相应的表是否存在。如果没有，它将生成创建表的 SQL "
"语句并执行。如果表确实存在，但与正在定义的表不同，它将生成变更表的 SQL "
"语句并执行。如果字段的类型发生了变化，但名称没有变化，它将尝试转换数据（如果你不想这样做，你需要重新定义表两次，第一次是让 py4web "
"删除字段，第二次是添加新定义的字段，以便 py4web "
"可以创建新类型的同名字段）。如果该表存在并且与当前定义匹配，它将保持原样。在所有情况下，它都会创建表示表的 ``db.person`` 对象。"

#: ../../chapter-07.rst:1365
msgid ""
"We refer to this behavior as a “migration”. py4web logs all migrations "
"and migration attempts in the file “sql.log”."
msgstr "我们说的 “迁移” 指的就是这种行为。py4web 在文件 “sql.log” 中记录所有迁移和迁移尝试。"

#: ../../chapter-07.rst:1370
msgid ""
"by default py4web uses the “app/databases” folder for the log file and "
"all other migration files it needs. You can change this setting by "
"changing the ``folder`` argument to DAL. To set a different log file "
"name, for example “migrate.log” you can do ``db = DAL(..., "
"adapter_args=dict(logfile='migrate.log'))``"
msgstr ""
"默认情况下， py4web 的日志文件和用到的所有其它迁移文件都保存在 “app/databases” 目录下。你可以通过设置 DAL 构造函数的"
" ``folder`` 参数来改变默认的保存位置。要设置一个不同的日志文件名，例如 “migrate.log” ，你可以设置为 ``db = "
"DAL(..., adapter_args=dict(logfile='migrate.log'))`` 。"

#: ../../chapter-07.rst:1376
msgid ""
"The first argument of ``define_table`` is always the table name. The "
"other unnamed arguments are the fields. The function also takes an "
"optional keyword argument called “migrate”:"
msgstr "``define_table`` 的第一个参数始终是表名。其他未命名的参数是字段。该函数还接受一个名为 “migrate” 的可选关键字参数："

#: ../../chapter-07.rst:1384
msgid ""
"The value of migrate is the filename where py4web stores internal "
"migration information for this table. These files are very important and "
"should never be removed while the corresponding tables exist. In cases "
"where a table has been dropped and the corresponding file still exist, it"
" can be removed manually. By default, migrate is set to True. This causes"
" py4web to generate the filename from a hash of the connection string. If"
" migrate is set to False, the migration is not performed, and py4web "
"assumes that the table exists in the datastore and it contains (at least)"
" the fields listed in ``define_table``."
msgstr ""
"migrate 的值是 py4web "
"存储此表内部迁移信息的文件名。这些文件非常重要，当相应的表存在时，不应将其删除。如果表已被删除，但相应的文件仍然存在，则可以手动将其删除。默认情况下，migrate"
" 设置为 True。这会导致 py4web 根据连接字符串的哈希生成文件名。如果 migrate 设置为 False，则不执行迁移，py4web "
"则会假设该表存在于数据存储中，并且它至少包含 ``define_table`` 中列出的字段。"

#: ../../chapter-07.rst:1394
msgid ""
"There may not be two tables in the same application with the same migrate"
" filename."
msgstr "同一应用程序中不可能有两个表对应同一个迁移文件名。"

#: ../../chapter-07.rst:1397
msgid ""
"The DAL class also takes a “migrate” argument, which determines the "
"default value of migrate for calls to ``define_table``. For example,"
msgstr "DAL类也接受一个 “migrate” 参数，该参数决定了调用  ``define_table`` 时 migrate 的默认值。例如，"

#: ../../chapter-07.rst:1404
msgid ""
"will set the default value of migrate to False whenever "
"``db.define_table`` is called without a migrate argument."
msgstr "每当在没有 migrate 参数的情况下调用 ``db.define_table`` 时，migrate 的默认值将被设置为 False 。"

#: ../../chapter-07.rst:1409
msgid ""
"py4web only migrates new columns, removed columns, and changes in column "
"type (except in SQLite). py4web does not migrate changes in attributes "
"such as changes in the values of ``default``, ``unique``, ``notnull``, "
"and ``ondelete``."
msgstr ""
"迁移时，py4web 会添加新列、删除列或改变列的类型（SQLite 除外）。 py4web 不会在迁移时改变其它属性，例如不改变 "
"``default`` 、 ``unique`` 、 ``notnull`` 或 ``ondelete`` 的值。"

#: ../../chapter-07.rst:1414
msgid "Migrations can be disabled for all tables at once:"
msgstr "可以一次禁用所有表的迁移"

#: ../../chapter-07.rst:1420
msgid ""
"This is the recommended behavior when two apps share the same database. "
"Only one of the two apps should perform migrations, the other should "
"disable them."
msgstr "当两个应用程序共用一个数据库时，建议这样做。两个应用程序中应该只有一个启用执行迁移，另一个应该禁用。"

#: ../../chapter-07.rst:1425
msgid "Fixing broken migrations"
msgstr "修复损坏的迁移"

#: ../../chapter-07.rst:1427
msgid ""
"There are two common problems with migrations and there are ways to "
"recover from them."
msgstr "迁移会遇到两种常见的问题，下面是一些从中恢复的方法。"

#: ../../chapter-07.rst:1430
msgid ""
"One problem is specific with SQLite. SQLite does not enforce column types"
" and cannot drop columns. This means that if you have a column of type "
"string and you remove it, it is not really removed. If you add the column"
" again with a different type (for example datetime) you end up with a "
"datetime column that contains strings (junk for practical purposes). "
"py4web does not complain about this because it does not know what is in "
"the database, until it tries to retrieve records and fails."
msgstr ""
"SQLite 存在一个特定的问题。SQLite 不强制执行列类型，也不能删除列。这意味着，如果你有一个 string "
"类型的列并将其删除，那么它并没有真正被删除。如果你用不同的类型（例如 datetime ）再次添加同名的列，你最终会得到一个类型是 string "
"的列（这不是实际想要的结果）。py4web 不会抱怨这一点，因为它不知道数据库中有什么，直到尝试检索记录时导致失败。"

#: ../../chapter-07.rst:1438
msgid ""
"If py4web returns an error in some parse function when selecting records,"
" most likely this is due to corrupted data in a column because of the "
"above issue."
msgstr "如果在某些解析函数中检索记录时，py4web 返回错误，很可能是由于上述问题导致列中的数据损坏。"

#: ../../chapter-07.rst:1442
msgid ""
"The solution consists in updating all records of the table and updating "
"the values in the column in question with None."
msgstr "这种情况的解决方案包括更新表的所有记录，并将相关列中的值更新为 None。"

#: ../../chapter-07.rst:1445
msgid ""
"The other problem is more generic but typical with MySQL. MySQL does not "
"allow more than one ALTER TABLE in a transaction. This means that py4web "
"must break complex transactions into smaller ones (one ALTER TABLE at the"
" time) and commit one piece at the time. It is therefore possible that "
"part of a complex transaction gets committed and one part fails, leaving "
"py4web in a corrupted state. Why would part of a transaction fail? "
"Because, for example, it involves altering a table and converting a "
"string column into a datetime column, py4web tries to convert the data, "
"but the data cannot be converted. What happens to py4web? It gets "
"confused about what exactly is the table structure actually stored in the"
" database."
msgstr ""
"另一个问题更为普遍，但在 MySQL 中更为常见。MySQL 不允许一个事务中有多个 ALTER TABLE 。这意味着 py4web "
"必须将复杂的事务分解为更小的事务（一次一个 ALTER TABLE ），并一次提交一个事务。因此，复杂事务的一部分可能被提交，而另一部分失败，导致"
" py4web 处于错误状态。为什么部分交易会失败？例如，因为它涉及更改表并将 string 列转换为 datetime 列，py4web "
"会尝试转换数据，但字符串无法转换成日期。py4web 怎么办？它对数据库中实际存储的表结构感到困惑。"

#: ../../chapter-07.rst:1457
msgid "The solution consists of enabling fake migrations:"
msgstr "这种情况的解决方案包括启用虚假迁移："

#: ../../chapter-07.rst:1463
msgid ""
"This will rebuild py4web metadata about the table according to the table "
"definition. Try multiple table definitions to see which one works (the "
"one before the failed migration and the one after the failed migration). "
"Once successful remove the ``fake_migrate=True`` parameter."
msgstr ""
"这将依据表定义重建 py4web 中相关表的元数据。尝试多个表定义，看看哪一个有效（一个是在迁移失败之前，另一个是迁移失败之后）。一旦成功，就移除"
" ``fake_migrate=True`` 参数。"

#: ../../chapter-07.rst:1468
msgid ""
"Before attempting to fix migration problems it is prudent to make a copy "
"of “yourapp/databases/\\*.table” files."
msgstr "在尝试修复迁移问题之前，谨慎的做法是复制 “yourapp/databases/\\*.table” 文件。"

#: ../../chapter-07.rst:1471
msgid "Migration problems can also be fixed for all tables at once:"
msgstr "也可以一次修复迁移中的所有问题表："

#: ../../chapter-07.rst:1477
msgid ""
"This also fails if the model describes tables that do not exist in the "
"database, but it can help narrowing down the problem."
msgstr "如果模型描述了数据库中不存在的表，这也会失败，但它可以帮助缩小问题的范围。"

#: ../../chapter-07.rst:1481
msgid "Migration control summary"
msgstr "迁移控制摘要"

#: ../../chapter-07.rst:1483
msgid ""
"The logic of the various migration arguments are summarized in this "
"pseudo-code:"
msgstr "此处的伪代码总结了各种迁移参数的逻辑："

#: ../../chapter-07.rst:1496
msgid "Table methods"
msgstr "“Table” 的方法"

#: ../../chapter-07.rst:1499
msgid "``insert``"
msgstr ""

#: ../../chapter-07.rst:1501
msgid "Given a table, you can insert records"
msgstr "给定一个表，你可以插入记录"

#: ../../chapter-07.rst:1510
msgid "Insert returns the unique “id” value of each record inserted."
msgstr "Insert() 返回唯一表示每条被插入记录的 “id” 。"

#: ../../chapter-07.rst:1512
msgid ""
"You can truncate the table, i.e., delete all records and reset the "
"counter of the id."
msgstr "您可以对表调用 truncate() ，即删除所有记录并重置 id 的计数器。"

#: ../../chapter-07.rst:1519
msgid ""
"Now, if you insert a record again, the counter starts again at 1 (this is"
" back-end specific and does not apply to Google NoSQL):"
msgstr "现在，如果你再插入一条记录，计数器又会重新从 1 开始（这是与后端数据库相关的，不适用于  Google NoSQL）："

#: ../../chapter-07.rst:1527
msgid ""
"Notice you can pass a parameter to ``truncate``, for example you can tell"
" SQLite to restart the id counter."
msgstr "注意，你可以给 ``truncate`` 一个参数，例如，你可以告诉 SQLite 让 id 计数器重新开始。"

#: ../../chapter-07.rst:1534
msgid "The argument is in raw SQL and therefore engine specific."
msgstr "参数是原始的 SQL 语句，因此这只对特定引擎有效。"

#: ../../chapter-07.rst:1536
msgid "py4web also provides a bulk_insert method"
msgstr "py4web 也提供一个  bulk_insert() 方法"

#: ../../chapter-07.rst:1543
msgid ""
"It takes a list of dictionaries of fields to be inserted and performs "
"multiple inserts at once. It returns the list of “id” values of the "
"inserted records. On the supported relational databases there is no "
"advantage in using this function as opposed to looping and performing "
"individual inserts but on Google App Engine NoSQL, there is a major speed"
" advantage."
msgstr ""
"它以要插入的字段值的字典组成的列表为参数，并一次执行插入多个记录。它返回插入记录的 “id” "
"值的列表。在支持的关系数据库上，与循环和执行单个插入操作相比，使用此函数没有优势，但在 Google App Engine NoSQL "
"上，有一个主要的速度优势。"

#: ../../chapter-07.rst:1551
msgid "``Query``, ``Set``, ``Rows``"
msgstr ""

#: ../../chapter-07.rst:1553
msgid ""
"Let’s consider again the table defined (and dropped) previously and "
"insert three records:"
msgstr "让我们再次考虑借用之前定义（并删除）的表，并插入三条记录："

#: ../../chapter-07.rst:1567
msgid ""
"You can store the table in a variable. For example, with variable "
"``person``, you could do:"
msgstr "你可以把 “表” 存储到一个变量。例如，使用变量 “person” ，你可以这样："

#: ../../chapter-07.rst:1574
msgid ""
"You can also store a field in a variable such as ``name``. For example, "
"you could also do:"
msgstr "你也可以把 “字段” 存储到一个变量。例如，使用变量 “name” ，你可以这样："

#: ../../chapter-07.rst:1581
msgid ""
"You can even build a query (using operators like ==, !=, <, >, <=, >=, "
"like, belongs) and store the query in a variable ``q`` such as in:"
msgstr ""
"你甚至可以构建一个查询（使用 ``==`` 、``!=`` 、``<`` 、 ``>`` 、 ``<=`` 、 ``>=`` 、 "
"``.like()`` 、 ``.belongs()`` 等运算符），然后把这个查询放在一个名为 “q” 的变量里，例如："

#: ../../chapter-07.rst:1588
msgid ""
"When you call ``db`` with a query, you define a set of records. You can "
"store it in a variable ``s`` and write:"
msgstr "当你使用查询调用 ``db`` 时，就定义了一个由多个记录组成的集合。你能把它存储在名为 “s” 的变量中，例如："

#: ../../chapter-07.rst:1595
msgid ""
"Notice that no database query has been performed so far. DAL + Query "
"simply define a set of records in this db that match the query. py4web "
"determines from the query which table (or tables) are involved and, in "
"fact, there is no need to specify that."
msgstr ""
"请注意，到目前为止还没有执行任何数据库查询。DAL + Query 只是在此数据库中定义一组与查询相匹配的记录。py4web "
"从查询中确定涉及哪些表，事实上，不需要显示指定表。"

#: ../../chapter-07.rst:1601
msgid "``update_or_insert``"
msgstr ""

#: ../../chapter-07.rst:1603
msgid ""
"Some times you need to perform an insert only if there is no record with "
"the same values as those being inserted. This can be done with"
msgstr "有时，只有当没有与要插入的值相同的记录时，才需要执行插入操作。这可以通过以下方式完成"

#: ../../chapter-07.rst:1614
msgid ""
"The record will be inserted only if there is no other user called John "
"born in Chicago."
msgstr "只有当数据库中没有出生在 Chicago 且名为 John 的用户时，才会插入该记录。"

#: ../../chapter-07.rst:1617
msgid ""
"You can specify which values to use as a key to determine if the record "
"exists. For example:"
msgstr "您可以指定使用哪些值作为键来确定记录是否存在。例如："

#: ../../chapter-07.rst:1626
msgid ""
"and if there is John his birthplace will be updated else a new record "
"will be created."
msgstr "如果有姓名为 John 的记录，那么他的出生地将被更新，否则将创建新的记录。"

#: ../../chapter-07.rst:1629
msgid ""
"The selection criteria in the example above is a single field. It can "
"also be a query, such as"
msgstr "上例中的匹配记录的条件标准是单一的一个字段。它也可以是一个查询，例如"

#: ../../chapter-07.rst:1640
msgid "``validate_and_insert``, ``validate_and_update``"
msgstr ""

#: ../../chapter-07.rst:1642
msgid "The function"
msgstr "除了在执行插入之前调用字段的验证器，函数"

#: ../../chapter-07.rst:1648
msgid "works very much like"
msgstr "的作用非常像"

#: ../../chapter-07.rst:1654
msgid ""
"except that it calls the validators for the fields before performing the "
"insert and bails out if the validation does not pass. If validation does "
"not pass the errors can be found in ``ret[\"errors\"]``. "
"``ret[\"errors\"]`` holds a key-value mapping where each key is the field"
" name whose validation failed, and the value of the key is the result "
"from the validation error (much like ``form[\"errors\"]``). If it passes,"
" the id of the new record is in ``ret[\"id\"]``. Mind that normally "
"validation is done by the form processing logic so this function is "
"rarely needed."
msgstr ""
"如果验证不通过，则退出。如果验证不合格，则可以在 ``ret[\"errors\"]`` 中找到错误。 ``ret[\"errors\"]`` "
"保存了一个键值映射，其中每个键都是验证失败的字段名，键的值是验证错误的结果（很像 ``form[\"errors\"]`` "
"）。如果通过，则新记录的 id 为 ``ret[\"id\"]`` 。请注意，通常验证是由表单处理逻辑完成的，因此很少需要单独调用此函数。"

#: ../../chapter-07.rst:1663
msgid "Similarly"
msgstr "类似地，除了在执行更新之前调用字段的验证器。函数"

#: ../../chapter-07.rst:1669
msgid "works very much the same as"
msgstr "的作用非常像"

#: ../../chapter-07.rst:1675
msgid ""
"except that it calls the validators for the fields before performing the "
"update. Notice that it only works if query involves a single table. The "
"number of updated records can be found in ``ret[\"updated\"]`` and errors"
" will be in ``ret[\"errors\"]``."
msgstr ""
"请注意，这仅在查询涉及单个表时有效。更新记录的数量可以在 ``ret[\"updated\"]`` 中找到，而错误在 "
"``ret[\"errors\"]`` 中。"

#: ../../chapter-07.rst:1681
msgid "``drop``"
msgstr ""

#: ../../chapter-07.rst:1683
msgid "Finally, you can drop tables and all data will be lost:"
msgstr "最后，你可以删除表，表中的所有数据也都将丢失："

#: ../../chapter-07.rst:1690
msgid "QueryBuilder"
msgstr "QueryBuilder() 查询生成器"

#: ../../chapter-07.rst:1692
msgid ""
"You can generate DAL queries using natural language. This can be done as "
"follows:"
msgstr "你能使用自然语言生成 DAL 查询。这可以像下面这样做："

#: ../../chapter-07.rst:1705
msgid "Example of valid expressions are:"
msgstr "合法的表达式示例如下："

#: ../../chapter-07.rst:1707
msgid "name is null"
msgstr ""

#: ../../chapter-07.rst:1708
msgid "name is not null"
msgstr ""

#: ../../chapter-07.rst:1709
msgid "name == Chair"
msgstr ""

#: ../../chapter-07.rst:1710
msgid "name is Chair"
msgstr ""

#: ../../chapter-07.rst:1711
msgid "name is equal Chair"
msgstr ""

#: ../../chapter-07.rst:1712
msgid "name is equal to Chair"
msgstr ""

#: ../../chapter-07.rst:1713
msgid "name is equal to \"Chair\""
msgstr ""

#: ../../chapter-07.rst:1714
msgid "name lower is equal to Chair"
msgstr ""

#: ../../chapter-07.rst:1715
msgid "not name lower is equal to Chair"
msgstr ""

#: ../../chapter-07.rst:1716
msgid "not (name lower is equal to Chair)"
msgstr ""

#: ../../chapter-07.rst:1717
msgid "name == Chair or name == Table"
msgstr ""

#: ../../chapter-07.rst:1718
msgid "name starts with C and name contains air"
msgstr ""

#: ../../chapter-07.rst:1719
msgid "name in Chair, Table, Glass"
msgstr ""

#: ../../chapter-07.rst:1720
msgid "name belongs Chair, Table, \"Glass Top\""
msgstr ""

#: ../../chapter-07.rst:1721
msgid "solid is true"
msgstr ""

#: ../../chapter-07.rst:1722
msgid "solid is false"
msgstr ""

#: ../../chapter-07.rst:1724
msgid ""
"Notice that quotes are optional and only for values. You can use brakets "
"to group. It throws a QueryParseError exception on failure. You can pass "
"optional parameters to QueryBuilder for internationalization purposes "
"(Italian in example):"
msgstr ""
"请注意，引号是可选的，仅适用于值。您可以使用括号进行分组。失败时，它会抛出QueryParseError 异常。您可以将可选参数传递给 "
"QueryBuilder 以实现国际化（例如意大利语）："

#: ../../chapter-07.rst:1736
msgid ""
"If field_aliases is not provided, only readable fields can be searched. "
"If field_aliases is provided, only explicitedly included field names can "
"be searched."
msgstr ""
"如果未提供 field_aliases 参数，只有 readable 字段能被查询到。如果提供了 field_aliases "
"参数，则只有明确指定的字段能被查询到。"

#: ../../chapter-07.rst:1739
msgid "You can, of course, use the translation operator T:"
msgstr "当然，您可以使用翻译运算符 T() ："

#: ../../chapter-07.rst:1747
msgid "You can alias the following tokens:"
msgstr "您可以对以下令牌设置别名："

#: ../../chapter-07.rst:1777
msgid ""
"The query builder is used in the Grid. In the Grid the field aliases are "
"the field.label in lower case with the spaces replaced by underscore."
msgstr "查询生成器在 Grid 中使用。在 Grid 中，字段别名是小写的 field.label ，空格被下划线替换。"

#: ../../chapter-07.rst:1781
msgid "Tagging records"
msgstr "标记记录（Tagging records）"

#: ../../chapter-07.rst:1783
msgid ""
"Tags allows to add or find properties attached to records in your "
"database."
msgstr "标记（Tags）功能可用于为数据库中的记录添加属性，或根据已附加的属性查找记录。"

#: ../../chapter-07.rst:1814
msgid ""
"``Tags`` are hierarchical. Then ``find([“color”])`` would return id1 and "
"id2 because both records have tags with “color”."
msgstr ""
"``Tags`` 具有层级结构。例如，执行 ``find([“color”])``  时，将返回 id1 和 id2 这两条记录，因为它们的 "
"“标记” 中均包含 “color” 。"

#: ../../chapter-07.rst:1817
msgid ""
"It is internally implemented with the creation of an additional table, "
"which in this example would be db.thing_tags_default, because no tail was"
" specified on the ``Tags(table, tail=“default”)`` constructor."
msgstr ""
"该功能在内部通过创建一个额外的表格实现，在本示例中，这个额外表格会是 db.thing_tags_default。出现 “default” "
"的原因是，在 ``Tags(table, tail=“default”)``  这个构造函数中，上面的例子并未指定自定义的 "
"“tail”（后缀）参数。"

#: ../../chapter-07.rst:1821
msgid ""
"py4web uses ``Tags`` as a flexible mechanism to manage permissions, we'll"
" see all the details later on the :ref:`Authorization using Tags` "
"chapter."
msgstr ""
"py4web 使用 ``Tags`` 作为一种灵活的机制来管理权限，我们稍后将在  :ref:`Authorization using Tags`"
" 中看到所有详细信息。"

#: ../../chapter-07.rst:1826
msgid "Raw SQL"
msgstr "原始的 SQL 语句"

#: ../../chapter-07.rst:1829
msgid "``executesql``"
msgstr ""

#: ../../chapter-07.rst:1831
msgid "The DAL allows you to explicitly issue SQL statements."
msgstr "DAL 允许您使用真正的 SQL 语句。"

#: ../../chapter-07.rst:1838
msgid ""
"In this case, the return values are not parsed or transformed by the DAL,"
" and the format depends on the specific database driver. This usage with "
"selects is normally not needed, but it is more common with indexes."
msgstr "这种情况下，DAL 不会再解析或者转换返回值，而且其格式依赖于特定的数据库驱动。通常不需要在 select 中使用这种用法，但在索引中更常见。"

#: ../../chapter-07.rst:1842
msgid ""
"``executesql`` takes five optional arguments: ``placeholders``, "
"``as_dict``, ``fields``, ``colnames``, and ``as_ordered_dict``."
msgstr ""
"``executesql`` 有五个可选的参数: ``placeholders`` 、 ``as_dict`` 、 ``fields`` 、 "
"``colnames`` 、 和 ``as_ordered_dict`` 。"

#: ../../chapter-07.rst:1845
msgid ""
"``placeholders`` is an optional sequence of values to be substituted in "
"or, if supported by the DB driver, a dictionary with keys matching named "
"placeholders in your SQL."
msgstr ""
"``placeholders`` 是一个可选的值的序列，用于替换 SQL 中的占位符；或者，如果数据库驱动程序支持，也可以是一个字典，其键与 "
"SQL 中的命名占位符相匹配。"

#: ../../chapter-07.rst:1849
msgid ""
"If ``as_dict`` is set to True, the results cursor returned by the DB "
"driver will be converted to a sequence of dictionaries keyed with the db "
"field names. Results returned with ``as_dict = True`` are the same as "
"those returned when applying as_list() to a normal select:"
msgstr ""
"如果将 ``as_dict`` 设置为 True，数据库驱动程序返回的结果游标将被转换为一系列字典，这些字典以数据库字段名为键。 "
"``as_dict = True`` 时返回的结果与对普通 select 结果应用 as_list () 方法得到的结果相同："

#: ../../chapter-07.rst:1858
msgid ""
"``as_ordered_dict`` is pretty much like ``as_dict`` but the former "
"ensures that the order of resulting fields (OrderedDict keys) reflect the"
" order on which they are returned from DB driver:"
msgstr ""
"``as_ordered_dict`` 与 ``as_dict`` 非常相似，但前者确保结果字段的顺序（OrderedDict "
"的键的顺序）与数据库驱动程序返回它们的顺序一致："

#: ../../chapter-07.rst:1867
msgid ""
"The ``fields`` argument is a list of DAL Field objects that match the "
"fields returned from the DB. The Field objects should be part of one or "
"more Table objects defined on the DAL object. The ``fields`` list can "
"include one or more DAL Table objects in addition to or instead of "
"including Field objects, or it can be just a single table (not in a "
"list). In that case, the Field objects will be extracted from the "
"table(s)."
msgstr ""
"``fields`` 参数是一个 DAL 字段（Field）对象的列表，这些对象与数据库返回的字段相匹配。这些字段对象应当是 DAL "
"对象上定义的一个或多个表（Table）对象的组成部分。 ``fields`` 列表除了可以包含字段对象，还可以包含一个或多个 DAL "
"表对象来补充或替代字段对象，也可以仅仅是一个单独的表（无需放在列表中）。在这种情况下，字段对象会从这些表中提取出来。"

#: ../../chapter-07.rst:1875
msgid ""
"Instead of specifying the ``fields`` argument, the ``colnames`` argument "
"can be specified as a list of field names in tablename.fieldname format. "
"Again, these should represent tables and fields defined on the DAL "
"object."
msgstr ""
"除了指定 ``fields`` 参数，还可以将 ``colnames`` 参数指定为一个字段名列表，字段名需采用 "
"“tablename.fieldname” 的格式。同样，这些字段名所代表的表和字段应当是在 DAL 对象上定义过的。"

#: ../../chapter-07.rst:1880
msgid ""
"It is also possible to specify both ``fields`` and the associated "
"``colnames``. In that case, ``fields`` can also include DAL Expression "
"objects in addition to Field objects. For Field objects in “fields”, the "
"associated ``colnames`` must still be in tablename.fieldname format. For "
"Expression objects in ``fields``, the associated ``colnames`` can be any "
"arbitrary labels."
msgstr ""
"也可以同时指定 ``fields`` 及其关联的 ``colnames``。在这种情况下， ``fields`` 除了可以包含字段对象，还可以包含"
" DAL 表达式（Expression）对象。对于  ``fields`` 中的字段对象，其关联的 ``colnames`` 仍必须采用 "
"“tablename.fieldname” 的格式；对于 ``fields`` 中的表达式对象，其关联的 ``colnames`` "
"可以是任意的标签。"

#: ../../chapter-07.rst:1887
msgid ""
"Notice, the DAL Table objects referred to by ``fields`` or ``colnames`` "
"can be dummy tables and do not have to represent any real tables in the "
"database. Also, note that the ``fields`` and ``colnames`` must be in the "
"same order as the fields in the results cursor returned from the DB."
msgstr ""
"需要注意的是，``fields`` 或 ``colnames`` 所引用的 DAL 表对象可以是虚拟表（dummy "
"tables），不必代表数据库中任何实际存在的表。另外，``fields`` 或 ``colnames`` "
"的顺序必须与数据库返回的结果游标中的字段顺序一致。"

#: ../../chapter-07.rst:1893
msgid "``_lastsql``"
msgstr ""

#: ../../chapter-07.rst:1895
msgid ""
"Whether SQL was executed manually using executesql or was SQL generated "
"by the DAL, you can always find the SQL code in ``db._lastsql``. This is "
"useful for debugging purposes:"
msgstr ""
"无论 SQL 语句是使用 executesql 手动执行的，还是由 DAL 生成的，您都可以用 ``db._lastsql`` 返回真正的 SQL"
" 语句代码。这对于调试目的很有用："

#: ../../chapter-07.rst:1907
msgid ""
"py4web never generates queries using the “*” operator. py4web is always "
"explicit when selecting fields."
msgstr "py4web 从不使用 “*” 运算符生成查询。py4web 的查询字段总是需要明确地指定。"

#: ../../chapter-07.rst:1911
msgid "Timing queries"
msgstr "查询的耗时"

#: ../../chapter-07.rst:1913
msgid ""
"All queries are automatically timed by py4web. The variable "
"``db._timings`` is a list of tuples. Each tuple contains the raw SQL "
"query as passed to the database driver and the time it took to execute in"
" seconds."
msgstr ""
"所有查询都由 py4web 自动计时。变量 ``db._timings`` 是一个元组列表。每个元组都包含传递给数据库驱动程序的原始 SQL "
"查询语句以及以秒为单位的执行时间。"

#: ../../chapter-07.rst:1919
msgid "Indexes"
msgstr "索引"

#: ../../chapter-07.rst:1921
msgid ""
"Currently the DAL API does not provide a command to create indexes on "
"tables, but this can be done using the ``executesql`` command. This is "
"because the existence of indexes can make migrations complex, and it is "
"better to deal with them explicitly. Indexes may be needed for those "
"fields that are used in recurrent queries."
msgstr ""
"目前，DAL API 没有提供在表上创建索引的命令，但这可以使用 executesql "
"命令来完成。这是因为索引的存在会使迁移变得复杂，最好明确地处理它们。对于那些在查询中频繁使用的字段，可能需要为其创建索引。"

#: ../../chapter-07.rst:1927
msgid "Here is an example of how to:"
msgstr "这里是一个示例："

#: ../../chapter-07.rst:1935
msgid ""
"Other database dialects have very similar syntaxes but may not support "
"the optional “IF NOT EXISTS” directive."
msgstr "其他数据库方言具有非常相似的语法，但可能不支持可选的 “IF not EXISTS” 指令。"

#: ../../chapter-07.rst:1939
msgid "Generating raw SQL"
msgstr "生成原始的 SQL 语句"

#: ../../chapter-07.rst:1941
msgid ""
"Sometimes you need to generate the SQL but not execute it. This is easy "
"to do with py4web since every command that performs database IO has an "
"equivalent command that does not, and simply returns the SQL that would "
"have been executed. These commands have the same names and syntax as the "
"functional ones, but they start with an underscore:"
msgstr ""
"有时您需要生成 SQL 语句，但不需要执行它。使用 py4web "
"很容易做到这一点，因为执行数据库读写操作的每个命令都有一个不执行的等效命令，并且只返回本应执行的 SQL "
"语句。这些命令的名称和语法与函数式命令相同，但它们以下划线开头："

#: ../../chapter-07.rst:1947
msgid "Here is ``_insert``"
msgstr "下面是 ``_insert`` "

#: ../../chapter-07.rst:1954
msgid "Here is ``_count``"
msgstr "下面是 ``_count``"

#: ../../chapter-07.rst:1961
msgid "Here is ``_select``"
msgstr "下面是 ``_select``"

#: ../../chapter-07.rst:1968
msgid "Here is ``_delete``"
msgstr "下面是 ``_delete``"

#: ../../chapter-07.rst:1975
msgid "And finally, here is ``_update``"
msgstr "最后，下面是  ``_update``"

#: ../../chapter-07.rst:1984
msgid ""
"Moreover you can always use ``db._lastsql`` to return the most recent SQL"
" code, whether it was executed manually using executesql or was SQL "
"generated by the DAL."
msgstr ""
"此外，无论是使用 executesql 手动执行还是DAL 生成的 SQL 语句，您始终可以使用 ``db._lastsql`` 返回最近执行的 "
"SQL 语句代码。"

#: ../../chapter-07.rst:1990
msgid "``select`` command"
msgstr "``select`` 命令"

#: ../../chapter-07.rst:1992
msgid "Given a Set, ``s``, you can fetch the records with the command ``select``:"
msgstr "有一个数据集合 ``s`` ，使用 ``select`` 命令能获取数据记录："

#: ../../chapter-07.rst:1999
msgid ""
"It returns an iterable object of class ``pydal.objects.Rows`` whose "
"elements are Row objects. ``pydal.objects.Row`` objects act like "
"dictionaries, but their elements can also be accessed as attributes. The "
"former differ from the latter because its values are read-only."
msgstr ""
"这返回 ``pydal.objects.Rows`` 类的一个可迭代对象，里面的元素是 ``Row`` "
"对象。``pydal.objects.Row`` 对象的行为像字典，但是它们的元素可以作为属性来访问。前者不同于后者，因为 ``Row`` "
"的元素的值是只读的。"

#: ../../chapter-07.rst:2005
msgid ""
"The Rows object allows looping over the result of the select and printing"
" the selected field values for each row:"
msgstr "Rows 对象允许循环查询（ select ）的结果，并打印每行中选定的字段值："

#: ../../chapter-07.rst:2015
msgid "You can do all the steps in one statement:"
msgstr "您可以在一个语句中完成所有步骤："

#: ../../chapter-07.rst:2024
msgid ""
"The select command can take arguments. All unnamed arguments are "
"interpreted as the names of the fields that you want to fetch. For "
"example, you can be explicit on fetching field “id” and field “name”:"
msgstr "select 命令可以接受参数。所有未命名的参数都被解释为要获取的字段的名称。例如，您可以显式获取字段 “id” 和字段 “name” 的值："

#: ../../chapter-07.rst:2037
msgid "The table attribute ALL allows you to specify all fields:"
msgstr "表的 ALL 属性允许你指定全部字段："

#: ../../chapter-07.rst:2048
msgid ""
"Notice that there is no query string passed to db. py4web understands "
"that if you want all fields of the table person without additional "
"information then you want all records of the table person."
msgstr ""
"请注意，这里没有向 db 传递查询字符串。py4web 会自动识别：若你想获取 person "
"表的所有字段且无需额外信息，那么你需要的就是该表的所有记录。"

#: ../../chapter-07.rst:2052
msgid "An equivalent alternative syntax is the following:"
msgstr "等效的替代语法如下："

#: ../../chapter-07.rst:2063
msgid ""
"and py4web understands that if you ask for all records of the table "
"person without additional information, then you want all the fields of "
"table person."
msgstr "而且 py4web 会理解：如果你想要 person 表的所有记录且无需额外信息，那么你需要的就是该表的所有字段。"

#: ../../chapter-07.rst:2067
msgid "Given one row"
msgstr "给定一行"

#: ../../chapter-07.rst:2073
msgid "you can extract its values using multiple equivalent expressions:"
msgstr "您可以使用多个等效表达式提取其值："

#: ../../chapter-07.rst:2084
msgid ""
"The latter syntax is particularly handy when selecting an expression "
"instead of a column. We will show this later."
msgstr "当要查询的是表达式而不是列时，后一种语法特别方便。稍后我们将展示这一点。"

#: ../../chapter-07.rst:2087
msgid "You can also do"
msgstr "你也可以这样做"

#: ../../chapter-07.rst:2093
msgid "to disable the notation"
msgstr "禁用以下形式"

#: ../../chapter-07.rst:2099
msgid "and enable, instead, the less compact notation:"
msgstr "相反地，启用了不那么紧凑的形式："

#: ../../chapter-07.rst:2105
msgid "Yes this is unusual and rarely needed."
msgstr "是的，这是不常见，很少需要。"

#: ../../chapter-07.rst:2107
msgid "Row objects also have two important methods:"
msgstr "Row 对象也有两个重要地方法："

#: ../../chapter-07.rst:2113
msgid "and"
msgstr "和"

#: ../../chapter-07.rst:2120
msgid "Using an iterator-based select for lower memory use"
msgstr "使用基于迭代器的查询以降低内存使用率"

#: ../../chapter-07.rst:2122
msgid ""
"Python “iterators” are a type of “lazy-evaluation”. They ‘feed’ data one "
"step at time; traditional Python loops create the entire set of data in "
"memory before looping."
msgstr ""
"Python 的 “iterators” 是一种 “懒惰求值”。它们只为每次迭代 “提供” 那次用到的数据；而传统的 Python "
"循环，在循环之前就需要在内存中创建整个数据集。"

#: ../../chapter-07.rst:2126
msgid "The traditional use of select is:"
msgstr "查询的传统做法是："

#: ../../chapter-07.rst:2133
msgid ""
"but for large numbers of rows, using an iterator-based alternative has "
"dramatically lower memory use:"
msgstr "但对于大量的数据行，使用基于迭代器的替代方案会大大降低内存使用率："

#: ../../chapter-07.rst:2141
#, python-format
msgid ""
"Testing shows this is around 10% faster as well, even on machines with "
"large RAM."
msgstr "测试表明，即使在具有大内存的机器上，这也快了大约 10%。"

#: ../../chapter-07.rst:2145
msgid "Rendering rows using represent"
msgstr "使用 represent 渲染行"

#: ../../chapter-07.rst:2147
msgid ""
"You may wish to rewrite rows returned by select to take advantage of "
"formatting information contained in the represents setting of the fields."
msgstr "您可能希望重写 select 返回的行，以利用字段 represents 设置中包含的格式信息。"

#: ../../chapter-07.rst:2156
msgid ""
"If you don’t specify an index, you get a generator to iterate over all "
"the rows:"
msgstr "如果你不指定索引，你会得到一个生成器来迭代所有行："

#: ../../chapter-07.rst:2164
msgid "Can also be applied to slices:"
msgstr "也可以应用切片："

#: ../../chapter-07.rst:2171
msgid ""
"If you only want to transform selected fields via their “represent” "
"attribute, you can list them in the “fields” argument:"
msgstr "如果你只想通过选定字段的 “represent” 属性来转换它们，你可以在 “fields” 参数中列出它们："

#: ../../chapter-07.rst:2178
msgid ""
"Note, it returns a transformed copy of the original Row, so there’s no "
"update_record (which you wouldn't want anyway) or delete_record."
msgstr "注意，它返回原始行的转换副本，因此没有 update_record （无论如何你都不想要）或 delete_record 。"

#: ../../chapter-07.rst:2182
msgid "Shortcuts"
msgstr "快捷语法"

#: ../../chapter-07.rst:2184
msgid "The DAL supports various code-simplifying shortcuts. In particular:"
msgstr "DAL 支持各种代码简化的快捷形式，特别地："

#: ../../chapter-07.rst:2190
msgid ""
"returns the record with the given ``id`` if it exists. If the ``id`` does"
" not exist, it returns ``None``. The above statement is equivalent to"
msgstr ""
"如果存在 id 字段与给定 ``id`` 的值相同的记录，则返回具那个记录。如果 ``id`` 在数据集中不存在，则返回 ``None`` "
"。上面地语句等效于："

#: ../../chapter-07.rst:2198
msgid "You can delete records by id:"
msgstr "能依据 id 删除记录："

#: ../../chapter-07.rst:2204
msgid "and this is equivalent to"
msgstr "而且这等效于："

#: ../../chapter-07.rst:2210
msgid "and deletes the record with the given ``id``, if it exists."
msgstr "如果给定 ``id`` 的值存在，则会删除相应记录。"

#: ../../chapter-07.rst:2212
msgid ""
"Note: this delete shortcut syntax does not currently work if *versioning*"
" is activated"
msgstr "注意：目前，如果激活了 *versioning* （版本控制），则删除记录的快捷语法不再起作用"

#: ../../chapter-07.rst:2215
msgid "You can insert records:"
msgstr "您可以插入记录："

#: ../../chapter-07.rst:2221
msgid "It is equivalent to"
msgstr "它等效于："

#: ../../chapter-07.rst:2227
msgid ""
"and it creates a new record with field values specified by the dictionary"
" on the right hand side."
msgstr "它使用右侧字典指定的字段值来创建一条新记录。"

#: ../../chapter-07.rst:2230
msgid ""
"Note: insert shortcut was previously ``db.table[0] = ...``. It has "
"changed in pyDAL 19.02 to permit normal usage of id 0."
msgstr ""
"注意：insert 的快捷语法以前的形式是 ``db.table[0] = ...`` 。这在 pyDAL 19.02 中已经更改为可以正常使用 "
"0 作为 id 来表示要插入数据。"

#: ../../chapter-07.rst:2236
msgid "You can update records:"
msgstr "你可以更新记录："

#: ../../chapter-07.rst:2242 ../../chapter-07.rst:2286
msgid "which is equivalent to"
msgstr "它等效于："

#: ../../chapter-07.rst:2248
msgid ""
"and it updates an existing record with field values specified by the "
"dictionary on the right hand side."
msgstr "它使用右侧字典指定的字段值来更新一条已存在的记录。"

#: ../../chapter-07.rst:2252
msgid "Fetching a ``Row``"
msgstr "读取 ``Row``"

#: ../../chapter-07.rst:2254
msgid "Yet another convenient syntax is the following:"
msgstr "另一种方便的语法如下："

#: ../../chapter-07.rst:2262
msgid ""
"Apparently similar to ``db.mytable[id]`` the above syntax is more "
"flexible and safer. First of all it checks whether ``id`` is an int (or "
"``str(id)`` is an int) and returns ``None`` if not (it never raises an "
"exception). It also allows to specify multiple conditions that the record"
" must meet. If they are not met, it also returns ``None``."
msgstr ""
"虽然看着与 ``db.mytable[id]`` 类似，但是上述语法更灵活、更安全。首先，它检查 ``id`` 是否为 int（或 "
"``str(id)`` 是否为 int ），如果不是，则返回 ``None`` "
"（它从不引发异常）。它还允许指定记录必须满足的多个条件。如果不满足，它也会返回 ``None`` 。"

#: ../../chapter-07.rst:2269
msgid "Recursive ``select``\\ s"
msgstr "递归的 ``select``"

#: ../../chapter-07.rst:2271
msgid ""
"Consider the previous table person and a new table “thing” referencing a "
"“person”:"
msgstr "设想还是前面的表 “person” 和一个引用 “person” 的新表 “thing” ："

#: ../../chapter-07.rst:2280
msgid "and a simple select from this table:"
msgstr "表 “thing” 的一个简单查询："

#: ../../chapter-07.rst:2292
msgid ""
"where ``_id`` is a reference to the primary key of the table. Normally "
"``db.thing._id`` is the same as ``db.thing.id`` and we will assume that "
"in most of this book."
msgstr ""
"其中 ``_id`` 是对表的主键的引用。通常是 ``db.thing._id`` 与 ``db.thing.id`` "
"相同，我们将在本书的大部分内容中假设这一点。"

#: ../../chapter-07.rst:2296
msgid ""
"For each Row of things it is possible to fetch not just fields from the "
"selected table (thing) but also from linked tables (recursively):"
msgstr "对于 “thing” 的每一行内容，不仅可以从表 “thing” 中获取字段，还可以从链接到的表（引用的表）中（递归地）获取："

#: ../../chapter-07.rst:2304
msgid ""
"Here ``thing.owner_id.name`` requires one database select for each thing "
"in things and it is therefore inefficient. We suggest using joins "
"whenever possible instead of recursive selects, nevertheless this is "
"convenient and practical when accessing individual records."
msgstr ""
"这里的 ``thing.owner_id.name`` ，需要为 things 中的每个 thing "
"执行一次数据库查询，因此效率较低。我们建议尽可能使用连接（join）操作，而非递归查询；不过，在访问单个记录时，这种方式既便捷又实用。"

#: ../../chapter-07.rst:2309
msgid ""
"You can also do it backwards, by selecting the things referenced by a "
"person:"
msgstr "你也可以通过选择引用同一条 person 记录的 things 来反向执行："

#: ../../chapter-07.rst:2318
msgid "In this last expression ``person.thing`` is a shortcut for"
msgstr "在这里，表达式 ``person.thing`` 是下面语法的快捷语法："

#: ../../chapter-07.rst:2324
msgid ""
"i.e. the Set of ``thing``\\ s referenced by the current ``person``. This "
"syntax breaks down if the referencing table has multiple references to "
"the referenced table. In this case one needs to be more explicit and use "
"a full Query."
msgstr ""
"即，引用当前 ``person`` 的一组 ``thing`` 集合。若引用表（ ``thing`` ）对被引用表（ ``person`` "
"）存在多个引用关系，此语法将无法正常使用。在这种情况下，需要更明确地使用完整的 Query。"

#: ../../chapter-07.rst:2332
msgid ""
"``orderby``, ``groupby``, ``limitby``, ``distinct``, ``having``, "
"``orderby_on_limitby``, ``join``, ``left``, ``cache``"
msgstr ""

#: ../../chapter-07.rst:2334
msgid "The ``select`` command takes a number of optional arguments."
msgstr "``select`` 命令接受许多可选参数。"

#: ../../chapter-07.rst:2337
msgid "orderby"
msgstr ""

#: ../../chapter-07.rst:2339
msgid "You can fetch the records sorted by name:"
msgstr "您能获取按 name 升序排序的记录："

#: ../../chapter-07.rst:2350
msgid ""
"You can fetch the records sorted by name in reverse order (notice the "
"tilde):"
msgstr "使用波浪号 “~”，您能获取按 name 降序排序的记录："

#: ../../chapter-07.rst:2362
msgid "You can have the fetched records appear in random order:"
msgstr "您可以让要获取的记录以随机顺序显示："

#: ../../chapter-07.rst:2375
msgid ""
"The use of ``orderby='<random>'`` is not supported on Google NoSQL. "
"However, to overcome this limit, sorting can be accomplished on selected "
"rows:"
msgstr "Google NoSQL 不支持使用 ``orderby='<random>'`` 。为了解决这一限制，可以对查询后的行进行排序："

#: ../../chapter-07.rst:2384
msgid ""
"You can sort the records according to multiple fields by concatenating "
"them with a “\\|”:"
msgstr "你能对记录按多个字段排序，需要使用 “\\|” 把多个字段组合到一起。"

#: ../../chapter-07.rst:2397
msgid "groupby, having"
msgstr ""

#: ../../chapter-07.rst:2399
msgid ""
"Using ``groupby`` together with ``orderby``, you can group records with "
"the same value for the specified field (this is back-end specific, and is"
" not on the Google NoSQL):"
msgstr ""
"将 ``groupby`` 与 ``orderby`` 一块使用，您可以对指定字段具有相同值的记录进行分组（这是特定于后端数据库的，不适用于 "
"Google NoSQL ）："

#: ../../chapter-07.rst:2414
msgid ""
"You can use ``having`` in conjunction with ``groupby`` to group "
"conditionally (only those ``having`` the condition are grouped)."
msgstr "你可以将 ``having`` 与 ``groupby`` 结合使用，有条件地分组（只有那些满足 ``having`` 条件的人才会被分组）。"

#: ../../chapter-07.rst:2421
msgid ""
"Notice that query1 filters records to be displayed, query2 filters "
"records to be grouped."
msgstr "注意，query1 筛选保留查询结果要显示的记录，而 query2 筛选哪些记录会被保留分组。"

#: ../../chapter-07.rst:2425
msgid "distinct"
msgstr ""

#: ../../chapter-07.rst:2427
msgid ""
"With the argument ``distinct=True``, you can specify that you only want "
"to select distinct records. This has the same effect as grouping using "
"all specified fields except that it does not require sorting. When using "
"distinct it is important not to select ALL fields, and in particular not "
"to select the “id” field, else all records will always be distinct."
msgstr ""
"使用参数 ``distinct=True`` "
"，可以指定查询只保留不重复的记录。除了不需要排序之外，这与使用所有指定字段进行分组具有相同的效果。使用 distinct "
"时，重要的是，不应选择所有字段，也不要选择 “id” 字段，否则结果将返回所有记录始终。"

#: ../../chapter-07.rst:2433 ../../chapter-07.rst:3496
msgid "Here is an example:"
msgstr "这里是一个例子："

#: ../../chapter-07.rst:2444
msgid "Notice that ``distinct`` can also be an expression, for example:"
msgstr "注意， ``distinct`` 也可以是一个表达式，例如："

#: ../../chapter-07.rst:2456
msgid "limitby"
msgstr ""

#: ../../chapter-07.rst:2458
msgid ""
"With ``limitby=(min, max)``, you can select a subset of the records from "
"offset=min to but not including offset=max. In the next example we select"
" the first two records starting at zero:"
msgstr ""
"使用 ``limitby=(min, max)`` ，能查询记录的一个子集，它从 offset=min 到 offset=max （不包括 "
"max）。在下面的例子中，查询结果是从 0 开始的头两条记录："

#: ../../chapter-07.rst:2471
msgid "orderby_on_limitby"
msgstr ""

#: ../../chapter-07.rst:2473
msgid ""
"Note that the DAL defaults to implicitly adding an orderby when using a "
"limitby. This ensures the same query returns the same results each time, "
"important for pagination. But it can cause performance problems. use "
"``orderby_on_limitby = False`` to change this (this defaults to True)."
msgstr ""
"请注意，DAL 默认在使用 limitby 时隐式添加 orderby "
"。这确保了相同的查询每次返回相同的结果，这对分页很重要。但这可能会导致性能问题。使用 ``orderby_on_limitby = False``"
" 更改此设置（默认为True）。"

#: ../../chapter-07.rst:2479
msgid "join, left"
msgstr "查询中的 “连接，左连接”"

#: ../../chapter-07.rst:2481
msgid ""
"These are involved in managing `One to many relation`_. They are "
"described in `Inner join`_ and `Left outer join`_ sections respectively."
msgstr ""
"这些涉及管理 `One to many relation`_ 。它们分别在 `Inner join`_  和 `Left outer join`_"
"  部分进行了描述。"

#: ../../chapter-07.rst:2485
msgid "cache, cacheable"
msgstr ""

#: ../../chapter-07.rst:2487
msgid "An example use which gives much faster selects is:"
msgstr "一个提供更快查询的示例用法是："

#: ../../chapter-07.rst:2493
msgid "Look at `Caching selects`_, to understand what the trade-offs are."
msgstr "查看 `Caching selects`_ ，了解权衡是什么。"

#: ../../chapter-07.rst:2496
msgid "Logical operators"
msgstr "逻辑操作"

#: ../../chapter-07.rst:2498
msgid "Queries can be combined using the binary AND operator “``&``”:"
msgstr "可以使用二进制 AND 运算符 “``&``” 组合查询条件："

#: ../../chapter-07.rst:2507
msgid "and the binary OR operator “``|``”:"
msgstr "也可以使用二进制 OR 运算符  “``|``” ："

#: ../../chapter-07.rst:2515
msgid "You can negate a sub-query inverting its operator:"
msgstr "您可以通过否定查询来反转运算："

#: ../../chapter-07.rst:2524
msgid "or by explicit negation with the “``~``” unary operator:"
msgstr "或者用一元运算符 “``~``” 进行显式否定："

#: ../../chapter-07.rst:2535
msgid ""
"Due to Python restrictions in overloading “``and``” and “``or``” "
"operators, these cannot be used in forming queries. The binary operators "
"“``&``” and “``|``” must be used instead. Note that these operators "
"(unlike “``and``” and “``or``”) have higher precedence than comparison "
"operators, so the “extra” parentheses in the above examples are "
"mandatory. Similarly, the unary operator “``~``” has higher precedence "
"than comparison operators, so ``~``-negated comparisons must also be "
"parenthesized."
msgstr ""
"由于 Python 在重载 “``and``” 和 “``or``” 运算符方面的限制，这些运算符不能用于生成查询。必须改用二元运算符 "
"“``&``” 和 “``|``” 。请注意，这些运算符（与 “``and``” 和 “``or``” "
"不同）的优先级高于比较运算符，因此上述示例中的 “额外” 的括号是强制性的。同样，一元运算符 “``~``” 的优先级高于比较运算符，因此 "
"``~`` 否定的内容也必须放在括号内。"

#: ../../chapter-07.rst:2544
msgid "It is also possible to build queries using in-place logical operators:"
msgstr "也可以使用就地逻辑运算符构建查询："

#: ../../chapter-07.rst:2553
msgid "``count``, ``isempty``, ``delete``, ``update``"
msgstr ""

#: ../../chapter-07.rst:2555
msgid "You can count records in a set:"
msgstr "您可以对一个数据集中的记录计数："

#: ../../chapter-07.rst:2562
msgid ""
"Notice that ``count`` takes an optional ``distinct`` argument which "
"defaults to False, and it works very much like the same argument for "
"``select``. ``count`` has also a ``cache`` argument that works very much "
"like the equivalent argument of the ``select`` method."
msgstr ""
"请注意， ``count`` 接受一个可选的 ``distinct`` 参数，默认为 False，它的工作原理与 ``select`` "
"的相同参数非常相似。 ``count`` 还有一个 ``cache`` 参数，其工作原理与 ``select`` 方法的等效参数非常相似。"

#: ../../chapter-07.rst:2567
msgid ""
"Sometimes you may need to check if a table is empty. A more efficient way"
" than counting is using the ``isempty`` method:"
msgstr "有时需要判断一个表是否为空。使用 ``isempty`` 会比 ``count`` 更有效："

#: ../../chapter-07.rst:2575
msgid "You can delete records in a set:"
msgstr "可以这样删除一个数据集中的记录："

#: ../../chapter-07.rst:2582
msgid "The ``delete`` method returns the number of records that were deleted."
msgstr "``delete`` 方法返回已被删除的记录的数量。"

#: ../../chapter-07.rst:2584
msgid ""
"And you can update all records in a set by passing named arguments "
"corresponding to the fields that need to be updated:"
msgstr "通过传递与需要更新的字段对应的命名参数，你能更新一个数据集中的全部记录："

#: ../../chapter-07.rst:2592
msgid "The ``update`` method returns the number of records that were updated."
msgstr "``update`` 方法返回已被更新的记录的数量。"

#: ../../chapter-07.rst:2595
msgid "Expressions"
msgstr "表达式"

#: ../../chapter-07.rst:2597
msgid ""
"The value assigned an update statement can be an expression. For example "
"consider this model"
msgstr "为更新语句指定的值可以是表达式。例如，考虑这个模型："

#: ../../chapter-07.rst:2608
msgid "The values used in queries can also be expressions"
msgstr "查询条件中也可以使用表达式："

#: ../../chapter-07.rst:2620
msgid "``case``"
msgstr ""

#: ../../chapter-07.rst:2622
msgid "An expression can contain a case clause for example:"
msgstr "表达式可以包含 case 子句，例如："

#: ../../chapter-07.rst:2636
msgid "``update_record``"
msgstr ""

#: ../../chapter-07.rst:2638
msgid ""
"py4web also allows updating a single record that is already in memory "
"using ``update_record``"
msgstr "使用 ``update_record`` ，py4web 也允许更新内存中的单个记录："

#: ../../chapter-07.rst:2647
msgid "``update_record`` should not be confused with"
msgstr "``update_record`` 不能和下面的混淆："

#: ../../chapter-07.rst:2653
msgid ""
"because for a single row, the method ``update`` updates the row object "
"but not the database record, as in the case of ``update_record``."
msgstr ""
"因为对于单独的 row ， ``update`` 方法虽然像 ``update_record`` 一样更新 row "
"对象，但它不会更新数据库中的记录。"

#: ../../chapter-07.rst:2656
msgid ""
"It is also possible to change the attributes of a row (one at a time) and"
" then call ``update_record()`` without arguments to save the changes:"
msgstr "也能够先改变一个 row 对象（每次一个 row ）的属性，再调用无参数的 ``update_record()`` 来保存变化。"

#: ../../chapter-07.rst:2668
msgid ""
"Note, you should avoid using ``row.update_record()`` with no arguments "
"when the ``row`` object contains fields that have an ``update`` attribute"
" (e.g., ``Field('modified_on', update=datetime.datetime.utcnow)``). "
"Calling ``row.update_record()`` will retain *all* of the existing values "
"in the ``row`` object, so any fields with ``update`` attributes will have"
" no effect in this case. Be particularly mindful of this with tables that"
" include ``auth.signature``."
msgstr ""
"请注意，当 ``row`` 对象包含具有 ``update`` 属性的字段时（例如  ``Field('modified_on', "
"update=datetime.datetime.utcnow)`` ），应避免使用没有参数的 ``row.update_record()``  "
"。调用 ``row.update_record()`` 将保留 ``row`` 对象中的 *所有* 现有值，因此在这种情况下，任何具有 "
"``update`` 属性的字段都将无效。对于包含 ``auth.signature`` 的表，请特别注意这一点。"

#: ../../chapter-07.rst:2677
msgid ""
"The ``update_record`` method is available only if the table’s ``id`` "
"field is included in the select, and ``cacheable`` is not set to "
"``True``."
msgstr ""
"只有当表的 ``id`` 字段包含在查询结果中，并且 ``cacheable`` 未设置为 ``True``时， "
"``update_record`` 方法才可用。"

#: ../../chapter-07.rst:2682
msgid "Inserting and updating from a dictionary"
msgstr "从字典\"中获取值来插入或更新记"

#: ../../chapter-07.rst:2684
msgid ""
"A common issue consists of needing to insert or update records in a table"
" where the name of the table, the field to be updated, and the value for "
"the field are all stored in variables. For example: ``tablename``, "
"``fieldname``, and ``value``."
msgstr ""
"一个常见的问题是需要在表中插入或更新记录，其中表的名称、要更新的字段和字段的值都存储在变量中。例如： ``tablename``, "
"``fieldname`` 和 ``value``。"

#: ../../chapter-07.rst:2689
msgid "The insert can be done using the following syntax:"
msgstr "使用下面的语法能够插入新记录："

#: ../../chapter-07.rst:2695
msgid "The update of record with given id can be done with:"
msgstr "可以这样更新给定 id 的记录："

#: ../../chapter-07.rst:2701
msgid ""
"Notice we used ``table._id`` instead of ``table.id``. In this way the "
"query works even for tables with a primary key field with type other than"
" “id”."
msgstr "请注意，我们使用了 ``table._id`` 而不是 ``table.id``。这样，查询甚至适用于主键字段类型不是 “id” 的表。"

#: ../../chapter-07.rst:2706
msgid "``first`` and ``last``"
msgstr "``commit`` 和 ``rollback``"

#: ../../chapter-07.rst:2708
msgid "Given a Rows object containing records:"
msgstr "对于包含记录的 Rows 对象："

#: ../../chapter-07.rst:2716
msgid "are equivalent to"
msgstr "等效于："

#: ../../chapter-07.rst:2723
msgid ""
"Notice, ``first()`` and ``last()`` allow you to obtain obviously the "
"first and last record present in your query, but this won’t mean that "
"these records are going to be the first or last inserted records. In case"
" you want the first or last record inputted in a given table don’t forget"
" to use ``orderby=db.table_name.id``. If you forget you will only get the"
" first and last record returned by your query which are often in a random"
" order determined by the backend query optimiser."
msgstr ""
"请注意， ``first()`` 和 ``last()`` "
"允许您获取查询中存在的第一条和最后一条记录，但这并不意味着这些记录将是第一条或最后一条插入的记录。如果你想在给定的表中读取第一条或最后一条插入的记录，别忘了使用"
" ``orderby=db.table_name.id`` "
"。如果你忘记了，你只会得到查询返回的第一条和最后一条，这些记录通常是由后端查询优化器确定的随机顺序。"

#: ../../chapter-07.rst:2732
msgid "``as_dict`` and ``as_list``"
msgstr "``as_dict`` 和 ``as_list``"

#: ../../chapter-07.rst:2734
msgid ""
"A Row object can be serialized into a regular dictionary using the "
"``as_dict()`` method and a Rows object can be serialized into a list of "
"dictionaries using the ``as_list()`` method. Here are some examples:"
msgstr ""
"使用 ``as_dict()`` ，一个 Row 对象能够被序列化为一个常规的字典；使用 ``as_list()`` ，一个 Rows "
"对象能够被序列化为一个常规的字典列表。下面是示例："

#: ../../chapter-07.rst:2744
msgid ""
"These methods are convenient for passing Rows to generic views and or to "
"store Rows in sessions (Rows objects themselves cannot be serialized "
"because they contain a reference to an open DB connection):"
msgstr ""
"这些方法便于将 Rows 中的数据传递给通用视图或是存储到 sessions 中。（因为 Rows "
"对象包含对已打开的数据库连接的引用，所以它本身不能被直接序列化为字符串）"

#: ../../chapter-07.rst:2755
msgid "Combining rows"
msgstr "组合使用多个 rows "

#: ../../chapter-07.rst:2757
msgid "Rows objects can be combined at the Python level. Here we assume:"
msgstr "不同的 Rows 对象可以在 Python 中被组合使用。这里，我们假设："

#: ../../chapter-07.rst:2771
msgid "You can do union of the records in two sets of rows:"
msgstr "使用 ``+`` 把两个 rows 集合中的记录直接进行合并："

#: ../../chapter-07.rst:2783
msgid "You can do union of the records removing duplicates:"
msgstr "使用 ``|`` 把两个 rows 集合中的记录进行无重复的合并："

#: ../../chapter-07.rst:2794
msgid "You can do intersection of the records in two sets of rows:"
msgstr "使用 ``&`` 获取两个 rows 集合中的相同的记录："

#: ../../chapter-07.rst:2804
msgid "``find``, ``exclude``, ``sort``"
msgstr ""

#: ../../chapter-07.rst:2806
msgid ""
"Some times you need to perform two selects and one contains a subset of a"
" previous select. In this case it is pointless to access the database "
"again. The ``find``, ``exclude`` and ``sort`` objects allow you to "
"manipulate a Rows object and generate another one without accessing the "
"database. More specifically: - ``find`` returns a new set of Rows "
"filtered by a condition and leaves the original unchanged. - ``exclude`` "
"returns a new set of Rows filtered by a condition and removes them from "
"the original Rows. - ``sort`` returns a new set of Rows sorted by a "
"condition and leaves the original unchanged."
msgstr ""
"有时，您需要执行两次查询，其中一次包含前一次查询的子集。在这种情况下，再次访问数据库是没有意义的。 ``find``、 ``exclude`` 和"
" ``sort`` 对象允许您操纵 Rows 对象并生成另一个对象，而无需再次访问数据库。更具体地说： - ``find`` "
"返回一组按条件筛选的新行，并保持原始行不变。 - ``exclude`` 返回一组按条件筛选的新行，并将其从原始行中删除。 - ``sort`` "
"返回一组按条件排序的新行，并保持原始行不变。"

#: ../../chapter-07.rst:2816
msgid ""
"All these methods take a single argument, a function that acts on each "
"individual row."
msgstr "所有这些方法都接受一个参数，一个作用于每一行（ row ）的函数。"

#: ../../chapter-07.rst:2819
msgid "Here is an example of usage:"
msgstr "这里是用法的示例"

#: ../../chapter-07.rst:2850
msgid "They can be combined:"
msgstr "它们可以组合在一起："

#: ../../chapter-07.rst:2862
msgid "Sort takes an optional argument ``reverse=True`` with the obvious meaning."
msgstr "``sort`` 接受一个可选的参数  ``reverse=True`` ，其含义显而易见。"

#: ../../chapter-07.rst:2865
msgid ""
"The ``find`` method has an optional ``limitby`` argument with the same "
"syntax and functionality as the Set ``select`` method."
msgstr "``find`` 方法有一个可选的 ``limitby`` 参数，其语法和功能与数据集 set 的 ``select`` 方法相同。"

#: ../../chapter-07.rst:2869
msgid "Caching selects"
msgstr "缓存查询"

#: ../../chapter-07.rst:2871
msgid ""
"The select method also takes a ``cache`` argument, which defaults to "
"None. For caching purposes, it should be set to a tuple where the first "
"element is the cache function with signature `(key, callback, "
"expiration)` (for example ``cache.get`` assuming ``cache`` is an instance"
" of the py4web cache object), and the second element is the expiration "
"time in seconds."
msgstr ""
"select 方法还接受一个 ``cache`` 参数，默认为 None。出于缓存目的，它应该设置为一个元组，其中第一个元素是带有签名 "
"`(key, callback, expiration)` 的缓存函数（例如 ``cache.get`` 假设 ``cache`` 是 "
"py4web 的缓存对象的实例），第二个元素是以秒为单位的过期时间。"

#: ../../chapter-07.rst:2878
msgid ""
"In the following example, you see a controller that caches a select on "
"the previously defined db.log table. The actual select fetches data from "
"the back-end database no more frequently than once every 60 seconds and "
"stores the result in memory. If the next call to this controller occurs "
"in less than 60 seconds since the last database IO, it simply fetches the"
" previous data from memory."
msgstr ""
"在下面的示例中，您会看到一个控制器，它在之前定义的 db.log "
"表上缓存一个查询结果。实际从后端数据库获取数据的查询频率不超过每60秒一次，并将结果存储在内存中。如果对该控制器的下一次调用发生在距离上次数据库查询操作不到"
" 60 秒的时间内，它只会从内存中获取之前的数据。"

#: ../../chapter-07.rst:2891
msgid ""
"The ``select`` method has an optional ``cacheable`` argument, normally "
"set to False. When ``cacheable=True`` the resulting ``Rows`` is "
"serializable but The ``Row``\\ s lack ``update_record`` and "
"``delete_record`` methods."
msgstr ""
"``select`` 方法有一个可选的参数 ``cacheable`` ，通常设置为 False。当设置为 ``cacheable=True`` "
"时，生成的 ``Rows`` 是可序列化的，但这种情况下的 ``Rows`` 没有 ``update_record`` 和 "
"``delete_record`` 方法。"

#: ../../chapter-07.rst:2896
msgid ""
"If you do not need these methods you can speed up selects a lot by "
"setting the ``cacheable`` attribute:"
msgstr "如果你不需要这些方法，可以通过设置 ``cacheable`` 属性来大大加快查询速度 "

#: ../../chapter-07.rst:2903
msgid ""
"When the ``cache`` argument is set but ``cacheable=False`` (default) only"
" the database results are cached, not the actual Rows object. When the "
"``cache`` argument is used in conjunction with ``cacheable=True`` the "
"entire Rows object is cached and this results in much faster caching:"
msgstr ""
"当 ``cache`` 参数已设置但当 ``cacheable=False`` （默认值）时，就仅缓存数据库查询结果，而非实际的 Rows "
"对象。当 ``cache`` 参数与 ``cacheable=True`` 结合使用时，整个 Rows 对象会被缓存，从而实现更快的缓存速度："

#: ../../chapter-07.rst:2915
msgid "Computed and Virtual fields"
msgstr "计算字段和虚拟字段"

#: ../../chapter-07.rst:2918
msgid "Computed fields"
msgstr "计算结果字段"

#: ../../chapter-07.rst:2920
msgid ""
"DAL fields may have a ``compute`` attribute. This must be a function (or "
"lambda) that takes a Row object and returns a value for the field. When a"
" new record is modified, including both insertions and updates, if a "
"value for the field is not provided, py4web tries to compute from the "
"other field values using the ``compute`` function. Here is an example:"
msgstr ""
"DAL 字段可能具有 ``compute`` 属性。这必须是一个函数（或 lambda ），它接受一个 Row "
"对象并为字段返回计算后的值。当有新的修改记录时，包括插入和更新，如果未提供字段的值，py4web 将尝试使用 ``compute`` "
"函数从其他字段值进行计算。以下是一个示例："

#: ../../chapter-07.rst:2938
msgid ""
"Notice that the computed value is stored in the db and it is not computed"
" on retrieval, as in the case of virtual fields, described next. Two "
"typical applications of computed fields are:"
msgstr "请注意，计算后的值存储在数据库中，在检索时不会再计算，就像下面描述的虚拟字段的情况一样。计算结果字段的两个典型应用是："

#: ../../chapter-07.rst:2942
msgid ""
"in wiki applications, to store the processed input wiki text as HTML, to "
"avoid re-processing on every request"
msgstr "在 wiki 应用程序中，将经过处理的输入文本存储为 HTML ，以避免在每个请求时在对其进行重新处理"

#: ../../chapter-07.rst:2944
msgid ""
"for searching, to compute normalized values for a field, to be used for "
"searching."
msgstr "在搜索场景下，需为某个字段计算标准化的值，以供搜索功能使用。"

#: ../../chapter-07.rst:2946
msgid ""
"Computed fields are evaluated in the order in which they are defined in "
"the table definition. A computed field can refer to previously defined "
"computed fields."
msgstr "计算结果字段按照在表定义中定义的顺序进行计算。计算结果字段可以使用在它之前定义的计算结果字段的值。"

#: ../../chapter-07.rst:2951
msgid "Virtual fields"
msgstr "虚拟字段"

#: ../../chapter-07.rst:2953
msgid ""
"Virtual fields are also computed fields (as in the previous subsection) "
"but they differ from those because they are *virtual* in the sense that "
"they are not stored in the db and they are computed each time records are"
" extracted from the database. They can be used to simplify the user’s "
"code without using additional storage but they cannot be used for "
"searching."
msgstr "虚拟字段也是计算结果字段（如前一小节所述），但不同之处是，它们是虚拟的，因为它们不存储在数据库中，所以每次从数据库中提取记录时，它们都会被重新计算。它们可用于简化用户的代码，而无需使用额外的存储空间，但不能用于搜索。"

#: ../../chapter-07.rst:2961
msgid "New style virtual fields (experimental)"
msgstr "新式虚拟字段（实验）"

#: ../../chapter-07.rst:2963
msgid ""
"py4web provides a new and easier way to define virtual fields and lazy "
"virtual fields. This section is marked experimental because the APIs may "
"still change a little from what is described here."
msgstr "py4web 提供了一种新的、更简单的方法来定义虚拟字段和惰性虚拟字段。本节标记为实验性，因为最终的 API 可能仍会与此处描述的有所不同。"

#: ../../chapter-07.rst:2967
msgid ""
"Here we will consider the same example as in the previous subsection. In "
"particular we consider the following model:"
msgstr "在这里，我们将考虑与上一小节中相同的示例。我们特别考虑以下模型："

#: ../../chapter-07.rst:2976 ../../chapter-07.rst:3052
msgid "One can define a ``total_price`` virtual field as"
msgstr "可以像这样定义一个名为 ``total_price`` 的虚拟字段："

#: ../../chapter-07.rst:2982
msgid ""
"i.e. by simply defining a new field ``total_price`` to be a "
"``Field.Virtual``. The only argument of the constructor is a function "
"that takes a row and returns the computed values."
msgstr ""
"即通过简单地将一个新字段 ``total_price`` 定义为 ``Field.Virtual``。虚拟构造函数的唯一参数是一个函数，它接受一个"
" row 对象并返回计算后的值。"

#: ../../chapter-07.rst:2986
msgid ""
"A virtual field defined as the one above is automatically computed for "
"all records when the records are selected:"
msgstr "当查询记录时，会自动为所有记录计算如上定义的虚拟字段："

#: ../../chapter-07.rst:2994
msgid ""
"It is also possible to define method fields which are calculated on-"
"demand, when called. For example:"
msgstr "还可以定义方法字段，这些字段在调用时按需计算。例如："

#: ../../chapter-07.rst:3003
msgid ""
"In this case ``row.discounted_total`` is not a value but a function. The "
"function takes the same arguments as the function passed to the "
"``Method`` constructor except for ``row`` which is implicit (think of it "
"as ``self`` for objects)."
msgstr ""
"在这种情况下，``row.discounted_total`` 不是一个值，而是一个函数。该函数接受与传递给 ``Method`` "
"构造函数的函数相同的参数，除了 ``row`` 是隐式的（可以将其视为对象的 ``self`` ）。"

#: ../../chapter-07.rst:3008
msgid ""
"The lazy field in the example above allows one to compute the total price"
" for each ``item``:"
msgstr "上面示例中的懒惰字段允许计算每个 ``item`` 的总价："

#: ../../chapter-07.rst:3015
msgid "And it also allows to pass an optional ``discount`` percentage (say 15%):"
msgstr "它还允许通过一个可选的 ``discount`` 百分比（比如 15% ）："

#: ../../chapter-07.rst:3022
msgid ""
"Virtual and Method fields can also be defined in place when a table is "
"defined:"
msgstr "也可以在表的定义中定义虚拟字段和方法字段。"

#: ../../chapter-07.rst:3035
msgid ""
"Mind that virtual fields do not have the same attributes as regular "
"fields (length, default, required, etc). They do not appear in the list "
"of ``db.table.fields``."
msgstr ""
"请记住，虚拟字段没有常规字段的属性（ length、default、required 等）。它们不在 ``db.table.fields`` "
"的列表里面。"

#: ../../chapter-07.rst:3040
msgid "Old style virtual fields"
msgstr "旧式虚拟字段"

#: ../../chapter-07.rst:3042
msgid ""
"In order to define one or more virtual fields, you can also define a "
"container class, instantiate it and link it to a table or to a select. "
"For example, consider the following table:"
msgstr "为了定义一个或多个虚拟字段，您还可以定义一个容器类，实例化它并将其链接到一个表或一个查询。例如，考虑下表："

#: ../../chapter-07.rst:3062
msgid ""
"Notice that each method of the class that takes a single argument (self) "
"is a new virtual field. ``self`` refers to each one row of the select. "
"Field values are referred by full path as in ``self.item.unit_price``. "
"The table is linked to the virtual fields by appending an instance of the"
" class to the table’s ``virtualfields`` attribute."
msgstr ""
"请注意，类中接受单个参数（self）的每个方法都是一个新的虚字段。 ``self`` 指的是查询中的每个 row 。字段值由 "
"``self.item.unit_price`` 中的完整路径引用。通过将类的实例附加到表的 ``virtualfields`` "
"属性，将表链接到虚拟字段。"

#: ../../chapter-07.rst:3068
msgid "Virtual fields can also access recursive fields as in"
msgstr "虚拟字段也可以访问递归字段，如"

#: ../../chapter-07.rst:3085
msgid ""
"Notice the recursive field access ``self.order_item.item.unit_price`` "
"where ``self`` is the looping record."
msgstr "请注意，递归字段访问的语句 ``self.order_item.item.unit_price`` 中， ``self`` 代表循环中的当前记录。"

#: ../../chapter-07.rst:3088
msgid "They can also act on the result of a JOIN"
msgstr "它们也可以对 JOIN 的结果进行操作。"

#: ../../chapter-07.rst:3103
msgid ""
"Notice how in this case the syntax is different. The virtual field "
"accesses both ``self.item.unit_price`` and ``self.order_item.quantity`` "
"which belong to the join select. The virtual field is attached to the "
"rows of the table using the ``setvirtualfields`` method of the rows "
"object. This method takes an arbitrary number of named arguments and can "
"be used to set multiple virtual fields, defined in multiple classes, and "
"attach them to multiple tables:"
msgstr ""
"注意在这种情况下，语法有何不同。虚拟字段同时访问 ``self.item.unit_price`` 和 "
"``self.order_item.quantity`` ，它们都属于连接查询（ join ）。虚拟字段通过 rows 对象的 "
"``setvirtualfields`` 方法附加到表的 rows "
"上。该方法接受任意数量的命名参数，可用于设置多个虚拟字段，这些字段可以定义在多个类中，并附加到多个表上："

#: ../../chapter-07.rst:3129
msgid ""
"Virtual fields can be *lazy*; all they need to do is return a function "
"and access it by calling the function:"
msgstr "虚拟字段可以是惰性的；它们所需要做的只是返回一个函数，并通过调用该函数来访问它："

#: ../../chapter-07.rst:3149
msgid "or shorter using a lambda function:"
msgstr "或者使用 lambda 函数会更简短："

#: ../../chapter-07.rst:3159
msgid "Joins and Relations"
msgstr "连接和关系"

#: ../../chapter-07.rst:3162
msgid "One to many relation"
msgstr "一对多关系"

#: ../../chapter-07.rst:3164
msgid ""
"To illustrate how to implement one to many relations with the DAL, define"
" another table “thing” that refers to the table “person” which we "
"redefine here:"
msgstr "为了演示如何使用数据访问层（DAL）实现一对多关系，请定义另一个名为 “thing” 的表，该表引用我们在这里重新定义的 “person” 表："

#: ../../chapter-07.rst:3184
msgid ""
"Table “thing” has two fields, the name of the thing and the owner of the "
"thing. The “owner_id” field is a reference field, it is intended that the"
" field reference the other table by its id. A reference type can be "
"specified in two equivalent ways, either: ``Field('owner_id', 'reference "
"person')`` or: ``Field('owner_id', db.person)``."
msgstr ""
"表 “thing” 有两个字段，即物品的名称和物品的所有者。“owner_id” 字段是一个引用字段，它的作用是通过 ID "
"引用另一个表。引用类型可以通过两种等效的方式指定，即：``Field('owner_id', 'reference person')`` "
"或：``Field('owner_id', db.person)``。"

#: ../../chapter-07.rst:3191
msgid ""
"The latter is always converted to the former. They are equivalent except "
"in the case of lazy tables, self references or other types of cyclic "
"references where the former notation is the only allowed notation."
msgstr "后者总是会被转换为前者。它们是等效的，但在惰性表、自引用或其他类型的循环引用情况下，就只能使用前者。"

#: ../../chapter-07.rst:3195
msgid "Now, insert three things, two owned by Alex and one by Bob:"
msgstr "现在，插入三件物品，其中两件属于 Alex ，一件属于 Bob："

#: ../../chapter-07.rst:3206
msgid "You can select as you did for any other table:"
msgstr "您可以像对其他表一样对它进行查询："

#: ../../chapter-07.rst:3216
msgid ""
"Because a thing has a reference to a person, a person can have many "
"things, so a record of table person now acquires a new attribute thing, "
"which is a Set, that defines the things of that person. This allows "
"looping over all persons and fetching their things easily:"
msgstr ""
"因为 thing 有一个指向 person 的引用，一个 person 可以拥有许多 things，所以 person "
"表的记录现在获得了一个新的属性 thing，它是一个集合，用于定义某个 person 的所拥有的 things。这允许我们遍历所有的 person"
" 并轻松获取他们的 things："

#: ../../chapter-07.rst:3236
msgid "Inner join"
msgstr "内连接"

#: ../../chapter-07.rst:3238
msgid ""
"Another way to achieve a similar result is by using a join, specifically "
"an INNER JOIN. py4web performs joins automatically and transparently when"
" the query links two or more tables as in the following example:"
msgstr ""
"实现类似结果的另一种方式是使用连接，特别是 INNER JOIN。 当查询需要将两个或多个表关联时，py4web "
"会自动且透明地执行连接，如以下示例所示："

#: ../../chapter-07.rst:3252
msgid ""
"Observe that py4web did a join, so the rows now contain two records, one "
"from each table, linked together. Because the two records may have fields"
" with conflicting names, you need to specify the table when extracting a "
"field value from a row. This means that while before you could do:"
msgstr ""
"请注意，py4web "
"执行了一个连接操作，因此现在每行包含两个记录，每个表各一个，并且它们已连接在一起。由于这两个记录可能具有字段名冲突，在从行中提取字段值时需要指定表。这意味着虽然之前你可以这样做："

#: ../../chapter-07.rst:3262
msgid ""
"and it was obvious whether this was the name of a person or a thing, in "
"the result of a join you have to be more explicit and say:"
msgstr "这是指一个 person 的名字还是一个 thing 的，非常显而易见，在连接（join）的结果中，你必须更明确地说明，并且要这样说："

#: ../../chapter-07.rst:3269
msgid "or:"
msgstr "或："

#: ../../chapter-07.rst:3275
msgid "There is an alternative syntax for INNER JOINS:"
msgstr "这里由 INNER JOIN 的一种替代语法："

#: ../../chapter-07.rst:3287
msgid ""
"While the output is the same, the generated SQL in the two cases can be "
"different. The latter syntax removes possible ambiguities when the same "
"table is joined twice and aliased:"
msgstr "虽然输出相同，但两种情况下生成的 SQL 可能不同。后一种语法在同一表被连接两次并使用别名时可以消除可能的歧义："

#: ../../chapter-07.rst:3302
msgid "The value of ``join`` can be list of ``db.table.on(...)`` to join."
msgstr "``join``  的值可以是要连接的 ``db.table.on(...)`` 列表。"

#: ../../chapter-07.rst:3305
msgid "Left outer join"
msgstr "左外连接"

#: ../../chapter-07.rst:3307
msgid ""
"Notice that Carl did not appear in the list above because he has no "
"things. If you intend to select on persons (whether they have things or "
"not) and their things (if they have any), then you need to perform a LEFT"
" OUTER JOIN. This is done using the argument “left” of the select. Here "
"is an example:"
msgstr ""
"注意 Carl 没有出现在上面的列表中，因为他没有任何 "
"things。如果你打算查询人员（无论他们是否有事物）及其事物（如果有的话），那么你需要执行 LEFT OUTER "
"JOIN（左外连接）。这是通过在 select 中使用参数 “left” 来完成的。这里是一个示例："

#: ../../chapter-07.rst:3325
msgid "where:"
msgstr "上面的："

#: ../../chapter-07.rst:3331
msgid ""
"does the left join query. Here the argument of ``db.thing.on`` is the "
"condition required for the join (the same used above for the inner join)."
" In the case of a left join, it is necessary to be explicit about which "
"fields to select."
msgstr "执行左连接查询。这里 ``db.thing.on`` 的参数是进行连接所需的条件（与上面内连接中使用的相同）。在进行左连接时，需要明确选择哪些字段。"

#: ../../chapter-07.rst:3336
msgid ""
"Multiple left joins can be combined by passing a list or tuple of "
"``db.mytable.on(...)`` to the ``left`` parameter."
msgstr "可以通过将 ``db.mytable.on(...)`` 的列表或元组传递给 ``left`` 参数来组合多个左连接。"

#: ../../chapter-07.rst:3340
msgid "Grouping and counting"
msgstr "分组与计数"

#: ../../chapter-07.rst:3342
msgid ""
"When doing joins, sometimes you want to group rows according to certain "
"criteria and count them. For example, count the number of things owned by"
" every person. py4web allows this as well. First, you need a count "
"operator. Second, you want to join the person table with the thing table "
"by owner. Third, you want to select all rows (person + thing), group them"
" by person, and count them while grouping:"
msgstr ""
"在进行连接时，有时你希望根据某些条件对记录进行分组并进行计数。例如，统计每个人拥有的物品数量。py4web "
"也支持这种操作。首先，你需要一个计数运算符。其次，你需要通过 “拥有” 将 person 表与 thing "
"表进行连接。第三，你希望选择所有行（person + thing），按 person 分组，并在分组时进行计数:"

#: ../../chapter-07.rst:3359
msgid ""
"Notice the ``count`` operator (which is built-in) is used as a field. The"
" only issue here is in how to retrieve the information. Each row clearly "
"contains a person and the count, but the count is not a field of a person"
" nor is it a table. So where does it go? It goes into the storage object "
"representing the record with a key equal to the query expression itself."
msgstr ""
"请注意，``count`` "
"运算符（内置的）是作为一个字段使用的。这里唯一的问题是如何获取信息。每一行显然包含一个人和计数，但计数既不是该人的字段，也不是一个表。那么它应该放在哪里呢？它会放入表示记录的存储对象中，其键等于查询表达式本身。"

#: ../../chapter-07.rst:3366
msgid ""
"The ``count`` method of the Field object has an optional ``distinct`` "
"argument. When set to ``True`` it specifies that only distinct values of "
"the field in question are to be counted."
msgstr "Field 对象的 ``count`` 方法有一个可选的  ``distinct`` 参数。当设置为 True 时，它指定只计算该字段的不同值。"

#: ../../chapter-07.rst:3371
msgid "Many to many relation"
msgstr "多对多关系"

#: ../../chapter-07.rst:3373
msgid ""
"In the previous examples, we allowed a thing to have one owner but one "
"person could have many things. What if Boat was owned by Alex and Curt? "
"This requires a many-to-many relation, and it is realized via an "
"intermediate table that links a person to a thing via an ownership "
"relation."
msgstr ""
"在前面的例子中，我们允许一个 thing 有一个所有者，但一个 person 可以拥有多个 things。如果 boat 同时属于 Alex 和 "
"Curt 呢？这是多对多的关系，它需要通过一个中间表来实现，该表通过所有关系将人和物品连接起来。"

#: ../../chapter-07.rst:3379
msgid "Here is how to do it:"
msgstr "下面是实现方法："

#: ../../chapter-07.rst:3398
msgid "the existing ownership relationship can now be rewritten as:"
msgstr "现有的所有关系现在可以重写为："

#: ../../chapter-07.rst:3409
msgid "Now you can add the new relation that Curt co-owns Boat:"
msgstr "现在你可以添加 Curt 也拥有 Boat 的新关系："

#: ../../chapter-07.rst:3416
msgid ""
"Because you now have a three-way relation between tables, it may be "
"convenient to define a new set on which to perform operations:"
msgstr "你现在在两个表之间有一个第三方关系，因此定义一个新的集合来执行操作可能会更方便："

#: ../../chapter-07.rst:3424
msgid "Now it is easy to select all persons and their things from the new Set:"
msgstr "现在很容易从新的集合中查询全部的 persons 及他们拥有的物品："

#: ../../chapter-07.rst:3436
msgid "Similarly, you can search for all things owned by Alex:"
msgstr "类似地，你能查询 Alex 拥有的全部 things："

#: ../../chapter-07.rst:3446
msgid "and all owners of Boat:"
msgstr "和 boat 的全部拥有者："

#: ../../chapter-07.rst:3456
msgid ""
"A lighter alternative to many-to-many relations is tagging, see the "
":ref:`Authorization using Tags` chapter. Tagging works even on database "
"backends that do not support JOINs like the Google App Engine NoSQL."
msgstr ""
"比多对多关系更轻量的做法是标签化（tagging），请参见 :ref:`Authorization using Tags` 一章。即使在不支持 "
"JOIN 的数据库后端（如 Google App Engine 的 NoSQL）上，标签化（tagging）也能正常工作。"

#: ../../chapter-07.rst:3461
msgid "Self-Reference and aliases"
msgstr "自引用与别名"

#: ../../chapter-07.rst:3463
msgid ""
"It is possible to define tables with fields that refer to themselves, "
"here is an example:"
msgstr "可以定义包含自引用字段的表，例如："

#: ../../chapter-07.rst:3473
msgid ""
"Notice that the alternative notation of using a table object as field "
"type will fail in this case, because it uses a table before it is "
"defined:"
msgstr "注意，在此情况下，如果使用表对象作为字段类型就会失败，因为它在表定义之前就使用了还没定义完整的自身，例如："

#: ../../chapter-07.rst:3484
msgid ""
"In general ``db.tablename`` and ``'reference tablename'`` are equivalent "
"field types, but the latter is the only one allowed for self-references."
msgstr ""
"一般来说， ``db.tablename`` 和 ``'reference tablename'`` "
"是等效的字段类型，但后者是唯一允许自引用的字段类型。"

#: ../../chapter-07.rst:3487
msgid ""
"When a table has a self-reference and you have to do join, for example to"
" select a person and its father, you need an alias for the table. In SQL "
"an alias is a temporary alternate name you can use to reference a "
"table/column into a query (or other SQL statement)."
msgstr ""
"当一个表有自引用并且您必须进行连接接（join）查询时，例如选择一个人及其父亲，您需要一个表的别名。在 SQL "
"中，别名是一个临时备用的名称，可用于将表/列引用到查询（或其他 SQL 语句）中。"

#: ../../chapter-07.rst:3492
msgid ""
"With py4web you can make an alias for a table using the ``with_alias`` "
"method. This works also for expressions, which means also for fields "
"since ``Field`` is derived from ``Expression``."
msgstr ""
"使用 py4web，您可以使用 ``with_alias`` 方法为表创建别名。这也适用于表达式，这意味着也适用于字段，因为 ``Field`` "
"是从 ``Expression`` 派生出来的。"

#: ../../chapter-07.rst:3519
msgid ""
"Notice that we have chosen to make a distinction between: - “father_id”: "
"the field name used in the table “person”; - “father”: the alias we want "
"to use for the table referenced by the above field; this is communicated "
"to the database; - “Father”: the variable used by py4web to refer to that"
" alias."
msgstr ""
"请注意，我们选择做了区分：-“father_id”：表 “person” "
"中使用的字段名；-“father”：我们想为被上述字段引用的表使用的别名；这被传送到数据库；-“Father”：py4web "
"使用的变量，用来引用别名对应的对象。"

#: ../../chapter-07.rst:3525
msgid ""
"The difference is subtle, and there is nothing wrong in using the same "
"name for the three of them:"
msgstr "区别是微妙的，对这三个词使用相同的名字并没有错："

#: ../../chapter-07.rst:3550
msgid ""
"But it is important to have the distinction clear in order to build "
"correct queries."
msgstr "但为了构建正确的查询，明确地区分很重要。"

#: ../../chapter-07.rst:3555
msgid "Other operators"
msgstr "其他运算符"

#: ../../chapter-07.rst:3557
msgid ""
"py4web has other operators that provide an API to access equivalent SQL "
"operators. Let’s define another table “log” to store security events, "
"their event_time and severity, where the severity is an integer number."
msgstr ""
"py4web 还有其他运算符，它们提供了一个 API 来访问等价的 SQL 运算符。让我们定义另一个表 “log” "
"来存储安全事件、事件时间和严重性，其中严重性是一个整数。"

#: ../../chapter-07.rst:3568
msgid ""
"As before, insert a few events, a “port scan”, an “xss injection” and an "
"“unauthorized login”. For the sake of the example, you can log events "
"with the same event_time but with different severities (1, 2, and 3 "
"respectively)."
msgstr ""
"如前所述，插入一些事件， “port scan” 、“xss injection” 和 “unauthorized "
"login”。为了示例，您可以记录具有相同 event_time 但严重程度不同（分别为 1、2 和 3 ）的事件。"

#: ../../chapter-07.rst:3585
msgid ""
"``like``, ``ilike``, ``regexp``, ``startswith``, ``endswith``, "
"``contains``, ``upper``, ``lower``"
msgstr ""

#: ../../chapter-07.rst:3587
msgid "Fields have a ``like`` operator that you can use to match strings:"
msgstr "字段有一个 ``like`` 运算符，可用于匹配字符串："

#: ../../chapter-07.rst:3596
msgid ""
"Here “port%” indicates a string starting with “port”. The percent sign "
"character, “%”, is a wild-card character that means “any sequence of "
"characters”."
msgstr "这里的 “port%” 表示以 “port” 开头的字符串。 “ % ” 是一个通配符，代表 “任意地字符序列” 。"

#: ../../chapter-07.rst:3600
msgid ""
"The ``like`` operator maps to the LIKE word in ANSI-SQL. LIKE is case-"
"sensitive in most databases, and depends on the collation of the database"
" itself. The ``like`` method is hence case-sensitive but it can be made "
"case-insensitive with"
msgstr ""
"``like`` 运算符映射到 ANSI-SQL 中的  LIKE 关键字。在大多数数据库中，LIKE "
"是区分大小写的，其行为取决于数据库自身的规则。因此，``like`` 方法区分大小写，但可以通过以下方式使其不区分大小写："

#: ../../chapter-07.rst:3609
msgid "which is the same as using ``ilike``"
msgstr "其作用和使用 ``ilike`` 相同："

#: ../../chapter-07.rst:3615
msgid "py4web also provides some shortcuts:"
msgstr "py4web 也提供了一些便捷形式："

#: ../../chapter-07.rst:3623
msgid "which are roughly equivalent respectively to"
msgstr "它们大致相当于："

#: ../../chapter-07.rst:3631
msgid ""
"Remember that ``contains`` has a special meaning for ``list:<type>`` "
"fields, as discussed in :ref:`list_type and contains`."
msgstr ""
"请记住， ``contains`` 对 ``list:<type>`` 字段有特殊含义，如 :ref:`list_type and "
"contains` 中所述。"

#: ../../chapter-07.rst:3634
msgid ""
"The ``contains`` method can also be passed a list of values and an "
"optional boolean argument ``all`` to search for records that contain all "
"values:"
msgstr ""
"也能把一些值组成的列表传递给 ``contains`` 方法，同时还有一个可选的 boolean 参数  ``all`` "
"决定着搜索的字段要包含列表中的每个值："

#: ../../chapter-07.rst:3642
msgid "or any value from the list"
msgstr "或者包含列表中的任意一个值："

#: ../../chapter-07.rst:3648
msgid ""
"There is a also a ``regexp`` method that works like the ``like`` method "
"but allows regular expression syntax for the look-up expression. It is "
"only supported by MySQL, Oracle, PostgreSQL, SQLite, and MongoDB (with "
"different degree of support)."
msgstr ""
"还有一个 ``regexp`` 方法，其工作方式与 ``like`` 方法类似，但允许查找表达式使用正则表达式语法。它只支持 "
"MySQL、Oracle、PostgreSQL、SQLite 和 MongoDB （支持程度不同）。"

#: ../../chapter-07.rst:3653
msgid ""
"The ``upper`` and ``lower`` methods allow you to convert the value of the"
" field to upper or lower case, and you can also combine them with the "
"like operator:"
msgstr "``upper`` 和 ``lower`` 方法允许您将字段的值转换为大写或小写，您还可以将它们与 like 运算符组合在一起："

#: ../../chapter-07.rst:3665
msgid "``year``, ``month``, ``day``, ``hour``, ``minutes``, ``seconds``"
msgstr ""

#: ../../chapter-07.rst:3667
msgid ""
"The date and datetime fields have ``day``, ``month`` and ``year`` "
"methods. The datetime and time fields have ``hour``, ``minutes`` and "
"``seconds`` methods. Here is an example:"
msgstr ""
"date 和 datetime 类型的字段有 ``day`` 、 ``month`` 和 ``year`` 方法。datetime 和 time "
"类型的字段有 ``hour`` 、 ``minutes`` 、 ``seconds`` 方法。这里是一个例子："

#: ../../chapter-07.rst:3681
msgid "``belongs``"
msgstr ""

#: ../../chapter-07.rst:3683
msgid ""
"The SQL IN operator is realized via the ``belongs`` method which returns "
"true when the field value belongs to the specified set (list or tuples):"
msgstr ""
"``belongs`` 方法实现了 SQL 语法中的 IN 的操作，当字段的值在某个指定的 set（list 或 tuples）中时，它返回 "
"true 。"

#: ../../chapter-07.rst:3694
msgid ""
"The DAL also allows a nested select as the argument of the belongs "
"operator. The only caveat is that the nested select has to be a "
"``_select``, not a ``select``, and only one field has to be selected "
"explicitly, the one that defines the set."
msgstr ""
"DAL 还允许嵌套查询作为 belongs 运算符的参数。唯一需要注意的是，嵌套的查询必须使用 ``_select`` ，而不是 "
"``select`` ，并且只能明确地指定一个要查询的字段，即定义集合的字段。"

#: ../../chapter-07.rst:3709
msgid ""
"In those cases where a nested select is required and the look-up field is"
" a reference we can also use a query as argument. For example:"
msgstr "在需要嵌套查询并且查找字段类型是引用的情况下，我们也可以使用 query 作为参数。例如："

#: ../../chapter-07.rst:3721
msgid ""
"In this case it is obvious that the nested select only needs the field "
"referenced by the ``db.thing.owner_id`` field so we do not need the more "
"verbose ``_select`` notation."
msgstr "在这个例子中，嵌套地查询只需要被 ``db.thing.owner_id`` 引用的字段，因此我们不再需要额外多余的 ``_select`` 。"

#: ../../chapter-07.rst:3725
msgid ""
"A nested select can also be used as insert/update value but in this case "
"the syntax is different:"
msgstr "一个嵌套查询也能够作为 insert/update 的参数值使用，但是在这种情况下的语法有些不同："

#: ../../chapter-07.rst:3734
msgid ""
"In this case ``lazy`` is a nested expression that computes the ``id`` of "
"person “Jonathan”. The two lines result in one single SQL query."
msgstr ""
"在这种情况下， ``lazy`` 是一个嵌套的表达式，它计算  “Jonathan” 这个人对应的 ``id`` 。这两行会生成一个单一的 SQL"
" 查询。"

#: ../../chapter-07.rst:3738
msgid "``sum``, ``avg``, ``min``, ``max`` and ``len``"
msgstr ""

#: ../../chapter-07.rst:3740
msgid ""
"Previously, you have used the ``count`` operator to count records. "
"Similarly, you can use the ``sum`` operator to add (sum) the values of a "
"specific field from a group of records. As in the case of count, the "
"result of a sum is retrieved via the storage object:"
msgstr ""
"在前面，您使用过 ``count`` 运算符对记录进行计数。同样，您可以使用 ``sum`` "
"运算符将一组记录中特定字段的值相加（求和）。与计数的情况一样，通过存储对象检索 sum 的结果："

#: ../../chapter-07.rst:3751
msgid ""
"You can also use ``avg``, ``min``, and ``max`` to the average, minimum, "
"and maximum value respectively for the selected records. For example:"
msgstr "您也能使用 ``avg`` 、 ``min`` 和 ``max`` 分别对查询后的记录计算平均值、最小值和最大值。例如："

#: ../../chapter-07.rst:3760
msgid ""
"``len`` computes the length of field’s value. It is generally used on "
"string or text fields but depending on the back-end it may still work for"
" other types too (boolean, integer, etc)."
msgstr ""
"``len`` 计算字段值的长度。它一般被用于 string  或 text 类型的字段。但是在后端数据库支持的情况下，它可能也会用于其他类型 "
"(boolean, integer 等)。"

#: ../../chapter-07.rst:3771
msgid ""
"Expressions can be combined to form more complex expressions. For example"
" here we are computing the sum of the length of the event strings in the "
"logs plus one:"
msgstr "表达式能被组合而形成更复杂的表达式。例如，这里我们计算的是日志中事件字符串长度加 1 的总和："

#: ../../chapter-07.rst:3782
msgid "Substrings"
msgstr "子字符串"

#: ../../chapter-07.rst:3784
msgid ""
"One can build an expression to refer to a substring. For example, we can "
"group things whose name starts with the same three characters and select "
"only one from each group:"
msgstr "可以构建一个表达式来引用子字符串。例如，我们可以将名称以相同的三个字符开头的事物分组，并从每组中只选择一个："

#: ../../chapter-07.rst:3793
msgid "Default values with ``coalesce`` and ``coalesce_zero``"
msgstr "``coalesce`` 和 ``coalesce_zero``"

#: ../../chapter-07.rst:3795
msgid ""
"There are times when you need to pull a value from database but also need"
" a default values if the value for a record is set to NULL. In SQL there "
"is a function, ``COALESCE``, for this. py4web has an equivalent "
"``coalesce`` method:"
msgstr ""
"有时，您需要从数据库中提取一个值，但如果记录的值已被设置为 NULL ，则还需要一个默认值。在 SQL 中，有一个函数 ``COALESCE`` "
"用于此。py4web 有一个等效的 ``coalesce`` 方法："

#: ../../chapter-07.rst:3815
msgid ""
"Other times you need to compute a mathematical expression but some fields"
" have a value set to None while it should be zero. ``coalesce_zero`` "
"comes to the rescue by defaulting None to zero in the query:"
msgstr ""
"其他时候，你需要计算一个数学表达式，但有些字段的值默认被设置为 None ，而实际它应该为零。 ``coalesce_zero`` "
"在查询中起到了弥补作用，它将默认的 None 换为零："

#: ../../chapter-07.rst:3838
msgid "Exporting and importing data"
msgstr "导出和导入数据"

#: ../../chapter-07.rst:3841
msgid "CSV (one Table at a time)"
msgstr "CSV（一次一个表）"

#: ../../chapter-07.rst:3843
msgid ""
"When a Rows object is converted to a string it is automatically "
"serialized in CSV:"
msgstr "当 Rows 对象被转换为字符串时，它会自动以 CSV 格式序列化："

#: ../../chapter-07.rst:3855
msgid "You can serialize a single table in CSV and store it in a file “test.csv”:"
msgstr "您可以将单个表序列化为 CSV 格式，并将其存储在文件 “test.CSV” 中："

#: ../../chapter-07.rst:3864
msgid ""
"Converting a ``Rows`` object into a string produces an encoded binary "
"string and it's better to be explicit with the encoding used:"
msgstr "将 ``Rows`` 对象转换为字符串时会生成某种编码的二进制字符串，最好明确指定所使用的编码："

#: ../../chapter-07.rst:3872
msgid "This is equivalent to"
msgstr "这等效于"

#: ../../chapter-07.rst:3880
msgid "You can read the CSV file back with:"
msgstr "您可以读回 CSV 文件："

#: ../../chapter-07.rst:3887
msgid "Again, you can be explict about the encoding for the exporting file:"
msgstr "再次说明，你应该明确地指定导出文件的编码"

#: ../../chapter-07.rst:3896
msgid "and the importing one:"
msgstr "和导入文件的编码："

#: ../../chapter-07.rst:3903
msgid ""
"When importing, py4web looks for the field names in the CSV header. In "
"this example, it finds two columns: “person.id” and “person.name”. It "
"ignores the “person.” prefix, and it ignores the “id” fields. Then all "
"records are appended and assigned new ids."
msgstr ""
"导入时，py4web 会在 CSV 第一行标头中查找字段名称。在这个例子中，它找到了两列：“person.id” 和 “person.name” "
"。它忽略了 “person.” 前缀，也忽略了 “id” 字段。然后，所有记录都会被添加并分配新的 id 。"

#: ../../chapter-07.rst:3909
msgid "CSV (all tables at once)"
msgstr "CSV（一次所有表）"

#: ../../chapter-07.rst:3911
msgid "In py4web, you can backup/restore an entire database with two commands:"
msgstr "在 py4web 中，您可以使用两个命令备份/还原整个数据库："

#: ../../chapter-07.rst:3913
msgid "To export:"
msgstr "要导出："

#: ../../chapter-07.rst:3920
msgid "To import:"
msgstr "要导入："

#: ../../chapter-07.rst:3927
msgid ""
"This mechanism can be used even if the importing database is of a "
"different type than the exporting database."
msgstr "即使导入数据库与导出数据库的类型不同，也可以使用此机制。"

#: ../../chapter-07.rst:3930
msgid ""
"The data is stored in “somefile.csv” as a CSV file where each table "
"starts with one line that indicates the tablename, and another line with "
"the fieldnames:"
msgstr "数据以 csv 文件的形式存储在 “somefile.csv” 中，其中每个表都以一行表示表名，另一行表示字段名："

#: ../../chapter-07.rst:3939
msgid ""
"Two tables are separated by ``\\r\\n\\r\\n`` (that is two empty lines). "
"The file ends with the line"
msgstr "两个表之间用  ``\\r\\n\\r\\n`` 分隔开（那是两个空行）。整个文件以下面的行结束："

#: ../../chapter-07.rst:3946
msgid ""
"The file does not include uploaded files if these are not stored in the "
"database. The upload files stored on filesystem must be dumped "
"separately, a zip of the “uploads” folder may suffice in most cases."
msgstr ""
"如果上传的文件未存储在数据库中，则导出文件不包括那些上传的文件。存储在文件系统上的上传文件必须单独转储，在大多数情况下， 将 “uploads” "
"文件夹压缩成 zip 文件即可满足需求。"

#: ../../chapter-07.rst:3950
msgid ""
"When importing, the new records will be appended to the database if it is"
" not empty. In general the new imported records will not have the same "
"record id as the original (saved) records but py4web will restore "
"references so they are not broken, even if the id values may change."
msgstr ""
"导入时，如果数据不为空，新记录将被添加到数据库中。一般来说，新导入的记录与原始（已保存）记录的记录 id 不同，但 py4web "
"会恢复引用，即使原记录的 id 值发生变化，引用关系也不会断裂。"

#: ../../chapter-07.rst:3955
msgid ""
"If a table contains a field called ``uuid``, this field will be used to "
"identify duplicates. Also, if an imported record has the same ``uuid`` as"
" an existing record, the previous record will be updated."
msgstr ""
"如果一个表包含一个名为 ``uuid`` 的字段，则该字段将用于识别重复项。此外，如果要导入的记录与已有记录具有相同的 ``uuid`` "
"\"，则已有的记录将被更新。"

#: ../../chapter-07.rst:3960
msgid "CSV and remote database synchronization"
msgstr "CSV 与远程数据库同步"

#: ../../chapter-07.rst:3962
msgid "Consider once again the following model:"
msgstr "再次考虑以下模型："

#: ../../chapter-07.rst:3978
msgid ""
"Each record is identified by an identifier and referenced by that id. If "
"you have two copies of the database used by distinct py4web "
"installations, the id is unique only within each database and not across "
"the databases. This is a problem when merging records from different "
"databases."
msgstr ""
"每条记录都由一个标识符标识 id ，并由该 id 引用。如果您有两个由不同 py4web 安装使用的数据库副本，则 id "
"仅在每个数据库内是唯一的，而不是在数据库之间。当合并来自不同数据库的记录时，这是一个问题。"

#: ../../chapter-07.rst:3984
msgid ""
"In order to make records uniquely identifiable across databases, they "
"must: - have a unique id (UUID), - have a last modification time to track"
" the most recent among multiple copies, - reference the UUID instead of "
"the id."
msgstr ""
"为了使记录在不同数据库中也是唯一的，它们必须：- 具有唯一的 id（UUID）；- 具有最后修改时间来跟踪多个副本中的最新的那个；- 引用 "
"UUID 代替一般的 id。"

#: ../../chapter-07.rst:3989
msgid "This can be achieved changing the above model into:"
msgstr "这可以通过将上述模型更改为："

#: ../../chapter-07.rst:4021
msgid ""
"Notice that in the above table definitions, the default value for the two"
" ``uuid`` fields is set to a lambda function, which returns a UUID "
"(converted to a string). The lambda function is called once for each "
"record inserted, ensuring that each record gets a unique UUID, even if "
"multiple records are inserted in a single transaction."
msgstr ""
"请注意，在上面的表定义中，两个 ``uuid`` 字段的默认值被设置为一个 lambda 函数，该函数返回一个 "
"uuid（转换为字符串）。插入的每条记录调用一次 lambda 函数，确保每条记录都有一个唯一的 UUID，即使在单个事务中插入了多条记录。"

#: ../../chapter-07.rst:4027
msgid "Create a controller action to export the database:"
msgstr "创建一个控制器 action 以导出数据库："

#: ../../chapter-07.rst:4039
msgid ""
"Create a controller action to import a saved copy of the other database "
"and sync records:"
msgstr "创建另一个控制器 action 以导入其他数据库中已保存记录的副本并同步记录："

#: ../../chapter-07.rst:4063
msgid ""
"Optionally you should create an index manually to make the search by uuid"
" faster."
msgstr "您可以选择手动创建索引，以加快按 uuid 搜索的速度。"

#: ../../chapter-07.rst:4066
msgid "Alternatively, you can use XML-RPC to export/import the file."
msgstr "或者，您可以使用 XML-RPC 导出/导入文件。"

#: ../../chapter-07.rst:4068
msgid ""
"If the records reference uploaded files, you also need to export/import "
"the content of the uploads folder. Notice that files therein are already "
"labeled by UUIDs so you do not need to worry about naming conflicts and "
"references."
msgstr "如果记录引用了上传的文件，您还需要导出/导入上传文件夹的内容。请注意，其中的文件已经用 UUID 标记，因此您不必担心命名冲突和引用。"

#: ../../chapter-07.rst:4074
msgid "HTML and XML (one Table at a time)"
msgstr "HTML 和 XML (一次一个表)"

#: ../../chapter-07.rst:4076
msgid ""
"Rows objects also have an ``xml`` method (like helpers) that serializes "
"it to XML/HTML:"
msgstr "Rows 对象还有一个  ``xml`` 方法（类似 heplers），它可以将 Rows 对象序列化为XML/HTML："

#: ../../chapter-07.rst:4113
msgid ""
"If you need to serialize the Rows in any other XML format with custom "
"tags, you can easily do that using the universal ``TAG`` XML helper that "
"we'll see later and the Python syntax ``*<iterable>`` allowed in function"
" calls:"
msgstr ""
"如果你需要使用自定义标签以任何其他 XML 格式序列化 Rows，你可以使用我们稍后将看到的通用 ``TAG`` XML helper "
"和函数调用中允许的 Python 语法 ``*<iterable>`` 轻松完成："

#: ../../chapter-07.rst:4133
msgid ""
"Do not confuse the `TAG` XML helper used here (see the :ref:`TAG` "
"chapter) with the ``Tags`` method that will be extensively explained on "
"the :ref:`Authorization using Tags` chapter."
msgstr ""
"不要将这里使用的 `TAG` XML helper （请参阅 :ref:`TAG` 一章）与 ``Tags`` 方法混淆，后者将在 "
":ref:`Authorization using Tags` 一章中详细解释。"

#: ../../chapter-07.rst:4139
msgid "Data representation"
msgstr ""

#: ../../chapter-07.rst:4141
msgid ""
"The ``Rows.export_to_csv_file`` method accepts a keyword argument named "
"``represent``. When ``True`` it will use the columns ``represent`` "
"function while exporting the data instead of the raw data."
msgstr ""
"``Rows.export_to_csv_file`` 方法接受一个名为 ``represent`` 的关键字参数。当设置为 ``True`` "
"时，它将在导出数据时使用列的 ``represent`` 函数，而不是原始数据。"

#: ../../chapter-07.rst:4145
msgid ""
"The function also accepts a keyword argument named ``colnames`` that "
"should contain a list of column names one wish to export. It defaults to "
"all columns."
msgstr "该函数还接受一个名为 ``colnames`` 的关键字参数，该参数应包含要导出的列名列表。它默认为所有列。"

#: ../../chapter-07.rst:4149
msgid ""
"Both ``export_to_csv_file`` and ``import_from_csv_file`` accept keyword "
"arguments that tell the csv parser the format to save/load the files: - "
"``delimiter``: delimiter to separate values (default ‘,’) - "
"``quotechar``: character to use to quote string values (default to double"
" quotes) - ``quoting``: quote system (default ``csv.QUOTE_MINIMAL``)"
msgstr ""
"``export_to_csv_file`` 和 ``import_from_csv_file`` 都接受关键字参数，这些参数告诉 csv "
"解析器保存/加载文件的格式：- ``delimiter`` ：分隔值的分隔符（默认为“，”）；- ``quotechar`` "
"：用于引用字符串值的字符（默认为双引号）；- ``quoting`` ：添加引号的规则（默认为 ``csv.QUOTE_MINIMAL``）"

#: ../../chapter-07.rst:4156
msgid "Here is some example usage:"
msgstr "以下是一些用法示例："

#: ../../chapter-07.rst:4168
msgid "Which would render something similar to"
msgstr "呈现结果类似于"

#: ../../chapter-07.rst:4174
msgid "For more information consult the official Python documentation"
msgstr "有关更多信息，请参阅 Python 官方文档。 "

#: ../../chapter-07.rst:4178
msgid "Advanced features"
msgstr "高级功能"

#: ../../chapter-07.rst:4183
msgid "``list:<type>`` and ``contains``"
msgstr "``list:<type>`` 和 ``contains``"

#: ../../chapter-07.rst:4185
msgid "py4web provides the following special field types:"
msgstr "py4web 提供以下特殊字段类型："

#: ../../chapter-07.rst:4193
msgid ""
"They can contain lists of strings, of integers and of references "
"respectively."
msgstr "它们可以分别包含字符串列表、整数列表和引用列表。"

#: ../../chapter-07.rst:4196
msgid ""
"On Google App Engine NoSQL ``list:string`` is mapped into "
"``StringListProperty``, the other two are mapped into "
"``ListProperty(int)``. On relational databases they are mapped into text "
"fields which contain the list of items separated by ``|``. For example "
"``[1, 2, 3]`` is mapped into ``|1|2|3|``."
msgstr ""
"在 Google App Engine NoSQL ``list:string`` 被映射到 ``StringListProperty`` "
"，另外两个被映射到 ``ListProperty(int)`` 。在关系数据库中，它们被映射到包含以 ``|`` "
"分隔的项目列表的文本字段中。例如，``[1, 2, 3]`` 被映射到 ``|1|2|3|`` 。"

#: ../../chapter-07.rst:4202
msgid ""
"For lists of string the items are escaped so that any ``|`` in the item "
"is replaced by a ``||``. Anyway this is an internal representation and it"
" is transparent to the user."
msgstr "对于字符串列表，项目被转义，项目中的任何 ``|`` 都被 ``||`` 替换。无论如何，这是一个内部表示，对用户是透明的。"

#: ../../chapter-07.rst:4206
msgid "You can use ``list:string``, for example, in the following way:"
msgstr "例如，您可以按以下方式使用 ``list:string`` ："

#: ../../chapter-07.rst:4223
msgid "``list:integer`` works in the same way but the items must be integers."
msgstr "``list:integer`` 的工作方式相同，但项目必须是整数。"

#: ../../chapter-07.rst:4225
msgid ""
"As usual the requirements are enforced at the level of forms, not at the "
"level of ``insert``."
msgstr "与往常一样，这些要求是在表单层面执行的，而不是在数据库中调用 ``insert`` 时。"

#: ../../chapter-07.rst:4228
msgid ""
"For ``list:<type>`` fields the ``contains(value)`` operator maps into a "
"non trivial query that checks for lists containing the ``value``. The "
"``contains`` operator also works for regular ``string`` and ``text`` "
"fields and it maps into a ``LIKE '%value%'``."
msgstr ""
"对于 ``list:<type>`` 字段， ``contains(value)`` 运算符映射到一个复制的查询中，该查询检查列表是否包含 "
"``value`` 元素。``contains`` 运算符也适用于常规的 ``string`` 字段和 ``text`` 字段，它映射到 "
"``LIKE '%value%'`` 。"

#: ../../chapter-07.rst:4233
msgid ""
"The ``list:reference`` and the ``contains(value)`` operator are "
"particularly useful to de-normalize many-to-many relations. Here is an "
"example:"
msgstr "``list:reference`` 和 ``contains(value)`` 运算符对于反规范化多对多关系特别有用。以下是一个示例："

#: ../../chapter-07.rst:4262
msgid "Notice that a ``list:reference tag`` field get a default constraint"
msgstr "请注意，``list:reference tag`` 字段获取到默认约束"

#: ../../chapter-07.rst:4268
msgid "that produces a ``SELECT/OPTION`` multiple drop-box in forms."
msgstr "它在表单中生成一个 ``SELECT/OPTION`` 多个项目的下拉框。"

#: ../../chapter-07.rst:4270
msgid ""
"Also notice that this field gets a default ``represent`` attribute which "
"represents the list of references as a comma-separated list of formatted "
"references. This is used in read ``forms``."
msgstr ""
"还要注意，此字段有一个默认的 ``represent`` 属性，它将引用列表表示为逗号分隔的格式化显示的引用列表。这用于只读的 ``forms``"
" 。"

#: ../../chapter-07.rst:4274
msgid ""
"While ``list:reference`` has a default validator and a default "
"representation, ``list:integer`` and ``list:string`` do not. So these two"
" need an ``IS_IN_SET`` or an ``IS_IN_DB`` validator if you want to use "
"them in forms."
msgstr ""
"虽然 ``list:reference`` 有一个默认验证器和一个默认表示，但 ``list:integer`` 和 "
"``list:string`` 没有。因此，如果要在表单中使用验证器，则需要给字段添加 ``IS_IN_SET`` 或 ``IS_IN_DB`` "
"验证器。"

#: ../../chapter-07.rst:4281
msgid "Table inheritance"
msgstr "“表” 的继承"

#: ../../chapter-07.rst:4283
msgid ""
"It is possible to create a table that contains all the fields from "
"another table. It is sufficient to pass the other table in place of a "
"field to ``define_table``. For example"
msgstr "可以创建一个包含另一个表中所有字段的表。将另一个表代替字段传递给 ``define_table`` 就足够了。例如"

#: ../../chapter-07.rst:4294
msgid ""
"It is also possible to define a dummy table that is not stored in a "
"database in order to reuse it in multiple other places. For example:"
msgstr "可以定义一个不存储在数据库中的虚拟表，以便在多个其他地方重用它。例如："

#: ../../chapter-07.rst:4310
msgid "This example assumes that standard py4web authentication is enabled."
msgstr "此示例假设启用了标准的 py4web 身份验证。"

#: ../../chapter-07.rst:4312
msgid ""
"Notice that if you use ``Auth`` py4web already creates one such table for"
" you:"
msgstr "请注意，如果您使用 ``Auth`` ，py4web 就已经为您创建了一个这样的表："

#: ../../chapter-07.rst:4320
msgid ""
"When using table inheritance, if you want the inheriting table to inherit"
" validators, be sure to define the validators of the parent table before "
"defining the inheriting table."
msgstr "使用表继承时，如果希望继承表继承验证器，请务必在定义继承表之前定义父表的验证器。"

#: ../../chapter-07.rst:4327
msgid "``filter_in`` and ``filter_out``"
msgstr "``filter_in`` 和 ``filter_out``"

#: ../../chapter-07.rst:4329
msgid ""
"It is possible to define a filter for each field to be called before a "
"value is inserted into the database for that field and after a value is "
"retrieved from the database."
msgstr "在将该字段的值插入数据库之前和从数据库检索字段的值之后，可以为每个要处理的字段定义一个过滤器。"

#: ../../chapter-07.rst:4333
msgid ""
"Imagine for example that you want to store a serializable Python data "
"structure in a field in the JSON format. Here is how it could be "
"accomplished:"
msgstr "例如，想象一下，你想在 JSON格 式的字段中存储一个可序列化的 Python 数据结构。以下是实现这一目标的方法："

#: ../../chapter-07.rst:4352
msgid ""
"Another way to accomplish the same is by using a Field of type "
"``SQLCustomType``, as discussed in :ref:`Custom Field types`."
msgstr "另一种实现此目的的方法是使用 ``SQLCustomType`` 类型的字段，如 :ref:`Custom Field types` 中所述。"

#: ../../chapter-07.rst:4356
msgid "callbacks on record insert, delete and update"
msgstr "在记录被 insert、 delete 和 update 时的回调"

#: ../../chapter-07.rst:4358
msgid ""
"PY4WEB provides a mechanism to register callbacks to be called before "
"and/or after insert, update and delete of records."
msgstr "PY4WEB 提供了一种机制，用于注册在 insert、 delete 和 update 记录之前和/或之后调用的回调函数。"

#: ../../chapter-07.rst:4361
msgid "Each table stores six lists of callbacks:"
msgstr "每个表存储六个回调列表："

#: ../../chapter-07.rst:4372
msgid ""
"You can register a callback function by appending it to the corresponding"
" list. The caveat is that depending on the functionality, the callback "
"has different signature."
msgstr "您可以通过将回调函数添加到相应的回调函数列表中来注册它。需要注意的是，根据功能的不同，回调函数需要具有不同的签名。"

#: ../../chapter-07.rst:4376
msgid "This is best explained by examples."
msgstr "这最好用例子来解释："

#: ../../chapter-07.rst:4404
msgid ""
"As you can see: - ``f`` gets passed the ``OpRow`` object with data for "
"insert or update. - ``i`` gets passed the id of the newly inserted "
"record. - ``s`` gets passed the ``Set`` object used for update or delete."
" ``OpRow`` is an helper object specialized in storing (field, value) "
"pairs, you can think of it as a normal dictionary that you can use even "
"with the syntax of attribute notation (that is ``f.name`` and "
"``f['name']`` are equivalent)."
msgstr ""
"如您所见：- ``f`` 传递 ``OpRow`` 对象，其中包含插入或更新的数据。 - ``i`` 传递新插入记录的 id。- ``s`` "
"传递用于更新或删除操作的 Set 对象。 ``OpRow`` "
"是一个专门用于存储（字段，值）对的辅助对象，您可以将其视为一个普通的字典，甚至可以使用属性表示法的语法来操作（即 ``f.name`` 和 "
"``f['name']`` 是等效的）。"

#: ../../chapter-07.rst:4412
msgid ""
"The return values of these callback should be ``None`` or ``False``. If "
"any of the ``_before_*`` callback returns a ``True`` value it will abort "
"the actual insert/update/delete operation."
msgstr ""
"这些回调函数的返回值应该是 ``None`` 或者 ``False`` 。如果任意一个 ``_before_*`` 回调函数返回的值是 "
"``True`` ，对应的实际 insert/update/delete 操作将被终止。"

#: ../../chapter-07.rst:4416
msgid ""
"Some times a callback may need to perform an update in the same or a "
"different table and one wants to avoid firing other callbacks, which "
"could cause an infinite loop."
msgstr "有时，回调可能需要在相同或不同的表中执行更新，并且希望避免触发其他回调，这可能会导致无限循环。"

#: ../../chapter-07.rst:4420
msgid ""
"For this purpose there the ``Set`` objects have an ``update_naive`` "
"method that works like ``update`` but ignores before and after callbacks."
msgstr "为此， ``Set`` 对象有一个 ``update_naive`` 方法，其工作方式类似于update，但忽略其执行前后可能触发的其它回调。"

#: ../../chapter-07.rst:4425
msgid "Database cascades"
msgstr "数据库的级联操作"

#: ../../chapter-07.rst:4427
msgid ""
"Database schema can define relationships which trigger deletions of "
"related records, known as cascading. The DAL is not informed when a "
"record is deleted due to a cascade. So no \\*_delete callback will ever "
"be called as consequence of a cascade-deletion."
msgstr ""
"数据库模式可以定义触发删除相关记录的关系，称为级联。当记录因级联而被删除时，DAL 不会收到通知。因此，级联导致的删除不会触发 "
"\\*_delete 回调。"

#: ../../chapter-07.rst:4433
msgid "Record versioning"
msgstr "记录版本控制"

#: ../../chapter-07.rst:4435
msgid ""
"It is possible to ask py4web to save every copy of a record when the "
"record is individually modified. There are different ways to do it and it"
" can be done for all tables at once using the syntax:"
msgstr "当记录被单独修改时，可以要求 py4web 保存记录的每个副本。有不同的方法可以做到这一点，并且可以使用以下语法一次对所有表完成设置："

#: ../../chapter-07.rst:4443
msgid ""
"this requires ``Auth``. It can also be done for each individual table as "
"discussed below."
msgstr "这种设置需要 ``Auth`` ，也可以像下面一样对每个单独的表进行设置。"

#: ../../chapter-07.rst:4446
msgid "Consider the following table:"
msgstr "假设有下面的表："

#: ../../chapter-07.rst:4456
msgid ""
"Notice the hidden boolean field called ``is_active`` and defaulting to "
"True."
msgstr "请注意，名为 ``is_active`` 的隐藏布尔字段，其默认值为 True"

#: ../../chapter-07.rst:4459
msgid ""
"We can tell py4web to create a new table (in the same or a different "
"database) and store all previous versions of each record in the table, "
"when modified."
msgstr "我们可以让 py4web 创建一个新表（在相同或不同的数据库中），并在修改时将每条记录的所有先前版本存储在表中。"

#: ../../chapter-07.rst:4463
msgid "This is done in the following way:"
msgstr "使用下面的方法实现："

#: ../../chapter-07.rst:4469
msgid "or in a more verbose syntax:"
msgstr "或使用更多参数："

#: ../../chapter-07.rst:4478
msgid ""
"The ``archive_db=db`` tells py4web to store the archive table in the same"
" database as the ``stored_item`` table. The ``archive_name`` sets the "
"name for the archive table. The archive table has the same fields as the "
"original table ``stored_item`` except that unique fields are no longer "
"unique (because it needs to store multiple versions) and has an extra "
"field which name is specified by ``current_record`` and which is a "
"reference to the current record in the ``stored_item`` table."
msgstr ""
"``archive_db=db`` 命令告诉 py4web 将归档表存储在与 ``stored_item`` "
"表相同的数据库中。``archive_name`` 设置存档表的名称。存档表具有与原始表 ``stored_item`` "
"相同的字段，除了唯一字段不再是唯一的（因为它需要存储多个版本），并且有一个额外的字段，它是对 ``stored_item`` "
"表中当前记录的引用，其名称由 ``current_record`` 指定。"

#: ../../chapter-07.rst:4486
msgid ""
"When records are deleted, they are not really deleted. A deleted record "
"is copied in the ``stored_item_archive`` table (like when it is modified)"
" and the ``is_active`` field is set to False. By enabling record "
"versioning py4web sets a ``common_filter`` on this table that hides all "
"records in table ``stored_item`` where the ``is_active`` field is set to "
"False. The ``is_active`` parameter in the ``_enable_record_versioning`` "
"method allows to specify the name of the field used by the "
"``common_filter`` to determine if the field was deleted or not."
msgstr ""
"当记录被删除时，它们并没有真正被删除。已删除的记录会被复制到 ``stored_item_archive`` 表中（就像它被修改时一样），并且 "
"``is_active`` 字段被设置为 False。通过启用记录版本控制，py4web 在此表上设置了一个 ``common_filter`` "
"，该筛选器隐藏了表 ``stored_item`` 中 ``is_active`` 字段设置为 False 的所有记录。 "
"``_enable_record_versioning`` 方法中的 ``is_active`` 参数允许指定 ``common_filter``"
" 用于确定字段是否被删除的字段的名称。"

#: ../../chapter-07.rst:4497
msgid "Common filters"
msgstr "通用的过滤器（Common filters）"

#: ../../chapter-07.rst:4499
msgid ""
"A common filter is a generalization of the above multi-tenancy idea. It "
"provides an easy way to prevent repeating of the same query. Consider for"
" example the following table:"
msgstr "通用过滤器（Common filter）是上述多用户概念的推广。它提供了一种简单的方法来防止重复相同的查询。例如，考虑下表："

#: ../../chapter-07.rst:4511
msgid ""
"Any select, delete or update in this table, will include only public blog"
" posts. The attribute can also be modified at runtime:"
msgstr "此表中的任何查询、删除或更新都将仅包括 “公开” 的博客帖子。该属性也可以在运行时修改："

#: ../../chapter-07.rst:4518
msgid ""
"It serves both as a way to avoid repeating the "
"“db.blog_post.is_public==True” phrase in each blog post search, and also "
"as a security enhancement, that prevents you from forgetting to disallow "
"viewing of non-public posts."
msgstr ""
"它既是一种避免在每次博客文章搜索中重复 “db.blog_post.is_public==True” "
"短语的方法，也是一种安全增强，可以防止您忘记设置 “禁止查看” 非公开文章。"

#: ../../chapter-07.rst:4523
msgid ""
"In case you actually do want items left out by the common filter (for "
"example, allowing the admin to see non-public posts), you can either "
"remove the filter:"
msgstr "如果您确实希望查询过滤器遗漏的项目（例如，允许管理员查看非公开帖子），您可以删除过滤器："

#: ../../chapter-07.rst:4531
msgid "or ignore it:"
msgstr "或者忽略过滤器："

#: ../../chapter-07.rst:4539
msgid "Note that common_filters are ignored by the appadmin interface."
msgstr "请注意，appadmin 接口会自动忽略 common_filters。"

#: ../../chapter-07.rst:4544
msgid "Custom ``Field`` types"
msgstr "自定义的 ``Field`` 类型"

#: ../../chapter-07.rst:4546
msgid ""
"Aside for using ``filter_in`` and ``filter_out``, it is possible to "
"define new/custom field types. For example, suppose that you want to "
"define a custom type to store an IP address:"
msgstr ""
"在不使用 ``filter_in`` 和 ``filter_out`` 的时候，还可以定义新的自定义字段类型。例如，下面假设你要定义一个存储 IP"
" 地址数据的自定义类型："

#: ../../chapter-07.rst:4591
msgid ""
"``SQLCustomType`` is a field type factory. Its ``type`` argument must be "
"one of the standard py4web types. It tells py4web how to treat the field "
"values at the py4web level. ``native`` is the type of the field as far as"
" the database is concerned. Allowed names depend on the database engine. "
"``encoder`` is an optional transformation function applied when the data "
"is stored and ``decoder`` is the optional reverse transformation "
"function."
msgstr ""
"``SQLCustomType`` 是一个字段类型工厂。参数 ``type`` 必须是标准的 py4 web 类型之一，它告诉 py4web "
"将输入的字段的值在 py4web 程序中按哪种类型对待；参数 ``native`` 是数据库中存储数据的字段类型，允许的名称取决于数据库引擎；参数"
" ``encoder`` 是存储数据时应用的可选变换函数；参数 ``decoder`` 是可选的逆变换函数。"

#: ../../chapter-07.rst:4599
msgid ""
"This feature is marked as experimental because can make your code not "
"portable across database engines."
msgstr "此功能被标记为实验性的，因为它会使您的代码无法在数据库引擎之间移植。"

#: ../../chapter-07.rst:4602
msgid "It does not work on Google App Engine NoSQL."
msgstr "它不适用于 Google App Engine NoSQL。"

#: ../../chapter-07.rst:4605
msgid "Using DAL without define tables"
msgstr "使用不定义表的 DAL "

#: ../../chapter-07.rst:4607
msgid "The DAL can be used from any Python program simply by doing this:"
msgstr "DAL 可以从任何 Python 程序中使用，只需执行以下操作："

#: ../../chapter-07.rst:4614
msgid ""
"i.e. import the DAL, connect and specify the folder which contains the "
".table files (the app/databases folder)."
msgstr "即，导入 DAL，连接并指定包含 .table 文件的文件夹（app/databases 文件夹）。"

#: ../../chapter-07.rst:4617
msgid ""
"To access the data and its attributes we still have to define all the "
"tables we are going to access with ``db.define_table``."
msgstr "为了访问数据及其属性，我们仍然需要定义我们将使用 ``db.define_table`` 访问的所有表。"

#: ../../chapter-07.rst:4620
msgid ""
"If we just need access to the data but not to the py4web table "
"attributes, we get away without re-defining the tables but simply asking "
"py4web to read the necessary info from the metadata in the .table files:"
msgstr ""
"如果我们只需要访问数据，而不需要访问 py4web 表属性，那么不需要再重新定义表，只需要让 py4web 从 .table "
"文件中的元数据中读取必要的信息："

#: ../../chapter-07.rst:4629
msgid "This allows us to access any db.table without need to re-define it."
msgstr "这允许我们访问任意的  db.table ，而无需再重新定义要访问的表。"

#: ../../chapter-07.rst:4632
msgid "Distributed transaction"
msgstr "分布式事务"

#: ../../chapter-07.rst:4634
msgid ""
"At the time of writing this feature is only supported by PostgreSQL, "
"MySQL and Firebird, since they expose API for two-phase commits."
msgstr "在撰写本文时，只有 PostgreSQL、MySQL 和 Firebird 支持此功能，因为它们公开了API 用于两阶段的提交。"

#: ../../chapter-07.rst:4637
msgid ""
"Assuming you have two (or more) connections to distinct PostgreSQL "
"databases, for example:"
msgstr "假设你有两个（或更多）连接到不同的 PostgreSQL 数据库，例如："

#: ../../chapter-07.rst:4645
msgid "In your models or controllers, you can commit them concurrently with:"
msgstr "在您的模型或控制器中，您可以同时提交它们："

#: ../../chapter-07.rst:4651
msgid "On failure, this function rolls back and raises an ``Exception``."
msgstr "如果失败，此函数将回滚并引发 ``Exception``。"

#: ../../chapter-07.rst:4653
msgid ""
"In controllers, when one action returns, if you have two distinct "
"connections and you do not call the above function, py4web commits them "
"separately. This means there is a possibility that one of the commits "
"succeeds and one fails. The distributed transaction prevents this from "
"happening."
msgstr ""
"在控制器中，当一个 action 返回时，如果您有两个不同的数据库连接并且没有调用上述函数，py4web "
"会分别提交它们。这意味着有可能一个提交成功，另一个提交失败。分布式事务可以防止这种情况发生。"

#: ../../chapter-07.rst:4661
msgid "Copy data from one db into another"
msgstr "将数据从一个数据库复制到另一个数据库"

#: ../../chapter-07.rst:4663
msgid ""
"Consider the situation in which you have been using the following "
"database:"
msgstr "假设您一直在使用以下数据库的情况："

#: ../../chapter-07.rst:4670
msgid ""
"and you wish to move to another database using a different connection "
"string:"
msgstr "并且您希望使用不同的连接字符串切换到另一个数据库："

#: ../../chapter-07.rst:4677
msgid ""
"Before you switch, you want to move the data and rebuild all the metadata"
" for the new database. We assume the new database to exist but we also "
"assume it is empty."
msgstr "在切换之前，您需要移动数据并为新数据库重建所有元数据。我们假设新数据库存在，但也假设它是空的。"

#: ../../chapter-07.rst:4683
msgid "Gotchas"
msgstr "陷阱"

#: ../../chapter-07.rst:4686
msgid "Note on new DAL and adapters"
msgstr "关于新 DAL 和适配器的说明"

#: ../../chapter-07.rst:4690
msgid ""
"The source code of the Database Abstraction Layer was completely "
"rewritten in 2010. While it stays backward compatible, the rewrite made "
"it more modular and easier to extend. Here we explain the main logic."
msgstr "数据库抽象层的源代码在 2010 年被完全重写。虽然它保持向后兼容，但重写使其更加模块化，更容易扩展。这里我们解释一下主要逻辑。"

#: ../../chapter-07.rst:4694
msgid "The module “dal.py” defines, among other, the following classes."
msgstr "模块 “dal.py” 主要定义了以下类："

#: ../../chapter-07.rst:4710
msgid ""
"Their use has been explained in the previous sections, except for "
"``BaseAdapter``. When the methods of a ``Table`` or ``Set`` object need "
"to communicate with the database they delegate to methods of the adapter "
"the task to generate the SQL and or the function call."
msgstr ""
"除了 ``BaseAdapter`` 之外，在前面的章节中已经解释了它们的用法。当 ``Table`` 或 ``Set`` "
"对象的方法需要与数据库通信时，它们将生成 SQL 和/或函数调用的任务委托给适配器的方法。"

#: ../../chapter-07.rst:4721
msgid "calls"
msgstr "调用"

#: ../../chapter-07.rst:4727
msgid "which delegates the adapter by returning:"
msgstr "该命令通过返回以下内容来委派适配器："

#: ../../chapter-07.rst:4733
msgid ""
"Here ``db.mytable._listify`` converts the dict of arguments into a list "
"of ``(field,value)`` and calls the ``insert`` method of the ``adapter``. "
"``db._adapter`` does more or less the following:"
msgstr ""
"这里 ``db.mytable._listify`` 将参数的 dict 转换为 ``(field,value)`` 列表，并调用 "
"``adapter`` 的 ``insert`` 方法。 ``db._adapter`` 执行以下类似的操作："

#: ../../chapter-07.rst:4742
msgid "where the first line builds the query and the second executes it."
msgstr "其中第一行构建查询，第二行执行查询。"

#: ../../chapter-07.rst:4744
msgid "``BaseAdapter`` defines the interface for all adapters."
msgstr "``BaseAdapter`` 定义了适配器的所有接口。"

#: ../../chapter-07.rst:4746
msgid "pyDAL at the moment of writing this book, contains the following adapters:"
msgstr "在撰写本书时，pyDAL 包含以下适配器："

#: ../../chapter-07.rst:4779
msgid "which override the behavior of the ``BaseAdapter``."
msgstr "它们重写了 ``BaseAdapter`` 的行为。"

#: ../../chapter-07.rst:4781
msgid "Each adapter has more or less this structure:"
msgstr "每个适配器都有这种类似的结构："

#: ../../chapter-07.rst:4818
msgid ""
"Looking at the various adapters as example should be easy to write new "
"ones."
msgstr "以各种适配器为例，应该很容易编写新的适配器。"

#: ../../chapter-07.rst:4821
msgid "When ``db`` instance is created:"
msgstr "当创建 ``db`` 实例时："

#: ../../chapter-07.rst:4827
msgid ""
"the prefix in the uri string defines the adapter. The mapping is defined "
"in the following dictionary also in “dal.py”:"
msgstr "DAL() 中 uri 字符串的前缀定义了适配器。在以下字典中定义的映射，在 “dal.py” 中也有定义："

#: ../../chapter-07.rst:4834
msgid "couchdb"
msgstr ""

#: ../../chapter-07.rst:4835
msgid "pydal.adapters.couchdb.CouchDB"
msgstr ""

#: ../../chapter-07.rst:4836
msgid "cubrid"
msgstr ""

#: ../../chapter-07.rst:4837
msgid "pydal.adapters.mysql.Cubrid"
msgstr ""

#: ../../chapter-07.rst:4838
msgid "db2:ibm_db_dbi"
msgstr ""

#: ../../chapter-07.rst:4839
msgid "pydal.adapters.db2.DB2IBM"
msgstr ""

#: ../../chapter-07.rst:4840
msgid "db2:pyodbc"
msgstr ""

#: ../../chapter-07.rst:4841
msgid "pydal.adapters.db2.DB2Pyodbc"
msgstr ""

#: ../../chapter-07.rst:4842
msgid "firebird"
msgstr ""

#: ../../chapter-07.rst:4843
msgid "pydal.adapters.firebird.FireBird"
msgstr ""

#: ../../chapter-07.rst:4844
msgid "firebird_embedded"
msgstr ""

#: ../../chapter-07.rst:4845
msgid "pydal.adapters.firebird.FireBirdEmbedded"
msgstr ""

#: ../../chapter-07.rst:4846
msgid "google:MySQLdb"
msgstr ""

#: ../../chapter-07.rst:4847
msgid "pydal.adapters.google.GoogleMySQL"
msgstr ""

#: ../../chapter-07.rst:4848
msgid "google:datastore"
msgstr ""

#: ../../chapter-07.rst:4849 ../../chapter-07.rst:4851
msgid "pydal.adapters.google.GoogleDatastore"
msgstr ""

#: ../../chapter-07.rst:4850
msgid "google:datastore+ndb"
msgstr ""

#: ../../chapter-07.rst:4852
msgid "google:psycopg2"
msgstr ""

#: ../../chapter-07.rst:4853
msgid "pydal.adapters.google.GooglePostgres"
msgstr ""

#: ../../chapter-07.rst:4854
msgid "google:sql"
msgstr ""

#: ../../chapter-07.rst:4855
msgid "pydal.adapters.google.GoogleSQL"
msgstr ""

#: ../../chapter-07.rst:4856
msgid "informix"
msgstr ""

#: ../../chapter-07.rst:4857
msgid "pydal.adapters.informix.Informix"
msgstr ""

#: ../../chapter-07.rst:4858
msgid "informix-se"
msgstr ""

#: ../../chapter-07.rst:4859
msgid "pydal.adapters.informix.InformixSE"
msgstr ""

#: ../../chapter-07.rst:4860
msgid "ingres"
msgstr ""

#: ../../chapter-07.rst:4861
msgid "pydal.adapters.ingres.Ingres"
msgstr ""

#: ../../chapter-07.rst:4862
msgid "ingresu"
msgstr ""

#: ../../chapter-07.rst:4863
msgid "pydal.adapters.ingres.IngresUnicode"
msgstr ""

#: ../../chapter-07.rst:4864
msgid "jdbc:postgres"
msgstr ""

#: ../../chapter-07.rst:4865
msgid "pydal.adapters.postgres.JDBCPostgre"
msgstr ""

#: ../../chapter-07.rst:4866
msgid "jdbc:sqlite"
msgstr ""

#: ../../chapter-07.rst:4867 ../../chapter-07.rst:4869
msgid "pydal.adapters.sqlite.JDBCSQLite"
msgstr ""

#: ../../chapter-07.rst:4868
msgid "jdbc:sqlite:memory"
msgstr ""

#: ../../chapter-07.rst:4870
msgid "mongodb"
msgstr ""

#: ../../chapter-07.rst:4871
msgid "pydal.adapters.mongo.Mongo"
msgstr ""

#: ../../chapter-07.rst:4872
msgid "mssql"
msgstr ""

#: ../../chapter-07.rst:4873
msgid "pydal.adapters.mssql.MSSQL1"
msgstr ""

#: ../../chapter-07.rst:4874
msgid "mssql2"
msgstr ""

#: ../../chapter-07.rst:4875 ../../chapter-07.rst:4885
msgid "pydal.adapters.mssql.MSSQL1N"
msgstr ""

#: ../../chapter-07.rst:4876
msgid "mssql3"
msgstr ""

#: ../../chapter-07.rst:4877
msgid "pydal.adapters.mssql.MSSQL3"
msgstr ""

#: ../../chapter-07.rst:4878
msgid "mssql3n"
msgstr ""

#: ../../chapter-07.rst:4879
msgid "pydal.adapters.mssql.MSSQL3N"
msgstr ""

#: ../../chapter-07.rst:4880
msgid "mssql4"
msgstr ""

#: ../../chapter-07.rst:4881
msgid "pydal.adapters.mssql.MSSQL4"
msgstr ""

#: ../../chapter-07.rst:4882
msgid "mssql4n"
msgstr ""

#: ../../chapter-07.rst:4883
msgid "pydal.adapters.mssql.MSSQL4N"
msgstr ""

#: ../../chapter-07.rst:4884
msgid "mssqln"
msgstr ""

#: ../../chapter-07.rst:4886
msgid "mysql"
msgstr ""

#: ../../chapter-07.rst:4887
msgid "pydal.adapters.mysql.MySQL"
msgstr ""

#: ../../chapter-07.rst:4888
msgid "oracle"
msgstr ""

#: ../../chapter-07.rst:4889
msgid "pydal.adapters.oracle.Oracle"
msgstr ""

#: ../../chapter-07.rst:4890
msgid "postgres"
msgstr ""

#: ../../chapter-07.rst:4891
msgid "pydal.adapters.postgres.Postgre"
msgstr ""

#: ../../chapter-07.rst:4892
msgid "postgres2"
msgstr ""

#: ../../chapter-07.rst:4893
msgid "pydal.adapters.postgres.PostgreNew"
msgstr ""

#: ../../chapter-07.rst:4894
msgid "postgres2:psycopg2"
msgstr ""

#: ../../chapter-07.rst:4895
msgid "pydal.adapters.postgres.PostgrePsycoNew"
msgstr ""

#: ../../chapter-07.rst:4896
msgid "postgres3"
msgstr ""

#: ../../chapter-07.rst:4897
msgid "pydal.adapters.postgres.PostgreBoolean"
msgstr ""

#: ../../chapter-07.rst:4898
msgid "postgres3:psycopg2"
msgstr ""

#: ../../chapter-07.rst:4899
msgid "pydal.adapters.postgres.PostgrePsycoBoolean"
msgstr ""

#: ../../chapter-07.rst:4900
msgid "postgres:psycopg2"
msgstr ""

#: ../../chapter-07.rst:4901
msgid "pydal.adapters.postgres.PostgrePsyco"
msgstr ""

#: ../../chapter-07.rst:4902
msgid "pytds"
msgstr ""

#: ../../chapter-07.rst:4903
msgid "pydal.adapters.mssql.PyTDS"
msgstr ""

#: ../../chapter-07.rst:4905
msgid "pydal.adapters.sap.SAPDB"
msgstr ""

#: ../../chapter-07.rst:4906
msgid "spatialite"
msgstr ""

#: ../../chapter-07.rst:4907 ../../chapter-07.rst:4909
msgid "pydal.adapters.sqlite.Spatialite"
msgstr ""

#: ../../chapter-07.rst:4908
msgid "spatialite:memory"
msgstr ""

#: ../../chapter-07.rst:4910
msgid "sqlite"
msgstr ""

#: ../../chapter-07.rst:4911 ../../chapter-07.rst:4913
msgid "pydal.adapters.sqlite.SQLite"
msgstr ""

#: ../../chapter-07.rst:4912
msgid "sqlite:memory"
msgstr ""

#: ../../chapter-07.rst:4914
msgid "sybase"
msgstr ""

#: ../../chapter-07.rst:4915
msgid "pydal.adapters.mssql.Sybase"
msgstr ""

#: ../../chapter-07.rst:4916
msgid "teradata"
msgstr ""

#: ../../chapter-07.rst:4917
msgid "pydal.adapters.teradata.Teradata"
msgstr ""

#: ../../chapter-07.rst:4918
msgid "vertica"
msgstr ""

#: ../../chapter-07.rst:4919
msgid "pydal.adapters.mssql.Vertica"
msgstr ""

#: ../../chapter-07.rst:4921
msgid ""
"the uri string is then parsed in more detail by the adapter itself. An "
"updated list of adapters can be obtained as dictionary with"
msgstr "然后，适配器本身会更详细地解析uri字符串。适配器的更新列表可以通过字典获得。"

#: ../../chapter-07.rst:4929
msgid ""
"For any adapter you can replace the driver with a different one globally "
"(not thread safe):"
msgstr "对于任何适配器，您都可以在全局范围内用不同的驱动程序替换已有的驱动程序（不是线程安全的）："

#: ../../chapter-07.rst:4938
msgid ""
"i.e. ``mysqldb`` has to be *that module* with a .connect() method. You "
"can specify optional driver arguments and adapter arguments:"
msgstr "即 ``mysqldb`` 必须是具有 ``.connect()`` 方法的模块。您可以指定可选的驱动程序参数和适配器参数："

#: ../../chapter-07.rst:4945
msgid ""
"For recognized adapters you can also simply specify the name in the "
"``adapter_args``:"
msgstr "对于已识别的适配器，您还可以在 ``adapter_args`` 中简单地指定名称："

#: ../../chapter-07.rst:4958
msgid ""
"SQLite does not support dropping and altering columns. That means that "
"py4web migrations will work up to a point. If you delete a field from a "
"table, the column will remain in the database but will be invisible to "
"py4web. If you decide to reinstate the column, py4web will try re-create "
"it and fail. In this case you must set ``fake_migrate=True`` so that "
"metadata is rebuilt without attempting to add the column again. Also, for"
" the same reason, SQLite is not aware of any change of column type. If "
"you insert a number in a string field, it will be stored as string. If "
"you later change the model and replace the type “string” with type "
"“integer”, SQLite will continue to keep the number as a string and this "
"may cause problem when you try to extract the data."
msgstr ""
"SQLite 不支持删除和更改列。这意味着 py4web 迁移在一定程度上是可行的。如果从表中删除字段，该列将保留在数据库中，但对 py4web "
"不可见。如果您决定恢复该列，py4web 将尝试重新创建它，但会失败。在这种情况下，您必须添加设置 ``fake_migrate=True`` "
"，以便在不尝试再次添加列的情况下重建元数据。同样，出于同样的原因，SQLite "
"不知道列的类型的任何变化。如果在字符串字段中插入一个数字，它将存储为字符串。如果稍后模型的类型 “string” 更改为类型 “integer” "
"，SQLite 将继续将数字保持为字符串不变，这可能会在您尝试提取数据时导致问题。"

#: ../../chapter-07.rst:4970
msgid ""
"SQLite doesn’t have a boolean type. py4web internally maps booleans to a "
"1 character string, with ‘T’ and ‘F’ representing True and False. The DAL"
" handles this completely; the abstraction of a true boolean value works "
"well. But if you are updating the SQLite table with SQL directly, be "
"aware of the py4web implementation, and avoid using 0 and 1 values."
msgstr ""
"SQLite 没有布尔类型。py4web 内部将布尔值映射为 1 个字符串，其中 'T' 和 'F' 分别表示 True 和 False。DAL "
"完全处理了这一点；真正布尔值的抽象效果很好。但是，如果您直接使用 SQL 更新 SQLite 表，请注意 py4web 实现，并避免使用 0 和 "
"1 值。"

#: ../../chapter-07.rst:4979
msgid ""
"MySQL does not support multiple ALTER TABLE within a single transaction. "
"This means that any migration process is broken into multiple commits. If"
" something happens that causes a failure it is possible to break a "
"migration (the py4web metadata are no longer in sync with the actual "
"table structure in the database). This is unfortunate but it can be "
"prevented (migrate one table at the time) or it can be fixed in the "
"aftermath (revert the py4web model to what corresponds to the table "
"structure in database, set ``fake_migrate=True`` and after the metadata "
"has been rebuilt, set ``fake_migrate=False`` and migrate the table "
"again)."
msgstr ""
"MySQL 不支持在单个事务中使用多个 ALTER "
"TABLE。这意味着任何迁移过程都被分解为多个提交。如果发生了导致失败的事情，则可能会中断迁移（py4web "
"元数据不再与数据库中的实际表结构同步）。这很不幸，但可以防止（一次迁移一个表），也可以在之后修复（将 py4web "
"模型还原为数据库中与表结构相对应的模型，设置 ``fake_migrate=True`` ，在重建元数据后，设置fake  "
"``fake_migrate=False`` 并再次迁移表）。"

#: ../../chapter-07.rst:4991
msgid "Google SQL"
msgstr ""

#: ../../chapter-07.rst:4993
msgid ""
"Google SQL has the same problems as MySQL and more. In particular table "
"metadata itself must be stored in the database in a table that is not "
"migrated by py4web. This is because Google App Engine has a read-only "
"file system. PY4WEB migrations in Google SQL combined with the MySQL "
"issue described above can result in metadata corruption. Again, this can "
"be prevented (by migrating the table at once and then setting "
"migrate=False so that the metadata table is not accessed any more) or it "
"can fixed in the aftermath (by accessing the database using the Google "
"dashboard and deleting any corrupted entry from the table called "
"``py4web_filesystem``."
msgstr ""
"Google SQL 与 MySQL 存在相同的问题，甚至更多。特别是，表元数据本身必须存储在数据库中一个不会被 py4web "
"迁移的表中。这是因为 Google App Engine 具有只读文件系统。Google SQL 中的 PY4WEB 迁移与上述 MySQL "
"问题相结合可能会导致元数据损坏。同样，可以防止这种情况（通过一次性迁移表，然后设置 "
"migrate=False，使元数据表不再被访问），也可以在之后修复（通过使用 Google dashboard 访问数据库，并从名为 "
"``py4web_filesystem`` 的表中删除任何损坏的条目）。"

#: ../../chapter-07.rst:5005
msgid "MSSQL (Microsoft SQL Server)"
msgstr ""

#: ../../chapter-07.rst:5007
msgid ""
"MSSQL < 2012 does not support the SQL OFFSET keyword. Therefore the "
"database cannot do pagination. When doing a ``limitby=(a, b)`` py4web "
"will fetch the first ``a + b`` rows and discard the first ``a``. This may"
" result in a considerable overhead when compared with other database "
"engines. If you’re using MSSQL >= 2005, the recommended prefix to use is "
"``mssql3://`` which provides a method to avoid the issue of fetching the "
"entire non-paginated resultset. If you’re on MSSQL >= 2012, use "
"``mssql4://`` that uses the ``OFFSET ... ROWS ... FETCH NEXT ... ROWS "
"ONLY`` construct to support natively pagination without performance hits "
"like other backends. The ``mssql://`` uri also enforces (for historical "
"reasons) the use of ``text`` columns, that are superseeded in more recent"
" versions (from 2005 onwards) by ``varchar(max)``. ``mssql3://`` and "
"``mssql4://`` should be used if you don’t want to face some limitations "
"of the - officially deprecated - ``text`` columns."
msgstr ""
"低于 MSSQL 2012 的版本不支持 SQL OFFSET 关键字。因此，数据库无法进行分页。当执行 ``limitby=(a, b)`` "
"时，py4web 将获取前 a+b 行并丢弃前 a 行。与其他数据库引擎相比，这可能会导致相当大的开销。如果您使用 MSSQL 2005 "
"及以上版本，建议使用的前缀是``mssql3://`` ，它提供了一种避免获取整个非分页结果集的方法。如果使用的是 MSSQL 2012 "
"及以上版本，请使用 mssql4://，它采用 ``OFFSET ... ROWS ... FETCH NEXT ... ROWS ONLY`` "
"结构，以原生方式支持分页，不会像其他后端那样产生性能损耗。  ``mssql://`` 还强制（出于历史原因）使用 ``text`` "
"列，在最近的版本（从 2005 年开始）中，文本列被 ``varchar(max)`` 取代。如果你不想面对正式弃用的 ``text`` "
"列的一些限制，应该使用 ``mssql3://`` 和 ``mssql4://`` 。"

#: ../../chapter-07.rst:5023
msgid ""
"MSSQL has problems with circular references in tables that have ONDELETE "
"CASCADE. This is an MSSQL bug and you work around it by setting the "
"ondelete attribute for all reference fields to “NO ACTION”. You can also "
"do it once and for all before you define tables:"
msgstr ""
"MSSQL 在使用具有 ONDELITE CASCADE 的表时会有循环引用的问题。这是 MSSQL 一个的漏洞，您可以通过将所有引用字段的 "
"ondelete 属性设置为 “NO ACTION” 来避免问题出现。您也可以在定义表之前一次性完成此操作："

#: ../../chapter-07.rst:5035
msgid ""
"MSSQL also has problems with arguments passed to the DISTINCT keyword and"
" therefore while this works,"
msgstr "MSSQL 在传递给 DISTINCT 关键字的参数方面也存在问题，因此，下面的可以"

#: ../../chapter-07.rst:5042
msgid "this does not"
msgstr "这就不行"

#: ../../chapter-07.rst:5051
msgid ""
"Oracle also does not support pagination. It does not support neither the "
"OFFSET nor the LIMIT keywords. PY4WEB achieves pagination by translating "
"a ``db(...).select(limitby=(a, b))`` into a complex three-way nested "
"select (as suggested by official Oracle documentation). This works for "
"simple select but may break for complex selects involving aliased fields "
"and or joins."
msgstr ""
"Oracle 也不支持分页。它既不支持 OFFSET 也不支持 LIMIT关 键字。PY4WEB 通过将 "
"``db(...).select(limitby=(a, b))`` 转换为复杂的三层嵌套的 select（如 Oracle "
"官方文档所建议）来实现分页。这适用于简单的查询，但对于涉及别名字段和/或连接的复杂的查询可能会中断。"

#: ../../chapter-07.rst:5059
msgid "Google NoSQL (Datastore)"
msgstr ""

#: ../../chapter-07.rst:5061
msgid ""
"Google NoSQL (Datastore) does not allow joins, left joins, aggregates, "
"expression, OR involving more than one table, the ‘like’ operator "
"searches in “text” fields."
msgstr ""
"Google NoSQL (Datastore) 不允许连接、左连接、聚合、表达式或涉及多个表的 OR，“like” 运算符在 “text” "
"字段中搜索。"

#: ../../chapter-07.rst:5065
msgid ""
"Transactions are limited and not provided automatically by py4web (you "
"need to use the Google API ``run_in_transaction`` which you can look up "
"in the Google App Engine documentation online)."
msgstr ""
"事务受到限制，py4web 不会自动提供（您需要使用 Google API ``run_in_transaction`` ，您可以在 Google"
" App Engine 的在线文档中查找）。"

#: ../../chapter-07.rst:5069
msgid ""
"Google also limits the number of records you can retrieve in each one "
"query (1000 at the time of writing). On the Google datastore record IDs "
"are integer but they are not sequential. While on SQL the “list:string” "
"type is mapped into a “text” type, on the Google Datastore it is mapped "
"into a ``ListStringProperty``. Similarly “list:integer” and "
"“list:reference” are mapped into ``ListProperty``. This makes searches "
"for content inside these fields types more efficient on Google NoSQL than"
" on SQL databases."
msgstr ""
"谷歌还限制了您在每个查询中可以检索的记录数量（在撰写本文时为 1000 条）。在 Google 数据存储中，记录 ID "
"是整数，但它们不是连续的。在 SQL 中， “list:string” 类型被映射为 “text” 类型，而 在Google Datastore "
"中，它被映射为  ``ListStringProperty``。类似地，“list:integer” 和 “list:reference” "
"被映射到 ``ListProperty`` 中。这使得在 Google NoSQL 上搜索这些字段类型中的内容比在 SQL 数据库上更高效。"

