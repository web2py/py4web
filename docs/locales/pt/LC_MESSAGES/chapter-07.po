# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, BSDv3 License
# This file is distributed under the same license as the py4web package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2020.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: py4web 1.20201112.1\n"
"Report-Msgid-Bugs-To: EMAIL@ADDRESS\n"
"POT-Creation-Date: 2020-11-29 10:41+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.8.0\n"

#: ../../chapter-07.rst:3
msgid "The database abstraction layer (DAL)"
msgstr ""

#: ../../chapter-07.rst:6
msgid "Dependencies"
msgstr ""

#: ../../chapter-07.rst:8
msgid ""
"py4web comes with a Database Abstraction Layer (DAL), an API that maps "
"Python objects into database objects such as queries, tables, and "
"records. The DAL dynamically generates the SQL in real time using the "
"specified dialect for the database back end, so that you do not have to "
"write SQL code or learn different SQL dialects (the term SQL is used "
"generically), and the application will be portable among different types "
"of databases. A partial list of supported databases is show in the table "
"below. Please check on the py4web web site and mailing list for more "
"recent adapters. Google NoSQL is treated as a particular case."
msgstr ""

#: ../../chapter-07.rst:18
msgid ""
"The Gotchas section at the end of this chapter has some more information "
"about specific databases."
msgstr ""

#: ../../chapter-07.rst:21
msgid ""
"The Windows binary distribution works out of the box with SQLite, MSSQL, "
"PostgreSQL and MySQL. The Mac binary distribution works out of the box "
"with SQLite. To use any other database back-end, run from the source "
"distribution and install the appropriate driver for the required back "
"end."
msgstr ""

#: ../../chapter-07.rst:27
msgid ""
"Once the proper driver is installed, start py4web from source, and it "
"will find the driver. Here is a list of the drivers py4web can use:"
msgstr ""

#: ../../chapter-07.rst:31
msgid "database"
msgstr ""

#: ../../chapter-07.rst:31
msgid "drivers (source)"
msgstr ""

#: ../../chapter-07.rst:33 ../../chapter-07.rst:4933
msgid "SQLite"
msgstr ""

#: ../../chapter-07.rst:33
msgid "sqlite3 or pysqlite2 or zxJDBC (on Jython)"
msgstr ""

#: ../../chapter-07.rst:34
msgid "PostgreSQL"
msgstr ""

#: ../../chapter-07.rst:34
msgid "psycopg2 or zxJDBC (on Jython)"
msgstr ""

#: ../../chapter-07.rst:35 ../../chapter-07.rst:4954
msgid "MySQL"
msgstr ""

#: ../../chapter-07.rst:35
msgid "pymysql or MySQLdb"
msgstr ""

#: ../../chapter-07.rst:36 ../../chapter-07.rst:5026
msgid "Oracle"
msgstr ""

#: ../../chapter-07.rst:36
msgid "cx_Oracle"
msgstr ""

#: ../../chapter-07.rst:37
msgid "MSSQL"
msgstr ""

#: ../../chapter-07.rst:37
msgid "pyodbc or pypyodbc"
msgstr ""

#: ../../chapter-07.rst:38
msgid "FireBird"
msgstr ""

#: ../../chapter-07.rst:38
msgid "kinterbasdb or fdb or pyodbc"
msgstr ""

#: ../../chapter-07.rst:39
msgid "DB2"
msgstr ""

#: ../../chapter-07.rst:39 ../../chapter-07.rst:44
msgid "pyodbc"
msgstr ""

#: ../../chapter-07.rst:40
msgid "Informix"
msgstr ""

#: ../../chapter-07.rst:40
msgid "informixdb"
msgstr ""

#: ../../chapter-07.rst:41
msgid "Ingres"
msgstr ""

#: ../../chapter-07.rst:41
msgid "ingresdbi"
msgstr ""

#: ../../chapter-07.rst:42
msgid "Cubrid"
msgstr ""

#: ../../chapter-07.rst:42
msgid "cubriddb"
msgstr ""

#: ../../chapter-07.rst:43
msgid "Sybase"
msgstr ""

#: ../../chapter-07.rst:44
msgid "Teradata"
msgstr ""

#: ../../chapter-07.rst:45
msgid "SAPDB"
msgstr ""

#: ../../chapter-07.rst:45
msgid "sapdb"
msgstr ""

#: ../../chapter-07.rst:46
msgid "MongoDB"
msgstr ""

#: ../../chapter-07.rst:46
msgid "pymongo"
msgstr ""

#: ../../chapter-07.rst:47
msgid "IMAP"
msgstr ""

#: ../../chapter-07.rst:47
msgid "imaplib"
msgstr ""

#: ../../chapter-07.rst:50
msgid ""
"``sqlite3``, ``pymysql``, and ``imaplib`` ship with py4web. Support of "
"MongoDB is experimental. The IMAP option allows to use DAL to access "
"IMAP."
msgstr ""

#: ../../chapter-07.rst:55
msgid "The DAL: A quick tour"
msgstr ""

#: ../../chapter-07.rst:57
msgid "py4web defines the following classes that make up the DAL:"
msgstr ""

#: ../../chapter-07.rst:59
msgid "The **DAL** object represents a database connection. For example:"
msgstr ""

#: ../../chapter-07.rst:65
msgid ""
"**Table** represents a database table. You do not directly instantiate "
"Table; instead, ``DAL.define_table`` instantiates it."
msgstr ""

#: ../../chapter-07.rst:72
msgid "The most important methods of a Table are:"
msgstr ""

#: ../../chapter-07.rst:74
msgid "``insert``, ``truncate``, ``drop``, and ``import_from_csv_file``."
msgstr ""

#: ../../chapter-07.rst:76
msgid ""
"**Field** represents a database field. It can be instantiated and passed "
"as an argument to ``DAL.define_table``."
msgstr ""

#: ../../chapter-07.rst:79
msgid ""
"**DAL Rows** is the object returned by a database select. It can be "
"thought of as a list of ``Row`` rows:"
msgstr ""

#: ../../chapter-07.rst:86
msgid "**Row** contains field values."
msgstr ""

#: ../../chapter-07.rst:93
msgid "**Query** is an object that represents a SQL “where” clause:"
msgstr ""

#: ../../chapter-07.rst:99
msgid ""
"**Set** is an object that represents a set of records. Its most important"
" methods are ``count``, ``select``, ``update``, and ``delete``. For "
"example:"
msgstr ""

#: ../../chapter-07.rst:110
msgid ""
"**Expression** is something like an ``orderby`` or ``groupby`` "
"expression. The Field class is derived from the Expression. Here is an "
"example."
msgstr ""

#: ../../chapter-07.rst:120
msgid "Using the DAL “stand-alone”"
msgstr ""

#: ../../chapter-07.rst:122
msgid "The DAL can be used in a non-py4web environment via"
msgstr ""

#: ../../chapter-07.rst:129
msgid "DAL constructor"
msgstr ""

#: ../../chapter-07.rst:131
msgid "Basic use:"
msgstr ""

#: ../../chapter-07.rst:137
msgid ""
"The database is now connected and the connection is stored in the global "
"variable ``db``."
msgstr ""

#: ../../chapter-07.rst:140
msgid "At any time you can retrieve the connection string."
msgstr ""

#: ../../chapter-07.rst:147
msgid "and the database name"
msgstr ""

#: ../../chapter-07.rst:154
msgid ""
"The connection string is called a ``_uri`` because it is an instance of a"
" Uniform Resource Identifier."
msgstr ""

#: ../../chapter-07.rst:157
msgid ""
"The DAL allows multiple connections with the same database or with "
"different databases, even databases of different types. For now, we will "
"assume the presence of a single database since this is the most common "
"situation."
msgstr ""

#: ../../chapter-07.rst:163
msgid "DAL signature"
msgstr ""

#: ../../chapter-07.rst:193
msgid "Connection strings (the uri parameter)"
msgstr ""

#: ../../chapter-07.rst:195
msgid ""
"A connection with the database is established by creating an instance of "
"the DAL object:"
msgstr ""

#: ../../chapter-07.rst:202
msgid ""
"``db`` is not a keyword; it is a local variable that stores the "
"connection object ``DAL``. You are free to give it a different name. The "
"constructor of ``DAL`` requires a single argument, the connection string."
" The connection string is the only py4web code that depends on a specific"
" back-end database. Here are examples of connection strings for specific "
"types of supported back-end databases (in all cases, we assume the "
"database is running from localhost on its default port and is named "
"“test”):"
msgstr ""

#: ../../chapter-07.rst:212
msgid "**SQLite**"
msgstr ""

#: ../../chapter-07.rst:212
msgid "``sqlite://storage.sqlite``"
msgstr ""

#: ../../chapter-07.rst:214 ../../chapter-07.rst:456
msgid "**MySQL**"
msgstr ""

#: ../../chapter-07.rst:214
msgid "``mysql://username:pa ssword@localhost/test?set_encoding=utf8mb4``"
msgstr ""

#: ../../chapter-07.rst:217 ../../chapter-07.rst:454
msgid "**PostgreSQL**"
msgstr ""

#: ../../chapter-07.rst:217
msgid "``p ostgres://username:password@localhost/test``"
msgstr ""

#: ../../chapter-07.rst:220
msgid "**MSSQL (legacy)**"
msgstr ""

#: ../../chapter-07.rst:220
msgid "``mssql://username:password@localhost/test``"
msgstr ""

#: ../../chapter-07.rst:222
msgid "**MSSQL (>=2005)**"
msgstr ""

#: ../../chapter-07.rst:222
msgid "` `mssql3://username:password@localhost/test``"
msgstr ""

#: ../../chapter-07.rst:225
msgid "**MSSQL (>=2012)**"
msgstr ""

#: ../../chapter-07.rst:225
msgid "` `mssql4://username:password@localhost/test``"
msgstr ""

#: ../../chapter-07.rst:228 ../../chapter-07.rst:457
msgid "**FireBird**"
msgstr ""

#: ../../chapter-07.rst:228
msgid "``f irebird://username:password@localhost/test``"
msgstr ""

#: ../../chapter-07.rst:231 ../../chapter-07.rst:459
msgid "**Oracle**"
msgstr ""

#: ../../chapter-07.rst:231
msgid "``oracle://username/password@test``"
msgstr ""

#: ../../chapter-07.rst:233
msgid "**DB2**"
msgstr ""

#: ../../chapter-07.rst:233
msgid "``db2://username:password@test``"
msgstr ""

#: ../../chapter-07.rst:235
msgid "**Ingres**"
msgstr ""

#: ../../chapter-07.rst:235
msgid "` `ingres://username:password@localhost/test``"
msgstr ""

#: ../../chapter-07.rst:238
msgid "**Sybase**"
msgstr ""

#: ../../chapter-07.rst:238
msgid "` `sybase://username:password@localhost/test``"
msgstr ""

#: ../../chapter-07.rst:241
msgid "**Informix**"
msgstr ""

#: ../../chapter-07.rst:241
msgid "``informix://username:password@test``"
msgstr ""

#: ../../chapter-07.rst:243
msgid "**Teradata**"
msgstr ""

#: ../../chapter-07.rst:243
msgid "``teradata ://DSN=dsn;UID=user;PWD=pass;DATABASE=test``"
msgstr ""

#: ../../chapter-07.rst:246
msgid "**Cubrid**"
msgstr ""

#: ../../chapter-07.rst:246
msgid "` `cubrid://username:password@localhost/test``"
msgstr ""

#: ../../chapter-07.rst:249
msgid "**SAPDB**"
msgstr ""

#: ../../chapter-07.rst:249
msgid "``sapdb://username:password@localhost/test``"
msgstr ""

#: ../../chapter-07.rst:251
msgid "**IMAP**"
msgstr ""

#: ../../chapter-07.rst:251
msgid "``imap://user:password@server:port``"
msgstr ""

#: ../../chapter-07.rst:253
msgid "**MongoDB**"
msgstr ""

#: ../../chapter-07.rst:253
msgid "`` mongodb://username:password@localhost/test``"
msgstr ""

#: ../../chapter-07.rst:256
msgid "**Google/SQL**"
msgstr ""

#: ../../chapter-07.rst:256
msgid "``google:sql://project:instance/database``"
msgstr ""

#: ../../chapter-07.rst:258
msgid "**Google/NoSQL**"
msgstr ""

#: ../../chapter-07.rst:258
msgid "``google:datastore``"
msgstr ""

#: ../../chapter-07.rst:260
msgid "**Google/NoSQL/NDB**"
msgstr ""

#: ../../chapter-07.rst:260
msgid "``google:datastore+ndb``"
msgstr ""

#: ../../chapter-07.rst:263
msgid ""
"Notice that in SQLite the database consists of a single file. If it does "
"not exist, it is created. This file is locked every time it is accessed. "
"In the case of MySQL, PostgreSQL, MSSQL, FireBird, Oracle, DB2, Ingres "
"and Informix the database “test” must be created outside py4web. Once the"
" connection is established, py4web will create, alter, and drop tables "
"appropriately."
msgstr ""

#: ../../chapter-07.rst:270
msgid ""
"In the MySQL connection string, the ``?set_encoding=utf8mb4`` at the end "
"sets the encoding to UTF-8 and avoids an ``Invalid utf8 character "
"string:`` error on Unicode characters that consist of four bytes, as by "
"default, MySQL can only handle Unicode characters that consist of one to "
"three bytes."
msgstr ""

#: ../../chapter-07.rst:276
msgid ""
"In the Google/NoSQL case the ``+ndb`` option turns on NDB. NDB uses a "
"Memcache buffer to read data that is accessed often. This is completely "
"automatic and done at the datastore level, not at the py4web level."
msgstr ""

#: ../../chapter-07.rst:280
msgid ""
"It is also possible to set the connection string to ``None``. In this "
"case DAL will not connect to any back-end database, but the API can still"
" be accessed for testing."
msgstr ""

#: ../../chapter-07.rst:284
msgid ""
"Some times you may need to generate SQL as if you had a connection but "
"without actually connecting to the database. This can be done with"
msgstr ""

#: ../../chapter-07.rst:291
msgid ""
"In this case you will be able to call ``_select``, ``_insert``, "
"``_update``, and ``_delete`` to generate SQL but not call ``select``, "
"``insert``, ``update``, and ``delete``. In most of the cases you can use "
"``do_connect=False`` even without having the required database drivers."
msgstr ""

#: ../../chapter-07.rst:296
msgid ""
"Notice that by default py4web uses utf8 character encoding for databases."
" If you work with existing databases that behave differently, you have to"
" change it with the optional parameter ``db_codec`` like"
msgstr ""

#: ../../chapter-07.rst:304
msgid "Otherwise you’ll get UnicodeDecodeError tickets."
msgstr ""

#: ../../chapter-07.rst:307
msgid "Connection pooling"
msgstr ""

#: ../../chapter-07.rst:309
msgid ""
"A common argument of the DAL constructor is the ``pool_size``; it "
"defaults to zero."
msgstr ""

#: ../../chapter-07.rst:312
msgid ""
"As it is rather slow to establish a new database connection for each "
"request, py4web implements a mechanism for connection pooling. Once a "
"connection is established and the page has been served and the "
"transaction completed, the connection is not closed but goes into a pool."
" When the next http request arrives, py4web tries to recycle a connection"
" from the pool and use that for the new transaction. If there are no "
"available connections in the pool, a new connection is established."
msgstr ""

#: ../../chapter-07.rst:321
msgid ""
"When py4web starts, the pool is always empty. The pool grows up to the "
"minimum between the value of ``pool_size`` and the max number of "
"concurrent requests. This means that if ``pool_size=10`` but our server "
"never receives more than 5 concurrent requests, then the actual pool size"
" will only grow to 5. If ``pool_size=0`` then connection pooling is not "
"used."
msgstr ""

#: ../../chapter-07.rst:328
msgid ""
"Connections in the pools are shared sequentially among threads, in the "
"sense that they may be used by two different but not simultaneous "
"threads. There is only one pool for each py4web process."
msgstr ""

#: ../../chapter-07.rst:332
msgid ""
"The ``pool_size`` parameter is ignored by SQLite and Google App Engine. "
"Connection pooling is ignored for SQLite, since it would not yield any "
"benefit."
msgstr ""

#: ../../chapter-07.rst:337
msgid "Connection failures (attempts parameter)"
msgstr ""

#: ../../chapter-07.rst:339
msgid ""
"If py4web fails to connect to the database it waits 1 second and by "
"default tries again up to 5 times before declaring a failure. In case of "
"connection pooling it is possible that a pooled connection that stays "
"open but unused for some time is closed by the database end. Thanks to "
"the retry feature py4web tries to re-establish these dropped connections."
" The number of attempts is set via the attempts parameter."
msgstr ""

#: ../../chapter-07.rst:347
msgid "Lazy Tables"
msgstr ""

#: ../../chapter-07.rst:349
msgid ""
"setting ``lazy_tables = True`` provides a major performance boost. See "
"below: `lazy tables <#lazy_tables>`__"
msgstr ""

#: ../../chapter-07.rst:353
msgid "Model-less applications"
msgstr ""

#: ../../chapter-07.rst:355
msgid ""
"Using py4web’s model directory for your application models is very "
"convenient and productive. With lazy tables and conditional models, "
"performance is usually acceptable even for large applications. Many "
"experienced developers use this in production environments."
msgstr ""

#: ../../chapter-07.rst:360
msgid ""
"However, it is possible to define DAL tables on demand inside controller "
"functions or modules. This may make sense when the number or complexity "
"of table definitions overloads the use of lazy tables and conditional "
"models."
msgstr ""

#: ../../chapter-07.rst:365
msgid ""
"This is referred to as “model-less” development by the py4web community. "
"It means less use of the automatic execution of Python files in the model"
" directory. It does not imply abandoning the concept of models, views and"
" controllers."
msgstr ""

#: ../../chapter-07.rst:370
msgid ""
"PY4WEB’s auto-execution of Python code inside the model directory does "
"this for you:"
msgstr ""

#: ../../chapter-07.rst:373
msgid "models are run automatically every time a request is processed"
msgstr ""

#: ../../chapter-07.rst:374
msgid "models access py4web’s global scope."
msgstr ""

#: ../../chapter-07.rst:376
msgid ""
"Models also make for useful interactive shell sessions when py4web is "
"started with the -M commandline option."
msgstr ""

#: ../../chapter-07.rst:379
msgid ""
"Also, remember maintainability: other py4web developers expect to find "
"model definitions in the model directory."
msgstr ""

#: ../../chapter-07.rst:382
msgid ""
"To use the “model-less” approach, you take responsibility for doing these"
" two housekeeping tasks. You call the table definitions when you need "
"them, and provide necessary access passed as parameter."
msgstr ""

#: ../../chapter-07.rst:386
msgid ""
"For example, a typical model-less application may leave the definitions "
"of the database connection objects in the model file, but define the "
"tables on demand per controller function."
msgstr ""

#: ../../chapter-07.rst:390
msgid ""
"The typical case is to move the table definitions to a module file (a "
"Python file saved in the modules directory)."
msgstr ""

#: ../../chapter-07.rst:393
msgid ""
"If the function to define a set of tables is called "
"``define_employee_tables()`` in a module called “table_setup.py”, your "
"controller that wants to refer to the tables related to employee records "
"in order to make an SQLFORM needs to call the "
"``define_employee_tables()`` function before accessing any tables. The "
"``define_employee_tables()`` function needs to access the database "
"connection object in order to define tables. You need to pass the db "
"object to the ``define_employee_tables()`` (as mentioned above)."
msgstr ""

#: ../../chapter-07.rst:403
msgid "Replicated databases"
msgstr ""

#: ../../chapter-07.rst:405
msgid ""
"The first argument of ``DAL(...)`` can be a list of URIs. In this case "
"py4web tries to connect to each of them. The main purpose for this is to "
"deal with multiple database servers and distribute the workload among "
"them). Here is a typical use case:"
msgstr ""

#: ../../chapter-07.rst:414
msgid ""
"In this case the DAL tries to connect to the first and, on failure, it "
"will try the second and the third. This can also be used to distribute "
"load in a database master-slave configuration."
msgstr ""

#: ../../chapter-07.rst:419
msgid "Reserved keywords"
msgstr ""

#: ../../chapter-07.rst:421
msgid ""
"``check_reserved`` tells the constructor to check table names and column "
"names against reserved SQL keywords in target back-end databases. "
"``check_reserved`` defaults to None."
msgstr ""

#: ../../chapter-07.rst:425
msgid ""
"This is a list of strings that contain the database back-end adapter "
"names."
msgstr ""

#: ../../chapter-07.rst:428
msgid ""
"The adapter name is the same as used in the DAL connection string. So if "
"you want to check against PostgreSQL and MSSQL then your connection "
"string would look as follows:"
msgstr ""

#: ../../chapter-07.rst:436
msgid "The DAL will scan the keywords in the same order as of the list."
msgstr ""

#: ../../chapter-07.rst:438
msgid ""
"There are two extra options “all” and “common”. If you specify all, it "
"will check against all known SQL keywords. If you specify common, it will"
" only check against common SQL keywords such as ``SELECT``, ``INSERT``, "
"``UPDATE``, etc."
msgstr ""

#: ../../chapter-07.rst:443
msgid ""
"For supported back-ends you may also specify if you would like to check "
"against the non-reserved SQL keywords as well. In this case you would "
"append ``_nonreserved`` to the name. For example:"
msgstr ""

#: ../../chapter-07.rst:451
msgid "The following database backends support reserved words checking."
msgstr ""

#: ../../chapter-07.rst:454
msgid "``postgres(_nonreserved)``"
msgstr ""

#: ../../chapter-07.rst:456
msgid "``mysql``"
msgstr ""

#: ../../chapter-07.rst:457
msgid "``firebird(_nonreserved)``"
msgstr ""

#: ../../chapter-07.rst:458
msgid "**MSSQL**"
msgstr ""

#: ../../chapter-07.rst:458
msgid "``mssql``"
msgstr ""

#: ../../chapter-07.rst:459
msgid "``oracle``"
msgstr ""

#: ../../chapter-07.rst:463
msgid "Database quoting and case settings"
msgstr ""

#: ../../chapter-07.rst:465
msgid "Quoting of SQL entities are enabled by default in DAL, that is:"
msgstr ""

#: ../../chapter-07.rst:467
msgid "``entity_quoting = True``"
msgstr ""

#: ../../chapter-07.rst:469
msgid ""
"This way identifiers are automatically quoted in SQL generated by DAL. At"
" SQL level keywords and unquoted identifiers are case insensitive, thus "
"quoting an SQL identifier makes it case sensitive."
msgstr ""

#: ../../chapter-07.rst:473
msgid ""
"Notice that unquoted identifiers should always be folded to lower case by"
" the back-end engine according to SQL standard but not all engines are "
"compliant with this (for example PostgreSQL default folding is upper "
"case)."
msgstr ""

#: ../../chapter-07.rst:478
msgid "By default DAL ignores field case too, to change this use:"
msgstr ""

#: ../../chapter-07.rst:480
msgid "``ignore_field_case = False``"
msgstr ""

#: ../../chapter-07.rst:482
msgid ""
"To be sure of using the same names in python and in the DB schema, you "
"must arrange for both settings above. Here is an example:"
msgstr ""

#: ../../chapter-07.rst:492
msgid "Making a secure connection"
msgstr ""

#: ../../chapter-07.rst:494
msgid ""
"Sometimes it is necessary (and advised) to connect to your database using"
" secure connection, especially if your database is not on the same server"
" as your application. In this case you need to pass additional parameters"
" to the database driver. You should refer to database driver "
"documentation for details."
msgstr ""

#: ../../chapter-07.rst:500
msgid "For PostgreSQL with psycopg2 it should look like this:"
msgstr ""

#: ../../chapter-07.rst:508
msgid ""
"where parameters ``sslrootcert``, ``sslcert`` and ``sslkey`` should "
"contain the full path to the files. You should refer to PostgreSQL "
"documentation on how to configure PostgreSQL server to accept secure "
"connections."
msgstr ""

#: ../../chapter-07.rst:514
msgid "Other DAL constructor parameters"
msgstr ""

#: ../../chapter-07.rst:517
msgid "Database folder location"
msgstr ""

#: ../../chapter-07.rst:519
msgid ""
"``folder`` sets the place where migration files will be created (see "
"`Migrations <#table_migrations>`__ section in this chapter for details). "
"It is also used for SQLite databases. Automatically set within py4web. "
"Set a path when using DAL outside py4web."
msgstr ""

#: ../../chapter-07.rst:525
msgid "Default migration settings"
msgstr ""

#: ../../chapter-07.rst:527
msgid ""
"The DAL constructor migration settings are booleans affecting defaults "
"and global behaviour."
msgstr ""

#: ../../chapter-07.rst:530
msgid "``migrate = True`` sets default migrate behavior for all tables"
msgstr ""

#: ../../chapter-07.rst:532
msgid "``fake_migrate = False`` sets default fake_migrate behavior for all tables"
msgstr ""

#: ../../chapter-07.rst:535
msgid "``migrate_enabled = True`` If set to False disables ALL migrations"
msgstr ""

#: ../../chapter-07.rst:537
msgid "``fake_migrate_all = False`` If set to True fake migrates ALL tables"
msgstr ""

#: ../../chapter-07.rst:540
msgid "Experiment with the py4web shell"
msgstr ""

#: ../../chapter-07.rst:542
msgid ""
"You can experiment with the DAL API using the py4web shell, that is "
"available using the ``shell`` command (read more in `Chapter 1 "
"<#chapter-01#command_line_options>`__)."
msgstr ""

#: ../../chapter-07.rst:546
msgid ""
"You need to choose an application to run the shell on, mind that database"
" changes may be persistent. So be carefull and do NOT exitate to create a"
" new application for doing testing instead of tampering with an existing "
"one."
msgstr ""

#: ../../chapter-07.rst:551
msgid ""
"Start by creating a connection. For the sake of example, you can use "
"SQLite. Nothing in this discussion changes when you change the back-end "
"engine."
msgstr ""

#: ../../chapter-07.rst:555
msgid ""
"Note that most of the code snippets that contain the python prompt "
"``>>>`` are directly executable via a plain shell, which you can obtain "
"using ``-PS`` command line options."
msgstr ""

#: ../../chapter-07.rst:560
msgid "Table constructor"
msgstr ""

#: ../../chapter-07.rst:562
msgid "Tables are defined in the DAL via ``define_table``."
msgstr ""

#: ../../chapter-07.rst:565
msgid "define_table signature"
msgstr ""

#: ../../chapter-07.rst:567
msgid "The signature for define_table method is:"
msgstr ""

#: ../../chapter-07.rst:573
msgid ""
"It accepts a mandatory table name and an optional number of ``Field`` "
"instances (even none). You can also pass a ``Table`` (or subclass) object"
" instead of a ``Field`` one, this clones and adds all the fields (but the"
" “id”) to the defining table. Other optional keyword args are: ``rname``,"
" ``redefine``, ``common_filter``, ``fake_migrate``, ``fields``, "
"``format``, ``migrate``, ``on_define``, ``plural``, ``polymodel``, "
"``primarykey``, ``sequence_name``, ``singular``, ``table_class``, and "
"``trigger_name``, which are discussed below."
msgstr ""

#: ../../chapter-07.rst:582 ../../chapter-07.rst:4757
msgid "For example:"
msgstr ""

#: ../../chapter-07.rst:589
msgid ""
"It defines, stores and returns a ``Table`` object called “person” "
"containing a field (column) “name”. This object can also be accessed via "
"``db.person``, so you do not need to catch the value returned by "
"define_table."
msgstr ""

#: ../../chapter-07.rst:595
msgid "``id``: Notes about the primary key"
msgstr ""

#: ../../chapter-07.rst:597
msgid ""
"Do not declare a field called “id”, because one is created by py4web "
"anyway. Every table has a field called “id” by default. It is an auto-"
"increment integer field (usually starting at 1) used for cross-reference "
"and for making every record unique, so “id” is a primary key. (Note: the "
"id counter starting at 1 is back-end specific. For example, this does not"
" apply to the Google App Engine NoSQL.)"
msgstr ""

#: ../../chapter-07.rst:604
msgid ""
"Optionally you can define a field of ``type='id'`` and py4web will use "
"this field as auto-increment id field. This is not recommended except "
"when accessing legacy database tables which have a primary key under a "
"different name. With some limitation, you can also use different primary "
"keys using the ``primarykey`` parameter."
msgstr ""

#: ../../chapter-07.rst:611
msgid "``plural`` and ``singular``"
msgstr ""

#: ../../chapter-07.rst:613
msgid ""
"As pydal is a general DAL, it includes plural and singular attributes to "
"refer to the table names so that external elements can use the proper "
"name for a table. A use case is in web2py with Smartgrid objects with "
"references to external tables."
msgstr ""

#: ../../chapter-07.rst:619
msgid "``redefine``"
msgstr ""

#: ../../chapter-07.rst:621
msgid ""
"Tables can be defined only once but you can force py4web to redefine an "
"existing table:"
msgstr ""

#: ../../chapter-07.rst:629
msgid "The redefinition may trigger a migration if table definition changes."
msgstr ""

#: ../../chapter-07.rst:632
msgid "``format``: Record representation"
msgstr ""

#: ../../chapter-07.rst:634
msgid ""
"It is optional but recommended to specify a format representation for "
"records with the ``format`` parameter."
msgstr ""

#: ../../chapter-07.rst:641
msgid "or"
msgstr ""

#: ../../chapter-07.rst:647
msgid "or even more complex ones using a function:"
msgstr ""

#: ../../chapter-07.rst:654
msgid ""
"The format attribute will be used for two purposes: - To represent "
"referenced records in select/option drop-downs. - To set the "
"``db.othertable.otherfield.represent`` attribute for all fields "
"referencing this table. This means that the ``Form`` constructor will not"
" show references by id but will use the preferred format representation "
"instead."
msgstr ""

#: ../../chapter-07.rst:662
msgid "``rname``: Real name"
msgstr ""

#: ../../chapter-07.rst:664
msgid ""
"``rname`` sets a database backend name for the table. This makes the "
"py4web table name an alias, and ``rname`` is the real name used when "
"constructing the query for the backend. To illustrate just one use, "
"``rname`` can be used to provide MSSQL fully qualified table names "
"accessing tables belonging to other databases on the server: ``rname = "
"'db1.dbo.table1'``:python"
msgstr ""

#: ../../chapter-07.rst:672
msgid "``primarykey``: Support for legacy tables"
msgstr ""

#: ../../chapter-07.rst:674
msgid ""
"``primarykey`` helps support legacy tables with existing primary keys, "
"even multi-part. See `Legacy databases and keyed tables "
"<#LegacyDatabases>`__ section in this chapter."
msgstr ""

#: ../../chapter-07.rst:679
msgid "``migrate``, ``fake_migrate``"
msgstr ""

#: ../../chapter-07.rst:681
msgid ""
"``migrate`` sets migration options for the table. Refer to `Migrations "
"<#table_migrations>`__ section in this chapter for details."
msgstr ""

#: ../../chapter-07.rst:685
msgid "``table_class``"
msgstr ""

#: ../../chapter-07.rst:687
msgid ""
"If you define your own Table class as a sub-class of pydal.objects.Table,"
" you can provide it here; this allows you to extend and override methods."
" Example:"
msgstr ""

#: ../../chapter-07.rst:701
msgid "``sequence_name``"
msgstr ""

#: ../../chapter-07.rst:703
msgid ""
"The name of a custom table sequence (if supported by the database). Can "
"create a SEQUENCE (starting at 1 and incrementing by 1) or use this for "
"legacy tables with custom sequences."
msgstr ""

#: ../../chapter-07.rst:707
msgid ""
"Note that when necessary, py4web will create sequences automatically by "
"default."
msgstr ""

#: ../../chapter-07.rst:711
msgid "``trigger_name``"
msgstr ""

#: ../../chapter-07.rst:713
msgid ""
"Relates to ``sequence_name``. Relevant for some backends which do not "
"support auto-increment numeric fields."
msgstr ""

#: ../../chapter-07.rst:717
msgid "``polymodel``"
msgstr ""

#: ../../chapter-07.rst:719
msgid "For Google App Engine"
msgstr ""

#: ../../chapter-07.rst:722
msgid "``on_define``"
msgstr ""

#: ../../chapter-07.rst:724
msgid ""
"``on_define`` is a callback triggered when a lazy_table is instantiated, "
"although it is called anyway if the table is not lazy. This allows "
"dynamic changes to the table without losing the advantages of delayed "
"instantiation."
msgstr ""

#: ../../chapter-07.rst:729
msgid "Example:"
msgstr ""

#: ../../chapter-07.rst:741
msgid ""
"Note this example shows how to use ``on_define`` but it is not actually "
"necessary. The simple ``requires`` values could be added to the Field "
"definitions and the table would still be lazy. However, ``requires`` "
"which take a Set object as the first argument, such as IS_IN_DB, will "
"make a query like ``db.sometable.somefield == some_value`` which would "
"cause ``sometable`` to be defined early. This is the situation saved by "
"``on_define``."
msgstr ""

#: ../../chapter-07.rst:750
msgid "Lazy Tables, a major performance boost"
msgstr ""

#: ../../chapter-07.rst:752
msgid ""
"py4web models are executed before controllers, so all tables are defined "
"at every request. Not all tables are needed to handle each request, so it"
" is possible that some of the time spent defining tables is wasted. "
"Conditional models (see `Model-less applications "
"<#model_less_applications>`__) can help, but py4web offers a big "
"performance boost via lazy_tables. This feature means that table creation"
" is deferred until the table is actually referenced. Enabling lazy tables"
" is made when initialising a database via the DAL constructor. It "
"requires setting the lazy_tables parameter: ``DAL(..., "
"lazy_tables=True)``:python This is one of the most significant response-"
"time performance boosts in py4web."
msgstr ""

#: ../../chapter-07.rst:765
msgid "Adding attributes to fields and tables"
msgstr ""

#: ../../chapter-07.rst:767
msgid ""
"If you need to add custom attributes to fields, you can simply do this: "
"``db.table.field.extra = {}``"
msgstr ""

#: ../../chapter-07.rst:770
msgid ""
"“extra” is not a keyword ; it’s a custom attributes now attached to the "
"field object. You can do it with tables too but they must be preceded by "
"an underscore to avoid naming conflicts with fields:"
msgstr ""

#: ../../chapter-07.rst:774
msgid "``db.table._extra = {}``:python"
msgstr ""

#: ../../chapter-07.rst:777
msgid "Field constructor"
msgstr ""

#: ../../chapter-07.rst:779
msgid "These are the default values of a Field constructor:"
msgstr ""

#: ../../chapter-07.rst:793
msgid ""
"where DEFAULT is a special value used to allow the value None for a "
"parameter."
msgstr ""

#: ../../chapter-07.rst:796
msgid ""
"Not all of them are relevant for every field. ``length`` is relevant only"
" for fields of type “string”. ``uploadfield``, ``authorize``, and "
"``autodelete`` are relevant only for fields of type “upload”. "
"``ondelete`` is relevant only for fields of type “reference” and "
"“upload”."
msgstr ""

#: ../../chapter-07.rst:802
msgid ""
"``length`` sets the maximum length of a “string”, “password” or “upload” "
"field. If ``length`` is not specified a default value is used but the "
"default value is not guaranteed to be backward compatible. *To avoid "
"unwanted migrations on upgrades, we recommend that you always specify the"
" length for string, password and upload fields.*"
msgstr ""

#: ../../chapter-07.rst:808
msgid ""
"``default`` sets the default value for the field. The default value is "
"used when performing an insert if a value is not explicitly specified. It"
" is also used to pre-populate forms built from the table using ``Form``. "
"Note, rather than being a fixed value, the default can instead be a "
"function (including a lambda function) that returns a value of the "
"appropriate type for the field. In that case, the function is called once"
" for each record inserted, even when multiple records are inserted in a "
"single transaction."
msgstr ""

#: ../../chapter-07.rst:816
msgid ""
"``required`` tells the DAL that no insert should be allowed on this table"
" if a value for this field is not explicitly specified."
msgstr ""

#: ../../chapter-07.rst:818
msgid ""
"``requires`` is a validator or a list of validators. This is not used by "
"the DAL, but it is used by ``Form``. The default validators for the given"
" types are shown in the next section."
msgstr ""

#: ../../chapter-07.rst:824
msgid ""
"Notice that while ``requires=...`` is enforced at the level of forms, "
"``required=True`` is enforced at the level of the DAL (insert). In "
"addition, ``notnull``, ``unique`` and ``ondelete`` are enforced at the "
"level of the database. While they sometimes may seem redundant, it is "
"important to maintain the distinction when programming with the DAL."
msgstr ""

#: ../../chapter-07.rst:831
msgid ""
"``rname`` provides the field with a “real name”, a name for the field "
"known to the database adapter; when the field is used, it is the rname "
"value which is sent to the database. The py4web name for the field is "
"then effectively an alias."
msgstr ""

#: ../../chapter-07.rst:836
msgid ""
"``ondelete`` translates into the “ON DELETE” SQL statement. By default it"
" is set to “CASCADE”. This tells the database that when it deletes a "
"record, it should also delete all records that refer to it. To disable "
"this feature, set ``ondelete`` to “NO ACTION” or “SET NULL”."
msgstr ""

#: ../../chapter-07.rst:842
msgid ""
"``notnull=True`` translates into the “NOT NULL” SQL statement. It "
"prevents the database from inserting null values for the field."
msgstr ""

#: ../../chapter-07.rst:845
msgid ""
"``unique=True`` translates into the “UNIQUE” SQL statement and it makes "
"sure that values of this field are unique within the table. It is "
"enforced at the database level."
msgstr ""

#: ../../chapter-07.rst:849
msgid ""
"``uploadfield`` applies only to fields of type “upload”. A field of type "
"“upload” stores the name of a file saved somewhere else, by default on "
"the filesystem under the application “uploads/” folder. If "
"``uploadfield`` is set to True, then the file is stored in a blob field "
"within the same table and the value of ``uploadfield`` is the name of the"
" blob field. This will be discussed in more detail later in the *More on "
"uploads* section in this chapter."
msgstr ""

#: ../../chapter-07.rst:857
msgid ""
"``uploadfolder`` sets the folder for uploaded files. By default, an "
"uploaded file goes into the application’s “uploads/” folder, that is into"
" ``os.path.join(request.folder, 'uploads')`` (this seems not the case for"
" MongoAdapter at present). For example: ``Field(..., "
"uploadfolder=os.path.join(request.folder, 'static/temp'))``:python will "
"upload files to the “py4web/applications/myapp/static/temp” folder."
msgstr ""

#: ../../chapter-07.rst:865
msgid ""
"``uploadseparate`` if set to True will upload files under different "
"subfolders of the *uploadfolder* folder. This is optimized to avoid too "
"many files under the same folder/subfolder. ATTENTION: You cannot change "
"the value of ``uploadseparate`` from True to False without breaking links"
" to existing uploads. py4web either uses the separate subfolders or it "
"does not. Changing the behavior after files have been uploaded will "
"prevent py4web from being able to retrieve those files. If this happens "
"it is possible to move files and fix the problem but this is not "
"described here."
msgstr ""

#: ../../chapter-07.rst:875
msgid ""
"``uploadfs`` allows you specify a different file system where to upload "
"files, including an Amazon S3 storage or a remote SFTP storage."
msgstr ""

#: ../../chapter-07.rst:881
msgid ""
"You need to have PyFileSystem installed for this to work. ``uploadfs`` "
"must point to PyFileSystem."
msgstr ""

#: ../../chapter-07.rst:884
msgid ""
"``autodelete`` determines if the corresponding uploaded file should be "
"deleted when the record referencing the file is deleted. For “upload” "
"fields only. However, records deleted by the database itself due to a "
"CASCADE operation will not trigger py4web’s autodelete. The py4web Google"
" group has workaround discussions."
msgstr ""

#: ../../chapter-07.rst:889
msgid ""
"``widget`` must be one of the available widget objects, including custom "
"widgets, for example: ``SQLFORM.widgets.string.widget``. A list of "
"available widgets will be discussed later. Each field type has a default "
"widget."
msgstr ""

#: ../../chapter-07.rst:893
msgid ""
"``label`` is a string (or a helper or something that can be serialized to"
" a string) that contains the label to be used for this field in auto-"
"generated forms."
msgstr ""

#: ../../chapter-07.rst:896
msgid ""
"``comment`` is a string (or a helper or something that can be serialized "
"to a string) that contains a comment associated with this field, and will"
" be displayed to the right of the input field in the autogenerated forms."
msgstr ""

#: ../../chapter-07.rst:900
msgid "``writable`` declares whether a field is writable in forms."
msgstr ""

#: ../../chapter-07.rst:901
msgid ""
"``readable`` declares whether a field is readable in forms. If a field is"
" neither readable nor writable, it will not be displayed in create and "
"update forms."
msgstr ""

#: ../../chapter-07.rst:904
msgid ""
"``searchable`` declares whether a field is searchable in grids "
"(``SQLFORM.grid`` and ``SQLFORM.smartgrid`` are described in *Chapter 7 "
"../07* ). Notice that a field must also be readable to be searched."
msgstr ""

#: ../../chapter-07.rst:907
msgid ""
"``listable`` declares whether a field is visible in grids (when listing "
"multiple records)"
msgstr ""

#: ../../chapter-07.rst:909
msgid ""
"``update`` contains the default value for this field when the record is "
"updated."
msgstr ""

#: ../../chapter-07.rst:911
msgid ""
"``compute`` is an optional function. If a record is inserted or updated, "
"the compute function will be executed and the field will be populated "
"with the function result. The record is passed to the compute function as"
" a ``dict``, and the dict will not include the current value of that, or "
"any other compute field."
msgstr ""

#: ../../chapter-07.rst:916
msgid ""
"``authorize`` can be used to require access control on the corresponding "
"field, for “upload” fields only. It will be discussed more in detail in "
"the context of Authentication and Authorization."
msgstr ""

#: ../../chapter-07.rst:919
msgid ""
"``represent`` can be None or can point to a function that takes a field "
"value and returns an alternate representation for the field value. "
"Examples:"
msgstr ""

#: ../../chapter-07.rst:929
msgid ""
"``filter_in`` and ``filter_out`` can be set to callables for further "
"processing of field’s value. ``filter_in`` is passed the field’s value to"
" be written to the database before an insert or update while "
"``filter_out`` is passed the value retrieved from the database before "
"field assignment. The value returned by the callable is then used. See "
"`filter_in and filter_out <#filter_in_filter_out>`__ section in this "
"chapter."
msgstr ""

#: ../../chapter-07.rst:936
msgid ""
"``custom_qualifier`` is a custom SQL qualifier for the field to be used "
"at table creation time (cannot use for field of type “id”, “reference”, "
"or “big-reference”)."
msgstr ""

#: ../../chapter-07.rst:941
msgid "Field types"
msgstr ""

#: ../../chapter-07.rst:944
msgid "**field type**"
msgstr ""

#: ../../chapter-07.rst:944
msgid "**default field validators**"
msgstr ""

#: ../../chapter-07.rst:946
msgid "``string``"
msgstr ""

#: ../../chapter-07.rst:946 ../../chapter-07.rst:970
msgid "``IS_LENGTH(length)`` default length is 512"
msgstr ""

#: ../../chapter-07.rst:949
msgid "``text``"
msgstr ""

#: ../../chapter-07.rst:949
msgid "``IS_LENGTH(length)`` default length is 32768"
msgstr ""

#: ../../chapter-07.rst:952
msgid "``blob``"
msgstr ""

#: ../../chapter-07.rst:952
msgid "``None`` default length is 2**31 (2 GiB)"
msgstr ""

#: ../../chapter-07.rst:955
msgid "``boolean``"
msgstr ""

#: ../../chapter-07.rst:955 ../../chapter-07.rst:977 ../../chapter-07.rst:979
#: ../../chapter-07.rst:989 ../../chapter-07.rst:991
msgid "``None``"
msgstr ""

#: ../../chapter-07.rst:957
msgid "``integer``"
msgstr ""

#: ../../chapter-07.rst:957
msgid "``IS_INT_IN_RANGE(-2**31, 2**31)``"
msgstr ""

#: ../../chapter-07.rst:959
msgid "``double``"
msgstr ""

#: ../../chapter-07.rst:959
msgid "``IS_FLOAT_IN_RANGE(-1e100, 1e100)``"
msgstr ""

#: ../../chapter-07.rst:961
msgid "``decimal(n,m)``"
msgstr ""

#: ../../chapter-07.rst:961
msgid "`` IS_DECIMAL_IN_RANGE(-10**10, 10**10)``"
msgstr ""

#: ../../chapter-07.rst:964
msgid "``date``"
msgstr ""

#: ../../chapter-07.rst:964
msgid "``IS_DATE()``"
msgstr ""

#: ../../chapter-07.rst:966
msgid "``time``"
msgstr ""

#: ../../chapter-07.rst:966
msgid "``IS_TIME()``"
msgstr ""

#: ../../chapter-07.rst:968
msgid "``datetime``"
msgstr ""

#: ../../chapter-07.rst:968
msgid "``IS_DATETIME()``"
msgstr ""

#: ../../chapter-07.rst:970
msgid "``password``"
msgstr ""

#: ../../chapter-07.rst:973
msgid "``upload``"
msgstr ""

#: ../../chapter-07.rst:973
msgid "``None`` default length is 512"
msgstr ""

#: ../../chapter-07.rst:975
msgid "``reference <table>``"
msgstr ""

#: ../../chapter-07.rst:975
msgid "``IS_IN_DB(db, table.field, format)``"
msgstr ""

#: ../../chapter-07.rst:977
msgid "``list:string``"
msgstr ""

#: ../../chapter-07.rst:979
msgid "``list:integer``"
msgstr ""

#: ../../chapter-07.rst:981
msgid "``list:reference <table>``"
msgstr ""

#: ../../chapter-07.rst:981
msgid "``IS_IN_DB(d b, table._id, format, multiple=True)``"
msgstr ""

#: ../../chapter-07.rst:984
msgid "``json``"
msgstr ""

#: ../../chapter-07.rst:984
msgid "``IS_EMPTY_OR(IS_JSON())`` default length is 512"
msgstr ""

#: ../../chapter-07.rst:987
msgid "``bigint``"
msgstr ""

#: ../../chapter-07.rst:987
msgid "``IS_INT_IN_RANGE(-2**63, 2**63)``"
msgstr ""

#: ../../chapter-07.rst:989
msgid "``big-id``"
msgstr ""

#: ../../chapter-07.rst:991
msgid "``big-reference``"
msgstr ""

#: ../../chapter-07.rst:994
msgid ""
"Decimal requires and returns values as ``Decimal`` objects, as defined in"
" the Python ``decimal`` module. SQLite does not handle the ``decimal`` "
"type so internally we treat it as a ``double``. The (n,m) are the number "
"of digits in total and the number of digits after the decimal point "
"respectively."
msgstr ""

#: ../../chapter-07.rst:1000
msgid ""
"The ``big-id`` and, ``big-reference`` are only supported by some of the "
"database engines and are experimental. They are not normally used as "
"field types unless for legacy tables, however, the DAL constructor has a "
"``bigint_id`` argument that when set to ``True`` makes the ``id`` fields "
"and ``reference`` fields ``big-id`` and ``big-reference`` respectively."
msgstr ""

#: ../../chapter-07.rst:1006
msgid ""
"The ``list:<type>`` fields are special because they are designed to take "
"advantage of certain denormalization features on NoSQL (in the case of "
"Google App Engine NoSQL, the field types ``ListProperty`` and "
"``StringListProperty``) and back-port them all the other supported "
"relational databases. On relational databases lists are stored as a "
"``text`` field. The items are separated by a ``|`` and each ``|`` in "
"string item is escaped as a ``||``. They are discussed in *list: and "
"contains* section in this chapter."
msgstr ""

#: ../../chapter-07.rst:1015
msgid ""
"The ``json`` field type is pretty much explanatory. It can store any json"
" serializable object. It is designed to work specifically for MongoDB and"
" backported to the other database adapters for portability."
msgstr ""

#: ../../chapter-07.rst:1019
msgid ""
"``blob`` fields are also special. By default, binary data is encoded in "
"base64 before being stored into the actual database field, and it is "
"decoded when extracted. This has the negative effect of using 33% more "
"storage space than necessary in blob fields, but has the advantageof "
"making the communication independent of back-end-specific escaping "
"conventions."
msgstr ""

#: ../../chapter-07.rst:1027
msgid "Run-time field and table modification"
msgstr ""

#: ../../chapter-07.rst:1029
msgid ""
"Most attributes of fields and tables can be modified after they are "
"defined:"
msgstr ""

#: ../../chapter-07.rst:1039
msgid ""
"notice that attributes of tables are usually prefixed by an underscore to"
" avoid conflict with possible field names."
msgstr ""

#: ../../chapter-07.rst:1042
msgid ""
"You can list the tables that have been defined for a given database "
"connection:"
msgstr ""

#: ../../chapter-07.rst:1050
msgid "You can query for the type of a table:"
msgstr ""

#: ../../chapter-07.rst:1057
msgid "You can access a table using different syntaxes:"
msgstr ""

#: ../../chapter-07.rst:1064
msgid "You can also list the fields that have been defined for a given table:"
msgstr ""

#: ../../chapter-07.rst:1071
msgid ""
"Similarly you can access fields from their name in multiple equivalent "
"ways:"
msgstr ""

#: ../../chapter-07.rst:1081
msgid "Given a field, you can access the attributes set in its definition:"
msgstr ""

#: ../../chapter-07.rst:1094
msgid "including its parent table, tablename, and parent connection:"
msgstr ""

#: ../../chapter-07.rst:1105
msgid ""
"A field also has methods. Some of them are used to build queries and we "
"will see them later. A special method of the field object is ``validate``"
" and it calls the validators for the field."
msgstr ""

#: ../../chapter-07.rst:1114
msgid ""
"which returns a tuple ``(value, error)``. ``error`` is ``None`` if the "
"input passes validation."
msgstr ""

#: ../../chapter-07.rst:1118
msgid "Migrations"
msgstr ""

#: ../../chapter-07.rst:1120
msgid ""
"``define_table`` checks whether or not the corresponding table exists. If"
" it does not, it generates the SQL to create it and executes the SQL. If "
"the table does exist but differs from the one being defined, it generates"
" the SQL to alter the table and executes it. If a field has changed type "
"but not name, it will try to convert the data (If you do not want this, "
"you need to redefine the table twice, the first time, letting py4web drop"
" the field by removing it, and the second time adding the newly defined "
"field so that py4web can create it.). If the table exists and matches the"
" current definition, it will leave it alone. In all cases it will create "
"the ``db.person`` object that represents the table."
msgstr ""

#: ../../chapter-07.rst:1132
msgid ""
"We refer to this behavior as a “migration”. py4web logs all migrations "
"and migration attempts in the file “sql.log”."
msgstr ""

#: ../../chapter-07.rst:1135
msgid ""
"Notice that by default py4web uses the “app/databases” folder for the log"
" file and all other migration files it needs. You can change this setting"
" the ``folder`` argument to DAL. To set a different log file name, for "
"example “migrate.log” you can do ``db = DAL(..., "
"adapter_args=dict(logfile='migrate.log'))``:python"
msgstr ""

#: ../../chapter-07.rst:1141
msgid ""
"The first argument of ``define_table`` is always the table name. The "
"other unnamed arguments are the fields (Field). The function also takes "
"an optional keyword argument called “migrate”:"
msgstr ""

#: ../../chapter-07.rst:1149
msgid ""
"The value of migrate is the filename where py4web stores internal "
"migration information for this table. These files are very important and "
"should never be removed while the corresponding tables exist. In cases "
"where a table has been dropped and the corresponding file still exist, it"
" can be removed manually. By default, migrate is set to True. This causes"
" py4web to generate the filename from a hash of the connection string. If"
" migrate is set to False, the migration is not performed, and py4web "
"assumes that the table exists in the datastore and it contains (at least)"
" the fields listed in ``define_table``."
msgstr ""

#: ../../chapter-07.rst:1159
msgid ""
"There may not be two tables in the same application with the same migrate"
" filename."
msgstr ""

#: ../../chapter-07.rst:1162
msgid ""
"The DAL class also takes a “migrate” argument, which determines the "
"default value of migrate for calls to ``define_table``. For example,"
msgstr ""

#: ../../chapter-07.rst:1169
msgid ""
"will set the default value of migrate to False whenever "
"``db.define_table`` is called without a migrate argument."
msgstr ""

#: ../../chapter-07.rst:1172
msgid ""
"Notice that py4web only migrates new columns, removed columns, and "
"changes in column type (except in SQLite). py4web does not migrate "
"changes in attributes such as changes in the values of ``default``, "
"``unique``, ``notnull``, and ``ondelete``."
msgstr ""

#: ../../chapter-07.rst:1177
msgid "Migrations can be disabled for all tables at once:"
msgstr ""

#: ../../chapter-07.rst:1183
msgid ""
"This is the recommended behavior when two apps share the same database. "
"Only one of the two apps should perform migrations, the other should "
"disabled them."
msgstr ""

#: ../../chapter-07.rst:1188
msgid "Fixing broken migrations"
msgstr ""

#: ../../chapter-07.rst:1190
msgid ""
"There are two common problems with migrations and there are ways to "
"recover from them."
msgstr ""

#: ../../chapter-07.rst:1193
msgid ""
"One problem is specific with SQLite. SQLite does not enforce column types"
" and cannot drop columns. This means that if you have a column of type "
"string and you remove it, it is not really removed. If you add the column"
" again with a different type (for example datetime) you end up with a "
"datetime column that contains strings (junk for practical purposes). "
"py4web does not complain about this because it does not know what is in "
"the database, until it tries to retrieve records and fails."
msgstr ""

#: ../../chapter-07.rst:1201
msgid ""
"If py4web returns an error in some parse function when selecting records,"
" most likely this is due to corrupted data in a column because of the "
"above issue."
msgstr ""

#: ../../chapter-07.rst:1205
msgid ""
"The solution consists in updating all records of the table and updating "
"the values in the column in question with None."
msgstr ""

#: ../../chapter-07.rst:1208
msgid ""
"The other problem is more generic but typical with MySQL. MySQL does not "
"allow more than one ALTER TABLE in a transaction. This means that py4web "
"must break complex transactions into smaller ones (one ALTER TABLE at the"
" time) and commit one piece at the time. It is therefore possible that "
"part of a complex transaction gets committed and one part fails, leaving "
"py4web in a corrupted state. Why would part of a transaction fail? "
"Because, for example, it involves altering a table and converting a "
"string column into a datetime column, py4web tries to convert the data, "
"but the data cannot be converted. What happens to py4web? It gets "
"confused about what exactly is the table structure actually stored in the"
" database."
msgstr ""

#: ../../chapter-07.rst:1220
msgid "The solution consists of enabling fake migrations:"
msgstr ""

#: ../../chapter-07.rst:1226
msgid ""
"This will rebuild py4web metadata about the table according to the table "
"definition. Try multiple table definitions to see which one works (the "
"one before the failed migration and the one after the failed migration). "
"Once successful remove the ``fake_migrate=True`` parameter."
msgstr ""

#: ../../chapter-07.rst:1231
msgid ""
"Before attempting to fix migration problems it is prudent to make a copy "
"of \"applications/yourapp/databases/\\*.table\" files."
msgstr ""

#: ../../chapter-07.rst:1234
msgid "Migration problems can also be fixed for all tables at once:"
msgstr ""

#: ../../chapter-07.rst:1240
msgid ""
"This also fails if the model describes tables that do not exist in the "
"database, but it can help narrowing down the problem."
msgstr ""

#: ../../chapter-07.rst:1244
msgid "Migration control summary"
msgstr ""

#: ../../chapter-07.rst:1246
msgid ""
"The logic of the various migration arguments are summarized in this "
"pseudo-code:"
msgstr ""

#: ../../chapter-07.rst:1258
msgid "``insert``"
msgstr ""

#: ../../chapter-07.rst:1260
msgid "Given a table, you can insert records"
msgstr ""

#: ../../chapter-07.rst:1269
msgid "Insert returns the unique “id” value of each record inserted."
msgstr ""

#: ../../chapter-07.rst:1271
msgid ""
"You can truncate the table, i.e., delete all records and reset the "
"counter of the id."
msgstr ""

#: ../../chapter-07.rst:1278
msgid ""
"Now, if you insert a record again, the counter starts again at 1 (this is"
" back-end specific and does not apply to Google NoSQL):"
msgstr ""

#: ../../chapter-07.rst:1286
msgid ""
"Notice you can pass a parameter to ``truncate``, for example you can tell"
" SQLite to restart the id counter."
msgstr ""

#: ../../chapter-07.rst:1293
msgid "The argument is in raw SQL and therefore engine specific."
msgstr ""

#: ../../chapter-07.rst:1295
msgid "py4web also provides a bulk_insert method"
msgstr ""

#: ../../chapter-07.rst:1302
msgid ""
"It takes a list of dictionaries of fields to be inserted and performs "
"multiple inserts at once. It returns the list of “id” values of the "
"inserted records. On the supported relational databases there is no "
"advantage in using this function as opposed to looping and performing "
"individual inserts but on Google App Engine NoSQL, there is a major speed"
" advantage."
msgstr ""

#: ../../chapter-07.rst:1310
msgid "``commit`` and ``rollback``"
msgstr ""

#: ../../chapter-07.rst:1312
msgid ""
"The insert, truncate, delete, and update operations aren’t actually "
"committed until py4web issues the commit command. The create and drop "
"operations may be executed immediately, depending on the database engine."
" Calls to py4web actions are automatically wrapped in transactions. If "
"you executed commands via the shell, you are required to manually commit:"
msgstr ""

#: ../../chapter-07.rst:1323
msgid "To check it let’s insert a new record:"
msgstr ""

#: ../../chapter-07.rst:1330
msgid "and roll back, i.e., ignore all operations since the last commit:"
msgstr ""

#: ../../chapter-07.rst:1336
msgid ""
"If you now insert again, the counter will again be set to 2, since the "
"previous insert was rolled back."
msgstr ""

#: ../../chapter-07.rst:1344
msgid ""
"Code in models, views and controllers is enclosed in py4web code that "
"looks like this (pseudo code) :"
msgstr ""

#: ../../chapter-07.rst:1359
msgid ""
"So in models, views and controllers there is no need to ever call "
"``commit`` or ``rollback`` explicitly in py4web unless you need more "
"granular control. However, in modules you will need to use ``commit()``."
msgstr ""

#: ../../chapter-07.rst:1364
msgid "Raw SQL"
msgstr ""

#: ../../chapter-07.rst:1367
msgid "Timing queries"
msgstr ""

#: ../../chapter-07.rst:1369
msgid ""
"All queries are automatically timed by py4web. The variable "
"``db._timings`` is a list of tuples. Each tuple contains the raw SQL "
"query as passed to the database driver and the time it took to execute in"
" seconds. This variable can be displayed in views using the toolbar:"
msgstr ""

#: ../../chapter-07.rst:1379
msgid "``executesql``"
msgstr ""

#: ../../chapter-07.rst:1381
msgid "The DAL allows you to explicitly issue SQL statements."
msgstr ""

#: ../../chapter-07.rst:1388
msgid ""
"In this case, the return values are not parsed or transformed by the DAL,"
" and the format depends on the specific database driver. This usage with "
"selects is normally not needed, but it is more common with indexes."
msgstr ""

#: ../../chapter-07.rst:1392
msgid ""
"``executesql`` takes five optional arguments: ``placeholders``, "
"``as_dict``, ``fields``, ``colnames``, and ``as_ordered_dict``."
msgstr ""

#: ../../chapter-07.rst:1395
msgid ""
"``placeholders`` is an optional sequence of values to be substituted in "
"or, if supported by the DB driver, a dictionary with keys matching named "
"placeholders in your SQL."
msgstr ""

#: ../../chapter-07.rst:1399
msgid ""
"If ``as_dict`` is set to True, the results cursor returned by the DB "
"driver will be converted to a sequence of dictionaries keyed with the db "
"field names. Results returned with ``as_dict = True`` are the same as "
"those returned when applying **.as_list()** to a normal select:"
msgstr ""

#: ../../chapter-07.rst:1408
msgid ""
"``as_ordered_dict`` is pretty much like ``as_dict`` but the former "
"ensures that the order of resulting fields (OrderedDict keys) reflect the"
" order on which they are returned from DB driver:"
msgstr ""

#: ../../chapter-07.rst:1417
msgid ""
"The ``fields`` argument is a list of DAL Field objects that match the "
"fields returned from the DB. The Field objects should be part of one or "
"more Table objects defined on the DAL object. The ``fields`` list can "
"include one or more DAL Table objects in addition to or instead of "
"including Field objects, or it can be just a single table (not in a "
"list). In that case, the Field objects will be extracted from the "
"table(s)."
msgstr ""

#: ../../chapter-07.rst:1425
msgid ""
"Instead of specifying the ``fields`` argument, the ``colnames`` argument "
"can be specified as a list of field names in tablename.fieldname format. "
"Again, these should represent tables and fields defined on the DAL "
"object."
msgstr ""

#: ../../chapter-07.rst:1430
msgid ""
"It is also possible to specify both ``fields`` and the associated "
"``colnames``. In that case, ``fields`` can also include DAL Expression "
"objects in addition to Field objects. For Field objects in “fields”, the "
"associated ``colnames`` must still be in tablename.fieldname format. For "
"Expression objects in ``fields``, the associated ``colnames`` can be any "
"arbitrary labels."
msgstr ""

#: ../../chapter-07.rst:1437
msgid ""
"Notice, the DAL Table objects referred to by ``fields`` or ``colnames`` "
"can be dummy tables and do not have to represent any real tables in the "
"database. Also, note that the ``fields`` and ``colnames`` must be in the "
"same order as the fields in the results cursor returned from the DB."
msgstr ""

#: ../../chapter-07.rst:1443
msgid "``_lastsql``"
msgstr ""

#: ../../chapter-07.rst:1445
msgid ""
"Whether SQL was executed manually using executesql or was SQL generated "
"by the DAL, you can always find the SQL code in ``db._lastsql``. This is "
"useful for debugging purposes:"
msgstr ""

#: ../../chapter-07.rst:1457
msgid ""
"py4web never generates queries using the \"*\" operator. py4web is always"
" explicit when selecting fields."
msgstr ""

#: ../../chapter-07.rst:1461
msgid "``drop``"
msgstr ""

#: ../../chapter-07.rst:1463
msgid "Finally, you can drop tables and all data will be lost:"
msgstr ""

#: ../../chapter-07.rst:1470
msgid "Indexes"
msgstr ""

#: ../../chapter-07.rst:1472
msgid ""
"Currently the DAL API does not provide a command to create indexes on "
"tables, but this can be done using the ``executesql`` command. This is "
"because the existence of indexes can make migrations complex, and it is "
"better to deal with them explicitly. Indexes may be needed for those "
"fields that are used in recurrent queries."
msgstr ""

#: ../../chapter-07.rst:1478
msgid "Here is an example of how to:"
msgstr ""

#: ../../chapter-07.rst:1486
msgid ""
"Other database dialects have very similar syntaxes but may not support "
"the optional “IF NOT EXISTS” directive."
msgstr ""

#: ../../chapter-07.rst:1490
msgid "Legacy databases and keyed tables"
msgstr ""

#: ../../chapter-07.rst:1492
msgid "py4web can connect to legacy databases under some conditions."
msgstr ""

#: ../../chapter-07.rst:1494
msgid ""
"The easiest way is when these conditions are met: - Each table must have "
"a unique auto-increment integer field called “id” - Records must be "
"referenced exclusively using the “id” field."
msgstr ""

#: ../../chapter-07.rst:1498
msgid ""
"When accessing an existing table, i.e., a table not created by py4web in "
"the current application, always set ``migrate=False``."
msgstr ""

#: ../../chapter-07.rst:1501
msgid ""
"If the legacy table has an auto-increment integer field but it is not "
"called “id”, py4web can still access it but the table definition must "
"declare the auto-increment field with ‘id’ type (that is using "
"``FIeld('...', 'id')``)."
msgstr ""

#: ../../chapter-07.rst:1506
msgid ""
"Finally if the legacy table uses a primary key that is not an auto-"
"increment id field it is possible to use a “keyed table”, for example:"
msgstr ""

#: ../../chapter-07.rst:1519
msgid "``primarykey`` is a list of the field names that make up the primary key."
msgstr ""

#: ../../chapter-07.rst:1521
msgid "All primarykey fields have a ``NOT NULL`` set even if not specified."
msgstr ""

#: ../../chapter-07.rst:1522
msgid "Keyed tables can only reference other keyed tables."
msgstr ""

#: ../../chapter-07.rst:1523
msgid "Referencing fields must use the ``reference tablename.fieldname`` format."
msgstr ""

#: ../../chapter-07.rst:1525
msgid "The ``update_record`` function is not available for Rows of keyed tables."
msgstr ""

#: ../../chapter-07.rst:1530
msgid ""
"Currently keyed tables are only supported for DB2, MSSQL, Ingres and "
"Informix, but others engines will be added."
msgstr ""

#: ../../chapter-07.rst:1533
msgid ""
"At the time of writing, we cannot guarantee that the ``primarykey`` "
"attribute works with every existing legacy table and every supported "
"database backend. For simplicity, we recommend, if possible, creating a "
"database view that has an auto-increment id field."
msgstr ""

#: ../../chapter-07.rst:1539
msgid "Distributed transaction"
msgstr ""

#: ../../chapter-07.rst:1541
msgid ""
"At the time of writing this feature is only supported by PostgreSQL, "
"MySQL and Firebird, since they expose API for two-phase commits."
msgstr ""

#: ../../chapter-07.rst:1544
msgid ""
"Assuming you have two (or more) connections to distinct PostgreSQL "
"databases, for example:"
msgstr ""

#: ../../chapter-07.rst:1552
msgid "In your models or controllers, you can commit them concurrently with:"
msgstr ""

#: ../../chapter-07.rst:1558
msgid "On failure, this function rolls back and raises an ``Exception``."
msgstr ""

#: ../../chapter-07.rst:1560
msgid ""
"In controllers, when one action returns, if you have two distinct "
"connections and you do not call the above function, py4web commits them "
"separately. This means there is a possibility that one of the commits "
"succeeds and one fails. The distributed transaction prevents this from "
"happening."
msgstr ""

#: ../../chapter-07.rst:1567
msgid "More on uploads"
msgstr ""

#: ../../chapter-07.rst:1569
msgid "Consider the following model:"
msgstr ""

#: ../../chapter-07.rst:1576
msgid ""
"In the case of an “upload” field, the default value can optionally be set"
" to a path (an absolute path or a path relative to the current app "
"folder), the default value is then assigned to each new record that does "
"not specify an image."
msgstr ""

#: ../../chapter-07.rst:1581
msgid ""
"Notice that this way multiple records may end to reference the same "
"default image file and this could be a problem on a Field having "
"``autodelete`` enabled. When you do not want to allow duplicates for the "
"image field (i.e. multiple records referencing the same file) but still "
"want to set a default value for the “upload” then you need a way to copy "
"the default file for each new record that does not specify an image. This"
" can be obtained using a file-like object referencing the default file as"
" the ``default`` argument to Field, or even with:"
msgstr ""

#: ../../chapter-07.rst:1594
msgid ""
"Normally an insert is handled automatically via a ``Form`` but "
"occasionally you already have the file on the filesystem and want to "
"upload it programmatically. This can be done in this way:"
msgstr ""

#: ../../chapter-07.rst:1603
msgid ""
"It is also possible to insert a file in a simpler way and have the insert"
" method call ``store`` automatically:"
msgstr ""

#: ../../chapter-07.rst:1611
msgid "In this case the filename is obtained from the stream object if available."
msgstr ""

#: ../../chapter-07.rst:1614
msgid ""
"The ``store`` method of the upload field object takes a file stream and a"
" filename. It uses the filename to determine the extension (type) of the "
"file, creates a new temp name for the file (according to py4web upload "
"mechanism) and loads the file content in this new temp file (under the "
"uploads folder unless specified otherwise). It returns the new temp name,"
" which is then stored in the ``image`` field of the ``db.myfile`` table."
msgstr ""

#: ../../chapter-07.rst:1622
msgid ""
"Note, if the file is to be stored in an associated blob field rather than"
" the file system, the ``store`` method will not insert the file in the "
"blob field (because ``store`` is called before the insert), so the file "
"must be explicitly inserted into the blob field:"
msgstr ""

#: ../../chapter-07.rst:1636
msgid "The ``retrieve`` method does the opposite of ``store``."
msgstr ""

#: ../../chapter-07.rst:1638
msgid ""
"When uploaded files are stored on filesystem (as in the case of a plain "
"``Field('image', 'upload')``) the code:"
msgstr ""

#: ../../chapter-07.rst:1646
msgid ""
"retrieves the original file name (filename) as seen by the user at upload"
" time and the name of stored file (fullname, with path relative to "
"application folder). While in general the call:"
msgstr ""

#: ../../chapter-07.rst:1654
msgid ""
"retrieves the original file name (filename) and a file-like object ready "
"to access uploaded file data (stream)."
msgstr ""

#: ../../chapter-07.rst:1657
msgid ""
"Notice that the stream returned by ``retrieve`` is a real file object in "
"the case that uploaded files are stored on filesystem. In that case "
"remember to close the file when you are done, calling ``stream.close()``."
msgstr ""

#: ../../chapter-07.rst:1662
msgid "Here is an example of safe usage of ``retrieve``:"
msgstr ""

#: ../../chapter-07.rst:1674
msgid "``Query``, ``Set``, ``Rows``"
msgstr ""

#: ../../chapter-07.rst:1676
msgid ""
"Let’s consider again the table defined (and dropped) previously and "
"insert three records:"
msgstr ""

#: ../../chapter-07.rst:1690
msgid ""
"You can store the table in a variable. For example, with variable "
"``person``, you could do:"
msgstr ""

#: ../../chapter-07.rst:1697
msgid ""
"You can also store a field in a variable such as ``name``. For example, "
"you could also do:"
msgstr ""

#: ../../chapter-07.rst:1704
msgid ""
"You can even build a query (using operators like ==, !=, <, >, <=, >=, "
"like, belongs) and store the query in a variable ``q`` such as in:"
msgstr ""

#: ../../chapter-07.rst:1711
msgid ""
"When you call ``db`` with a query, you define a set of records. You can "
"store it in a variable ``s`` and write:"
msgstr ""

#: ../../chapter-07.rst:1718
msgid ""
"Notice that no database query has been performed so far. DAL + Query "
"simply define a set of records in this db that match the query. py4web "
"determines from the query which table (or tables) are involved and, in "
"fact, there is no need to specify that."
msgstr ""

#: ../../chapter-07.rst:1724
msgid "``select`` command"
msgstr ""

#: ../../chapter-07.rst:1726
msgid "Given a Set, ``s``, you can fetch the records with the command ``select``:"
msgstr ""

#: ../../chapter-07.rst:1733
msgid ""
"It returns an iterable object of class ``pydal.objects.Rows`` whose "
"elements are Row objects. ``pydal.objects.Row`` objects act like "
"dictionaries, but their elements can also be accessed as attributes, like"
" ``gluon.storage.Storage``.The former differ from the latter because its "
"values are read-only."
msgstr ""

#: ../../chapter-07.rst:1739
msgid ""
"The Rows object allows looping over the result of the select and printing"
" the selected field values for each row:"
msgstr ""

#: ../../chapter-07.rst:1749
msgid "You can do all the steps in one statement:"
msgstr ""

#: ../../chapter-07.rst:1758
msgid ""
"The select command can take arguments. All unnamed arguments are "
"interpreted as the names of the fields that you want to fetch. For "
"example, you can be explicit on fetching field “id” and field “name”:"
msgstr ""

#: ../../chapter-07.rst:1771
msgid "The table attribute ALL allows you to specify all fields:"
msgstr ""

#: ../../chapter-07.rst:1782
msgid ""
"Notice that there is no query string passed to db. py4web understands "
"that if you want all fields of the table person without additional "
"information then you want all records of the table person."
msgstr ""

#: ../../chapter-07.rst:1786
msgid "An equivalent alternative syntax is the following:"
msgstr ""

#: ../../chapter-07.rst:1797
msgid ""
"and py4web understands that if you ask for all records of the table "
"person without additional information, then you want all the fields of "
"table person."
msgstr ""

#: ../../chapter-07.rst:1801
msgid "Given one row"
msgstr ""

#: ../../chapter-07.rst:1807
msgid "you can extract its values using multiple equivalent expressions:"
msgstr ""

#: ../../chapter-07.rst:1818
msgid ""
"The latter syntax is particularly handy when selecting en expression "
"instead of a column. We will show this later."
msgstr ""

#: ../../chapter-07.rst:1821
msgid "You can also do"
msgstr ""

#: ../../chapter-07.rst:1827
msgid "to disable the notation"
msgstr ""

#: ../../chapter-07.rst:1833
msgid "and enable, instead, the less compact notation:"
msgstr ""

#: ../../chapter-07.rst:1839
msgid "Yes this is unusual and rarely needed."
msgstr ""

#: ../../chapter-07.rst:1841
msgid "Row objects also have two important methods:"
msgstr ""

#: ../../chapter-07.rst:1847
msgid "and"
msgstr ""

#: ../../chapter-07.rst:1854
msgid "Using an iterator-based select for lower memory use"
msgstr ""

#: ../../chapter-07.rst:1856
msgid ""
"Python “iterators” are a type of “lazy-evaluation”. They ‘feed’ data one "
"step at time; traditional Python loops create the entire set of data in "
"memory before looping."
msgstr ""

#: ../../chapter-07.rst:1860
msgid "The traditional use of select is:"
msgstr ""

#: ../../chapter-07.rst:1867
msgid ""
"but for large numbers of rows, using an iterator-based alternative has "
"dramatically lower memory use:"
msgstr ""

#: ../../chapter-07.rst:1875
#, python-format
msgid ""
"Testing shows this is around 10% faster as well, even on machines with "
"large RAM."
msgstr ""

#: ../../chapter-07.rst:1879
msgid "Rendering rows using represent"
msgstr ""

#: ../../chapter-07.rst:1881
msgid ""
"You may wish to rewrite rows returned by select to take advantage of "
"formatting information contained in the represents setting of the fields."
msgstr ""

#: ../../chapter-07.rst:1890
msgid ""
"If you don’t specify an index, you get a generator to iterate over all "
"the rows:"
msgstr ""

#: ../../chapter-07.rst:1898
msgid "Can also be applied to slices:"
msgstr ""

#: ../../chapter-07.rst:1905
msgid ""
"If you only want to transform selected fields via their “represent” "
"attribute, you can list them in the “fields” argument:"
msgstr ""

#: ../../chapter-07.rst:1912
msgid ""
"Note, it returns a transformed copy of the original Row, so there’s no "
"update_record (which you wouldn’t want anyway) or delete_record."
msgstr ""

#: ../../chapter-07.rst:1916
msgid "Shortcuts"
msgstr ""

#: ../../chapter-07.rst:1918
msgid "The DAL supports various code-simplifying shortcuts. In particular:"
msgstr ""

#: ../../chapter-07.rst:1924
msgid ""
"returns the record with the given ``id`` if it exists. If the ``id`` does"
" not exist, it returns ``None``. The above statement is equivalent to"
msgstr ""

#: ../../chapter-07.rst:1932
msgid "You can delete records by id:"
msgstr ""

#: ../../chapter-07.rst:1938
msgid "and this is equivalent to"
msgstr ""

#: ../../chapter-07.rst:1944
msgid "and deletes the record with the given ``id``, if it exists."
msgstr ""

#: ../../chapter-07.rst:1946
msgid ""
"Note: this delete shortcut syntax does not currently work if *versioning*"
" is activated"
msgstr ""

#: ../../chapter-07.rst:1949
msgid "You can insert records:"
msgstr ""

#: ../../chapter-07.rst:1955
msgid "It is equivalent to"
msgstr ""

#: ../../chapter-07.rst:1961
msgid ""
"and it creates a new record with field values specified by the dictionary"
" on the right hand side."
msgstr ""

#: ../../chapter-07.rst:1964
msgid ""
"Note: insert shortcut was previously ``db.table[0] = ...``. It has "
"changed in PyDAL 19.02 to permit normal usage of id 0."
msgstr ""

#: ../../chapter-07.rst:1967
msgid "You can update records:"
msgstr ""

#: ../../chapter-07.rst:1973 ../../chapter-07.rst:2017
msgid "which is equivalent to"
msgstr ""

#: ../../chapter-07.rst:1979
msgid ""
"and it updates an existing record with field values specified by the "
"dictionary on the right hand side."
msgstr ""

#: ../../chapter-07.rst:1983
msgid "Fetching a ``Row``"
msgstr ""

#: ../../chapter-07.rst:1985
msgid "Yet another convenient syntax is the following:"
msgstr ""

#: ../../chapter-07.rst:1993
msgid ""
"Apparently similar to ``db.mytable[id]`` the above syntax is more "
"flexible and safer. First of all it checks whether ``id`` is an int (or "
"``str(id)`` is an int) and returns ``None`` if not (it never raises an "
"exception). It also allows to specify multiple conditions that the record"
" must meet. If they are not met, it also returns ``None``."
msgstr ""

#: ../../chapter-07.rst:2000
msgid "Recursive ``select``\\ s"
msgstr ""

#: ../../chapter-07.rst:2002
msgid ""
"Consider the previous table person and a new table “thing” referencing a "
"“person”:"
msgstr ""

#: ../../chapter-07.rst:2011
msgid "and a simple select from this table:"
msgstr ""

#: ../../chapter-07.rst:2023
msgid ""
"where ``_id`` is a reference to the primary key of the table. Normally "
"``db.thing._id`` is the same as ``db.thing.id`` and we will assume that "
"in most of this book."
msgstr ""

#: ../../chapter-07.rst:2027
msgid ""
"For each Row of things it is possible to fetch not just fields from the "
"selected table (thing) but also from linked tables (recursively):"
msgstr ""

#: ../../chapter-07.rst:2035
msgid ""
"Here ``thing.owner_id.name`` requires one database select for each thing "
"in things and it is therefore inefficient. We suggest using joins "
"whenever possible instead of recursive selects, nevertheless this is "
"convenient and practical when accessing individual records."
msgstr ""

#: ../../chapter-07.rst:2040
msgid ""
"You can also do it backwards, by selecting the things referenced by a "
"person:"
msgstr ""

#: ../../chapter-07.rst:2049
msgid "In this last expression ``person.thing`` is a shortcut for"
msgstr ""

#: ../../chapter-07.rst:2055
msgid ""
"i.e. the Set of ``thing``\\ s referenced by the current ``person``. This "
"syntax breaks down if the referencing table has multiple references to "
"the referenced table. In this case one needs to be more explicit and use "
"a full Query."
msgstr ""

#: ../../chapter-07.rst:2061
msgid ""
"``orderby``, ``groupby``, ``limitby``, ``distinct``, ``having``, "
"``orderby_on_limitby``, ``join``, ``left``, ``cache``"
msgstr ""

#: ../../chapter-07.rst:2063
msgid "The ``select`` command takes a number of optional arguments."
msgstr ""

#: ../../chapter-07.rst:2066
msgid "orderby"
msgstr ""

#: ../../chapter-07.rst:2068
msgid "You can fetch the records sorted by name:"
msgstr ""

#: ../../chapter-07.rst:2079
msgid ""
"You can fetch the records sorted by name in reverse order (notice the "
"tilde):"
msgstr ""

#: ../../chapter-07.rst:2091
msgid "You can have the fetched records appear in random order:"
msgstr ""

#: ../../chapter-07.rst:2104
msgid ""
"The use of ``orderby='<random>'`` is not supported on Google NoSQL. "
"However, to overcome this limit, sorting can be accomplished on selected "
"rows:"
msgstr ""

#: ../../chapter-07.rst:2113
msgid ""
"You can sort the records according to multiple fields by concatenating "
"them with a “\\|”:"
msgstr ""

#: ../../chapter-07.rst:2126
msgid "groupby, having"
msgstr ""

#: ../../chapter-07.rst:2128
msgid ""
"Using ``groupby`` together with ``orderby``, you can group records with "
"the same value for the specified field (this is back-end specific, and is"
" not on the Google NoSQL):"
msgstr ""

#: ../../chapter-07.rst:2143
msgid ""
"You can use ``having`` in conjunction with ``groupby`` to group "
"conditionally (only those ``having`` the condition are grouped)."
msgstr ""

#: ../../chapter-07.rst:2150
msgid ""
"Notice that query1 filters records to be displayed, query2 filters "
"records to be grouped."
msgstr ""

#: ../../chapter-07.rst:2154
msgid "distinct"
msgstr ""

#: ../../chapter-07.rst:2156
msgid ""
"With the argument ``distinct=True``, you can specify that you only want "
"to select distinct records. This has the same effect as grouping using "
"all specified fields except that it does not require sorting. When using "
"distinct it is important not to select ALL fields, and in particular not "
"to select the “id” field, else all records will always be distinct."
msgstr ""

#: ../../chapter-07.rst:2162 ../../chapter-07.rst:4117
msgid "Here is an example:"
msgstr ""

#: ../../chapter-07.rst:2173
msgid "Notice that ``distinct`` can also be an expression, for example:"
msgstr ""

#: ../../chapter-07.rst:2185
msgid "limitby"
msgstr ""

#: ../../chapter-07.rst:2187
msgid ""
"With ``limitby=(min, max)``, you can select a subset of the records from "
"offset=min to but not including offset=max. In the next example we select"
" the first two records starting at zero:"
msgstr ""

#: ../../chapter-07.rst:2200
msgid "orderby_on_limitby"
msgstr ""

#: ../../chapter-07.rst:2202
msgid ""
"Note that the DAL defaults to implicitly adding an orderby when using a "
"limitby. This ensures the same query returns the same results each time, "
"important for pagination. But it can cause performance problems. use "
"``orderby_on_limitby = False`` to change this (this defaults to True)."
msgstr ""

#: ../../chapter-07.rst:2208
msgid "join, left"
msgstr ""

#: ../../chapter-07.rst:2210
msgid ""
"These are involved in managing *one to many relations* . They are "
"described in *Inner join* and *Left outer join* sections respectively."
msgstr ""

#: ../../chapter-07.rst:2214
msgid "cache, cacheable"
msgstr ""

#: ../../chapter-07.rst:2216
msgid ""
"An example use which gives much faster selects is: ``rows = "
"db(query).select(cache=(cache.ram, 3600), cacheable=True)``:python Look "
"at *Caching selects* section in this chapter, to understand what the "
"trade-offs are."
msgstr ""

#: ../../chapter-07.rst:2222
msgid "Logical operators"
msgstr ""

#: ../../chapter-07.rst:2224
msgid "Queries can be combined using the binary AND operator “``&``”:"
msgstr ""

#: ../../chapter-07.rst:2233
msgid "and the binary OR operator “``|``”:"
msgstr ""

#: ../../chapter-07.rst:2241
msgid "You can negate a sub-query inverting its operator:"
msgstr ""

#: ../../chapter-07.rst:2250
msgid "or by explicit negation with the “``~``” unary operator:"
msgstr ""

#: ../../chapter-07.rst:2261
msgid ""
"Due to Python restrictions in overloading “``and``” and “``or``” "
"operators, these cannot be used in forming queries. The binary operators "
"“``&``” and “``|``” must be used instead. Note that these operators "
"(unlike “``and``” and “``or``”) have higher precedence than comparison "
"operators, so the “extra” parentheses in the above examples are "
"mandatory. Similarly, the unary operator “``~``” has higher precedence "
"than comparison operators, so ``~``-negated comparisons must also be "
"parenthesized."
msgstr ""

#: ../../chapter-07.rst:2270
msgid "It is also possible to build queries using in-place logical operators:"
msgstr ""

#: ../../chapter-07.rst:2279
msgid "``count``, ``isempty``, ``delete``, ``update``"
msgstr ""

#: ../../chapter-07.rst:2281
msgid "You can count records in a set:"
msgstr ""

#: ../../chapter-07.rst:2288
msgid ""
"Notice that ``count`` takes an optional ``distinct`` argument which "
"defaults to False, and it works very much like the same argument for "
"``select``. ``count`` has also a ``cache`` argument that works very much "
"like the equivalent argument of the ``select`` method."
msgstr ""

#: ../../chapter-07.rst:2293
msgid ""
"Sometimes you may need to check if a table is empty. A more efficient way"
" than counting is using the ``isempty`` method:"
msgstr ""

#: ../../chapter-07.rst:2301
msgid "You can delete records in a set:"
msgstr ""

#: ../../chapter-07.rst:2308
msgid "The ``delete`` method returns the number of records that were deleted."
msgstr ""

#: ../../chapter-07.rst:2310
msgid ""
"And you can update all records in a set by passing named arguments "
"corresponding to the fields that need to be updated:"
msgstr ""

#: ../../chapter-07.rst:2318
msgid "The ``update`` method returns the number of records that were updated."
msgstr ""

#: ../../chapter-07.rst:2321
msgid "Expressions"
msgstr ""

#: ../../chapter-07.rst:2323
msgid ""
"The value assigned an update statement can be an expression. For example "
"consider this model"
msgstr ""

#: ../../chapter-07.rst:2334
msgid "The values used in queries can also be expressions"
msgstr ""

#: ../../chapter-07.rst:2346
msgid "``case``"
msgstr ""

#: ../../chapter-07.rst:2348
msgid "An expression can contain a case clause for example:"
msgstr ""

#: ../../chapter-07.rst:2362
msgid "``update_record``"
msgstr ""

#: ../../chapter-07.rst:2364
msgid ""
"py4web also allows updating a single record that is already in memory "
"using ``update_record``"
msgstr ""

#: ../../chapter-07.rst:2373
msgid "``update_record`` should not be confused with"
msgstr ""

#: ../../chapter-07.rst:2379
msgid ""
"because for a single row, the method ``update`` updates the row object "
"but not the database record, as in the case of ``update_record``."
msgstr ""

#: ../../chapter-07.rst:2382
msgid ""
"It is also possible to change the attributes of a row (one at a time) and"
" then call ``update_record()`` without arguments to save the changes:"
msgstr ""

#: ../../chapter-07.rst:2394
msgid ""
"Note, you should avoid using ``row.update_record()`` with no arguments "
"when the ``row`` object contains fields that have an ``update`` attribute"
" (e.g., ``Field('modified_on', update=request.now)``). Calling "
"``row.update_record()`` will retain *all* of the existing values in the "
"``row`` object, so any fields with ``update`` attributes will have no "
"effect in this case. Be particularly mindful of this with tables that "
"include ``auth.signature``."
msgstr ""

#: ../../chapter-07.rst:2403
msgid ""
"The ``update_record`` method is available only if the table’s ``id`` "
"field is included in the select, and ``cacheable`` is not set to "
"``True``."
msgstr ""

#: ../../chapter-07.rst:2408
msgid "Inserting and updating from a dictionary"
msgstr ""

#: ../../chapter-07.rst:2410
msgid ""
"A common issue consists of needing to insert or update records in a table"
" where the name of the table, the field to be updated, and the value for "
"the field are all stored in variables. For example: ``tablename``, "
"``fieldname``, and ``value``."
msgstr ""

#: ../../chapter-07.rst:2415
msgid "The insert can be done using the following syntax:"
msgstr ""

#: ../../chapter-07.rst:2421
msgid "The update of record with given id can be done with:"
msgstr ""

#: ../../chapter-07.rst:2427
msgid ""
"Notice we used ``table._id`` instead of ``table.id``. In this way the "
"query works even for tables with a primary key field with type other than"
" “id”."
msgstr ""

#: ../../chapter-07.rst:2432
msgid "``first`` and ``last``"
msgstr ""

#: ../../chapter-07.rst:2434
msgid "Given a Rows object containing records:"
msgstr ""

#: ../../chapter-07.rst:2442
msgid "are equivalent to"
msgstr ""

#: ../../chapter-07.rst:2449
msgid ""
"Notice, ``first()`` and ``last()`` allow you to obtain obviously the "
"first and last record present in your query, but this won’t mean that "
"these records are going to be the first or last inserted records. In case"
" you want the first or last record inputted in a given table don’t forget"
" to use ``orderby=db.table_name.id``. If you forget you will only get the"
" first and last record returned by your query which are often in a random"
" order determined by the backend query optimiser."
msgstr ""

#: ../../chapter-07.rst:2458
msgid "``as_dict`` and ``as_list``"
msgstr ""

#: ../../chapter-07.rst:2460
msgid ""
"A Row object can be serialized into a regular dictionary using the "
"``as_dict()`` method and a Rows object can be serialized into a list of "
"dictionaries using the ``as_list()`` method. Here are some examples:"
msgstr ""

#: ../../chapter-07.rst:2470
msgid ""
"These methods are convenient for passing Rows to generic views and or to "
"store Rows in sessions (since Rows objects themselves cannot be "
"serialized since contain a reference to an open DB connection):"
msgstr ""

#: ../../chapter-07.rst:2481
msgid "Combining rows"
msgstr ""

#: ../../chapter-07.rst:2483
msgid "Rows objects can be combined at the Python level. Here we assume:"
msgstr ""

#: ../../chapter-07.rst:2497
msgid "You can do union of the records in two sets of rows:"
msgstr ""

#: ../../chapter-07.rst:2509
msgid "You can do union of the records removing duplicates:"
msgstr ""

#: ../../chapter-07.rst:2520
msgid "You can do intersection of the records in two sets of rows:"
msgstr ""

#: ../../chapter-07.rst:2530
msgid "``find``, ``exclude``, ``sort``"
msgstr ""

#: ../../chapter-07.rst:2532
msgid ""
"Some times you need to perform two selects and one contains a subset of a"
" previous select. In this case it is pointless to access the database "
"again. The ``find``, ``exclude`` and ``sort`` objects allow you to "
"manipulate a Rows object and generate another one without accessing the "
"database. More specifically: - ``find`` returns a new set of Rows "
"filtered by a condition and leaves the original unchanged. - ``exclude`` "
"returns a new set of Rows filtered by a condition and removes them from "
"the original Rows. - ``sort`` returns a new set of Rows sorted by a "
"condition and leaves the original unchanged."
msgstr ""

#: ../../chapter-07.rst:2542
msgid ""
"All these methods take a single argument, a function that acts on each "
"individual row."
msgstr ""

#: ../../chapter-07.rst:2545
msgid "Here is an example of usage:"
msgstr ""

#: ../../chapter-07.rst:2576
msgid "They can be combined:"
msgstr ""

#: ../../chapter-07.rst:2588
msgid "Sort takes an optional argument ``reverse=True`` with the obvious meaning."
msgstr ""

#: ../../chapter-07.rst:2591
msgid ""
"The ``find`` method has an optional ``limitby`` argument with the same "
"syntax and functionality as the Set ``select`` method."
msgstr ""

#: ../../chapter-07.rst:2595
msgid "Other methods"
msgstr ""

#: ../../chapter-07.rst:2598
msgid "``update_or_insert``"
msgstr ""

#: ../../chapter-07.rst:2600
msgid ""
"Some times you need to perform an insert only if there is no record with "
"the same values as those being inserted. This can be done with"
msgstr ""

#: ../../chapter-07.rst:2611
msgid ""
"The record will be inserted only if there is no other user called John "
"born in Chicago."
msgstr ""

#: ../../chapter-07.rst:2614
msgid ""
"You can specify which values to use as a key to determine if the record "
"exists. For example:"
msgstr ""

#: ../../chapter-07.rst:2623
msgid ""
"and if there is John his birthplace will be updated else a new record "
"will be created."
msgstr ""

#: ../../chapter-07.rst:2626
msgid ""
"The selection criteria in the example above is a single field. It can "
"also be a query, such as"
msgstr ""

#: ../../chapter-07.rst:2637
msgid "``validate_and_insert``, ``validate_and_update``"
msgstr ""

#: ../../chapter-07.rst:2639
msgid "The function"
msgstr ""

#: ../../chapter-07.rst:2645
msgid "works very much like"
msgstr ""

#: ../../chapter-07.rst:2651
msgid ""
"except that it calls the validators for the fields before performing the "
"insert and bails out if the validation does not pass. If validation does "
"not pass the errors can be found in ``ret.errors``. ``ret.errors`` holds "
"a key-value mapping where each key is the field name whose validation "
"failed, and the value of the key is the result from the validation error "
"(much like ``form.errors``). If it passes, the id of the new record is in"
" ``ret.id``. Mind that normally validation is done by the form processing"
" logic so this function is rarely needed."
msgstr ""

#: ../../chapter-07.rst:2660
msgid "Similarly"
msgstr ""

#: ../../chapter-07.rst:2666
msgid "works very much the same as"
msgstr ""

#: ../../chapter-07.rst:2672
msgid ""
"except that it calls the validators for the fields before performing the "
"update. Notice that it only works if query involves a single table. The "
"number of updated records can be found in ``ret.updated`` and errors will"
" be in ``ret.errors``."
msgstr ""

#: ../../chapter-07.rst:2678
msgid "Computed fields"
msgstr ""

#: ../../chapter-07.rst:2680
msgid ""
"DAL fields may have a ``compute`` attribute. This must be a function (or "
"lambda) that takes a Row object and returns a value for the field. When a"
" new record is modified, including both insertions and updates, if a "
"value for the field is not provided, py4web tries to compute from the "
"other field values using the ``compute`` function. Here is an example:"
msgstr ""

#: ../../chapter-07.rst:2698
msgid ""
"Notice that the computed value is stored in the db and it is not computed"
" on retrieval, as in the case of virtual fields, described next. Two "
"typical applications of computed fields are: - in wiki applications, to "
"store the processed input wiki text as HTML, to avoid re-processing on "
"every request - for searching, to compute normalized values for a field, "
"to be used for searching."
msgstr ""

#: ../../chapter-07.rst:2705
msgid ""
"Computed fields are evaluated in the order in which they are defined in "
"the table definition. A computed field can refer to previously defined "
"computed fields (new after v 2.5.1)"
msgstr ""

#: ../../chapter-07.rst:2710
msgid "Virtual fields"
msgstr ""

#: ../../chapter-07.rst:2712
msgid ""
"Virtual fields are also computed fields (as in the previous subsection) "
"but they differ from those because they are *virtual* in the sense that "
"they are not stored in the db and they are computed each time records are"
" extracted from the database. They can be used to simplify the user’s "
"code without using additional storage but they cannot be used for "
"searching."
msgstr ""

#: ../../chapter-07.rst:2720
msgid "New style virtual fields (experimental)"
msgstr ""

#: ../../chapter-07.rst:2722
msgid ""
"py4web provides a new and easier way to define virtual fields and lazy "
"virtual fields. This section is marked experimental because the APIs may "
"still change a little from what is described here."
msgstr ""

#: ../../chapter-07.rst:2726
msgid ""
"Here we will consider the same example as in the previous subsection. In "
"particular we consider the following model:"
msgstr ""

#: ../../chapter-07.rst:2735 ../../chapter-07.rst:2814
msgid "One can define a ``total_price`` virtual field as"
msgstr ""

#: ../../chapter-07.rst:2741
msgid ""
"i.e. by simply defining a new field ``total_price`` to be a "
"``Field.Virtual``. The only argument of the constructor is a function "
"that takes a row and returns the computed values."
msgstr ""

#: ../../chapter-07.rst:2745
msgid ""
"A virtual field defined as the one above is automatically computed for "
"all records when the records are selected:"
msgstr ""

#: ../../chapter-07.rst:2753
msgid ""
"It is also possible to define method fields which are calculated on-"
"demand, when called. For example:"
msgstr ""

#: ../../chapter-07.rst:2762
msgid ""
"In this case ``row.discounted_total`` is not a value but a function. The "
"function takes the same arguments as the function passed to the "
"``Method`` constructor except for ``row`` which is implicit (think of it "
"as ``self`` for objects)."
msgstr ""

#: ../../chapter-07.rst:2767
msgid ""
"The lazy field in the example above allows one to compute the total price"
" for each ``item``:"
msgstr ""

#: ../../chapter-07.rst:2774
msgid "And it also allows to pass an optional ``discount`` percentage (say 15%):"
msgstr ""

#: ../../chapter-07.rst:2781
msgid ""
"Virtual and Method fields can also be defined in place when a table is "
"defined:"
msgstr ""

#: ../../chapter-07.rst:2794
msgid ""
"Mind that virtual fields do not have the same attributes as regular "
"fields (length, default, required, etc). They do not appear in the list "
"of ``db.table.fields`` and in older versions of py4web they require a "
"special approach to display in SQLFORM.grid and SQLFORM.smartgrid. See "
"the discussion on grids and virtual fields in *Chapter 12* ."
msgstr ""

#: ../../chapter-07.rst:2802
msgid "Old style virtual fields"
msgstr ""

#: ../../chapter-07.rst:2804
msgid ""
"In order to define one or more virtual fields, you can also define a "
"container class, instantiate it and link it to a table or to a select. "
"For example, consider the following table:"
msgstr ""

#: ../../chapter-07.rst:2824
msgid ""
"Notice that each method of the class that takes a single argument (self) "
"is a new virtual field. ``self`` refers to each one row of the select. "
"Field values are referred by full path as in ``self.item.unit_price``. "
"The table is linked to the virtual fields by appending an instance of the"
" class to the table’s ``virtualfields`` attribute."
msgstr ""

#: ../../chapter-07.rst:2830
msgid "Virtual fields can also access recursive fields as in"
msgstr ""

#: ../../chapter-07.rst:2847
msgid ""
"Notice the recursive field access ``self.order_item.item.unit_price`` "
"where ``self`` is the looping record."
msgstr ""

#: ../../chapter-07.rst:2850
msgid "They can also act on the result of a JOIN"
msgstr ""

#: ../../chapter-07.rst:2865
msgid ""
"Notice how in this case the syntax is different. The virtual field "
"accesses both ``self.item.unit_price`` and ``self.order_item.quantity`` "
"which belong to the join select. The virtual field is attached to the "
"rows of the table using the ``setvirtualfields`` method of the rows "
"object. This method takes an arbitrary number of named arguments and can "
"be used to set multiple virtual fields, defined in multiple classes, and "
"attach them to multiple tables:"
msgstr ""

#: ../../chapter-07.rst:2891
msgid ""
"Virtual fields can be *lazy*; all they need to do is return a function "
"and access it by calling the function:"
msgstr ""

#: ../../chapter-07.rst:2911
msgid "or shorter using a lambda function:"
msgstr ""

#: ../../chapter-07.rst:2920
msgid "One to many relation"
msgstr ""

#: ../../chapter-07.rst:2922
msgid ""
"To illustrate how to implement one to many relations with the DAL, define"
" another table “thing” that refers to the table “person” which we "
"redefine here:"
msgstr ""

#: ../../chapter-07.rst:2942
msgid ""
"Table “thing” has two fields, the name of the thing and the owner of the "
"thing. The “owner_id” field is a reference field, it is intended that the"
" field reference the other table by its id. A reference type can be "
"specified in two equivalent ways, either: ``Field('owner_id', 'reference "
"person')``:python or: ``Field('owner_id', db.person)``:python"
msgstr ""

#: ../../chapter-07.rst:2949
msgid ""
"The latter is always converted to the former. They are equivalent except "
"in the case of lazy tables, self references or other types of cyclic "
"references where the former notation is the only allowed notation."
msgstr ""

#: ../../chapter-07.rst:2953
msgid "Now, insert three things, two owned by Alex and one by Bob:"
msgstr ""

#: ../../chapter-07.rst:2964
msgid "You can select as you did for any other table:"
msgstr ""

#: ../../chapter-07.rst:2974
msgid ""
"Because a thing has a reference to a person, a person can have many "
"things, so a record of table person now acquires a new attribute thing, "
"which is a Set, that defines the things of that person. This allows "
"looping over all persons and fetching their things easily:"
msgstr ""

#: ../../chapter-07.rst:2994
msgid "Inner joins"
msgstr ""

#: ../../chapter-07.rst:2996
msgid ""
"Another way to achieve a similar result is by using a join, specifically "
"an INNER JOIN. py4web performs joins automatically and transparently when"
" the query links two or more tables as in the following example:"
msgstr ""

#: ../../chapter-07.rst:3010
msgid ""
"Observe that py4web did a join, so the rows now contain two records, one "
"from each table, linked together. Because the two records may have fields"
" with conflicting names, you need to specify the table when extracting a "
"field value from a row. This means that while before you could do:"
msgstr ""

#: ../../chapter-07.rst:3020
msgid ""
"and it was obvious whether this was the name of a person or a thing, in "
"the result of a join you have to be more explicit and say:"
msgstr ""

#: ../../chapter-07.rst:3027
msgid "or:"
msgstr ""

#: ../../chapter-07.rst:3033
msgid "There is an alternative syntax for INNER JOINS:"
msgstr ""

#: ../../chapter-07.rst:3045
msgid ""
"While the output is the same, the generated SQL in the two cases can be "
"different. The latter syntax removes possible ambiguities when the same "
"table is joined twice and aliased:"
msgstr ""

#: ../../chapter-07.rst:3060
msgid "The value of ``join`` can be list of ``db.table.on(...)`` to join."
msgstr ""

#: ../../chapter-07.rst:3063
msgid "Left outer join"
msgstr ""

#: ../../chapter-07.rst:3065
msgid ""
"Notice that Carl did not appear in the list above because he has no "
"things. If you intend to select on persons (whether they have things or "
"not) and their things (if they have any), then you need to perform a LEFT"
" OUTER JOIN. This is done using the argument “left” of the select. Here "
"is an example:"
msgstr ""

#: ../../chapter-07.rst:3083
msgid "where:"
msgstr ""

#: ../../chapter-07.rst:3089
msgid ""
"does the left join query. Here the argument of ``db.thing.on`` is the "
"condition required for the join (the same used above for the inner join)."
" In the case of a left join, it is necessary to be explicit about which "
"fields to select."
msgstr ""

#: ../../chapter-07.rst:3094
msgid ""
"Multiple left joins can be combined by passing a list or tuple of "
"``db.mytable.on(...)`` to the ``left`` parameter."
msgstr ""

#: ../../chapter-07.rst:3098
msgid "Grouping and counting"
msgstr ""

#: ../../chapter-07.rst:3100
msgid ""
"When doing joins, sometimes you want to group rows according to certain "
"criteria and count them. For example, count the number of things owned by"
" every person. py4web allows this as well. First, you need a count "
"operator. Second, you want to join the person table with the thing table "
"by owner. Third, you want to select all rows (person + thing), group them"
" by person, and count them while grouping:"
msgstr ""

#: ../../chapter-07.rst:3117
msgid ""
"Notice the ``count`` operator (which is built-in) is used as a field. The"
" only issue here is in how to retrieve the information. Each row clearly "
"contains a person and the count, but the count is not a field of a person"
" nor is it a table. So where does it go? It goes into the storage object "
"representing the record with a key equal to the query expression itself."
msgstr ""

#: ../../chapter-07.rst:3124
msgid ""
"The ``count`` method of the Field object has an optional ``distinct`` "
"argument. When set to ``True`` it specifies that only distinct values of "
"the field in question are to be counted."
msgstr ""

#: ../../chapter-07.rst:3129
msgid "Many to many"
msgstr ""

#: ../../chapter-07.rst:3131
msgid ""
"In the previous examples, we allowed a thing to have one owner but one "
"person could have many things. What if Boat was owned by Alex and Curt? "
"This requires a many-to-many relation, and it is realized via an "
"intermediate table that links a person to a thing via an ownership "
"relation."
msgstr ""

#: ../../chapter-07.rst:3137
msgid "Here is how to do it:"
msgstr ""

#: ../../chapter-07.rst:3156
msgid "the existing ownership relationship can now be rewritten as:"
msgstr ""

#: ../../chapter-07.rst:3167
msgid "Now you can add the new relation that Curt co-owns Boat:"
msgstr ""

#: ../../chapter-07.rst:3174
msgid ""
"Because you now have a three-way relation between tables, it may be "
"convenient to define a new set on which to perform operations:"
msgstr ""

#: ../../chapter-07.rst:3182
msgid "Now it is easy to select all persons and their things from the new Set:"
msgstr ""

#: ../../chapter-07.rst:3194
msgid "Similarly, you can search for all things owned by Alex:"
msgstr ""

#: ../../chapter-07.rst:3204
msgid "and all owners of Boat:"
msgstr ""

#: ../../chapter-07.rst:3214
msgid ""
"A lighter alternative to many-to-many relations is tagging, you can found"
" an example of this in the next section. Tagging works even on database "
"backends that do not support JOINs like the Google App Engine NoSQL."
msgstr ""

#: ../../chapter-07.rst:3220
msgid "Tagging records"
msgstr ""

#: ../../chapter-07.rst:3222
msgid ""
"Tags allows to add or find properties attached to records in your "
"database."
msgstr ""

#: ../../chapter-07.rst:3252
msgid ""
"It is internally implemented as a table with name: \\ *tags*\\ , which in"
" this example would be db.thing_tags_default, because no path was "
"specified on the Tags(table, path=“default”) constructor"
msgstr ""

#: ../../chapter-07.rst:3256
msgid ""
"The ``find`` method is doing a search by ``startswith`` of the path "
"passed as parameter. Then find([“color”]) would return id1 and id2 "
"because both records have tags starting with “color”. py4web uses tags as"
" a flexible mechanism to manage permissions."
msgstr ""

#: ../../chapter-07.rst:3262
msgid "``list:<type>`` and ``contains``"
msgstr ""

#: ../../chapter-07.rst:3264
msgid "py4web provides the following special field types:"
msgstr ""

#: ../../chapter-07.rst:3272
msgid ""
"They can contain lists of strings, of integers and of references "
"respectively."
msgstr ""

#: ../../chapter-07.rst:3275
msgid ""
"On Google App Engine NoSQL ``list:string`` is mapped into "
"``StringListProperty``, the other two are mapped into "
"``ListProperty(int)``. On relational databases they are mapped into text "
"fields which contain the list of items separated by ``|``. For example "
"``[1, 2, 3]`` is mapped into ``|1|2|3|``."
msgstr ""

#: ../../chapter-07.rst:3281
msgid ""
"For lists of string the items are escaped so that any ``|`` in the item "
"is replaced by a ``||``. Anyway this is an internal representation and it"
" is transparent to the user."
msgstr ""

#: ../../chapter-07.rst:3285
msgid "You can use ``list:string``, for example, in the following way:"
msgstr ""

#: ../../chapter-07.rst:3302
msgid "``list:integer`` works in the same way but the items must be integers."
msgstr ""

#: ../../chapter-07.rst:3304
msgid ""
"As usual the requirements are enforced at the level of forms, not at the "
"level of ``insert``."
msgstr ""

#: ../../chapter-07.rst:3307
msgid ""
"For ``list:<type>`` fields the ``contains(value)`` operator maps into a "
"non trivial query that checks for lists containing the ``value``. The "
"``contains`` operator also works for regular ``string`` and ``text`` "
"fields and it maps into a ``LIKE '%value%'``."
msgstr ""

#: ../../chapter-07.rst:3312
msgid ""
"The ``list:reference`` and the ``contains(value)`` operator are "
"particularly useful to de-normalize many-to-many relations. Here is an "
"example:"
msgstr ""

#: ../../chapter-07.rst:3341
msgid "Notice that a ``list:reference tag`` field get a default constraint"
msgstr ""

#: ../../chapter-07.rst:3347
msgid "that produces a ``SELECT/OPTION`` multiple drop-box in forms."
msgstr ""

#: ../../chapter-07.rst:3349
msgid ""
"Also notice that this field gets a default ``represent`` attribute which "
"represents the list of references as a comma-separated list of formatted "
"references. This is used in read ``forms``."
msgstr ""

#: ../../chapter-07.rst:3353
msgid ""
"While ``list:reference`` has a default validator and a default "
"representation, ``list:integer`` and ``list:string`` do not. So these two"
" need an ``IS_IN_SET`` or an ``IS_IN_DB`` validator if you want to use "
"them in forms."
msgstr ""

#: ../../chapter-07.rst:3359
msgid "Other operators"
msgstr ""

#: ../../chapter-07.rst:3361
msgid ""
"py4web has other operators that provide an API to access equivalent SQL "
"operators. Let’s define another table “log” to store security events, "
"their event_time and severity, where the severity is an integer number."
msgstr ""

#: ../../chapter-07.rst:3372
msgid ""
"As before, insert a few events, a “port scan”, an “xss injection” and an "
"“unauthorized login”. For the sake of the example, you can log events "
"with the same event_time but with different severities (1, 2, and 3 "
"respectively)."
msgstr ""

#: ../../chapter-07.rst:3389
msgid ""
"``like``, ``ilike``, ``regexp``, ``startswith``, ``endswith``, "
"``contains``, ``upper``, ``lower``"
msgstr ""

#: ../../chapter-07.rst:3391
msgid "Fields have a ``like`` operator that you can use to match strings:"
msgstr ""

#: ../../chapter-07.rst:3400
msgid ""
"Here “port%” indicates a string starting with “port”. The percent sign "
"character, “%”, is a wild-card character that means “any sequence of "
"characters”."
msgstr ""

#: ../../chapter-07.rst:3404
msgid ""
"The ``like`` operator maps to the LIKE word in ANSI-SQL. LIKE is case-"
"sensitive in most databases, and depends on the collation of the database"
" itself. The ``like`` method is hence case-sensitive but it can be made "
"case-insensitive with"
msgstr ""

#: ../../chapter-07.rst:3413
msgid "which is the same as using ``ilike``"
msgstr ""

#: ../../chapter-07.rst:3419
msgid "py4web also provides some shortcuts:"
msgstr ""

#: ../../chapter-07.rst:3427
msgid "which are roughly equivalent respectively to"
msgstr ""

#: ../../chapter-07.rst:3435
msgid ""
"Remember that ``contains`` has a special meaning for ``list:<type>`` "
"fields, as discussed in previous *list: and contains* section."
msgstr ""

#: ../../chapter-07.rst:3438
msgid ""
"The ``contains`` method can also be passed a list of values and an "
"optional boolean argument ``all`` to search for records that contain all "
"values:"
msgstr ""

#: ../../chapter-07.rst:3446
msgid "or any value from the list"
msgstr ""

#: ../../chapter-07.rst:3452
msgid ""
"There is a also a ``regexp`` method that works like the ``like`` method "
"but allows regular expression syntax for the look-up expression. It is "
"only supported by MySQL, Oracle, PostgreSQL, SQLite, and MongoDB (with "
"different degree of support)."
msgstr ""

#: ../../chapter-07.rst:3457
msgid ""
"The ``upper`` and ``lower`` methods allow you to convert the value of the"
" field to upper or lower case, and you can also combine them with the "
"like operator:"
msgstr ""

#: ../../chapter-07.rst:3469
msgid "``year``, ``month``, ``day``, ``hour``, ``minutes``, ``seconds``"
msgstr ""

#: ../../chapter-07.rst:3471
msgid ""
"The date and datetime fields have ``day``, ``month`` and ``year`` "
"methods. The datetime and time fields have ``hour``, ``minutes`` and "
"``seconds`` methods. Here is an example:"
msgstr ""

#: ../../chapter-07.rst:3485
msgid "``belongs``"
msgstr ""

#: ../../chapter-07.rst:3487
msgid ""
"The SQL IN operator is realized via the ``belongs`` method which returns "
"true when the field value belongs to the specified set (list or tuples):"
msgstr ""

#: ../../chapter-07.rst:3498
msgid ""
"The DAL also allows a nested select as the argument of the belongs "
"operator. The only caveat is that the nested select has to be a "
"``_select``, not a ``select``, and only one field has to be selected "
"explicitly, the one that defines the set."
msgstr ""

#: ../../chapter-07.rst:3513
msgid ""
"In those cases where a nested select is required and the look-up field is"
" a reference we can also use a query as argument. For example:"
msgstr ""

#: ../../chapter-07.rst:3525
msgid ""
"In this case it is obvious that the nested select only needs the field "
"referenced by the ``db.thing.owner_id`` field so we do not need the more "
"verbose ``_select`` notation."
msgstr ""

#: ../../chapter-07.rst:3529
msgid ""
"A nested select can also be used as insert/update value but in this case "
"the syntax is different:"
msgstr ""

#: ../../chapter-07.rst:3538
msgid ""
"In this case ``lazy`` is a nested expression that computes the ``id`` of "
"person “Jonathan”. The two lines result in one single SQL query."
msgstr ""

#: ../../chapter-07.rst:3542
msgid "``sum``, ``avg``, ``min``, ``max`` and ``len``"
msgstr ""

#: ../../chapter-07.rst:3544
msgid ""
"Previously, you have used the ``count`` operator to count records. "
"Similarly, you can use the ``sum`` operator to add (sum) the values of a "
"specific field from a group of records. As in the case of count, the "
"result of a sum is retrieved via the storage object:"
msgstr ""

#: ../../chapter-07.rst:3555
msgid ""
"You can also use ``avg``, ``min``, and ``max`` to the average, minimum, "
"and maximum value respectively for the selected records. For example:"
msgstr ""

#: ../../chapter-07.rst:3564
msgid ""
"``len`` computes the length of field’s value. It is generally used on "
"string or text fields but depending on the back-end it may still work for"
" other types too (boolean, integer, etc)."
msgstr ""

#: ../../chapter-07.rst:3575
msgid ""
"Expressions can be combined to form more complex expressions. For example"
" here we are computing the sum of the length of the event strings in the "
"logs plus one:"
msgstr ""

#: ../../chapter-07.rst:3586
msgid "Substrings"
msgstr ""

#: ../../chapter-07.rst:3588
msgid ""
"One can build an expression to refer to a substring. For example, we can "
"group things whose name starts with the same three characters and select "
"only one from each group:"
msgstr ""

#: ../../chapter-07.rst:3597
msgid "Default values with ``coalesce`` and ``coalesce_zero``"
msgstr ""

#: ../../chapter-07.rst:3599
msgid ""
"There are times when you need to pull a value from database but also need"
" a default values if the value for a record is set to NULL. In SQL there "
"is a function, ``COALESCE``, for this. py4web has an equivalent "
"``coalesce`` method:"
msgstr ""

#: ../../chapter-07.rst:3619
msgid ""
"Other times you need to compute a mathematical expression but some fields"
" have a value set to None while it should be zero. ``coalesce_zero`` "
"comes to the rescue by defaulting None to zero in the query:"
msgstr ""

#: ../../chapter-07.rst:3641
msgid "Generating raw sql"
msgstr ""

#: ../../chapter-07.rst:3643
msgid ""
"Sometimes you need to generate the SQL but not execute it. This is easy "
"to do with py4web since every command that performs database IO has an "
"equivalent command that does not, and simply returns the SQL that would "
"have been executed. These commands have the same names and syntax as the "
"functional ones, but they start with an underscore:"
msgstr ""

#: ../../chapter-07.rst:3649
msgid "Here is ``_insert``"
msgstr ""

#: ../../chapter-07.rst:3656
msgid "Here is ``_count``"
msgstr ""

#: ../../chapter-07.rst:3663
msgid "Here is ``_select``"
msgstr ""

#: ../../chapter-07.rst:3670
msgid "Here is ``_delete``"
msgstr ""

#: ../../chapter-07.rst:3677
msgid "And finally, here is ``_update``"
msgstr ""

#: ../../chapter-07.rst:3686
msgid ""
"Moreover you can always use ``db._lastsql`` to return the most recent SQL"
" code, whether it was executed manually using executesql or was SQL "
"generated by the DAL."
msgstr ""

#: ../../chapter-07.rst:3691
msgid "Exporting and importing data"
msgstr ""

#: ../../chapter-07.rst:3694
msgid "CSV (one Table at a time)"
msgstr ""

#: ../../chapter-07.rst:3696
msgid ""
"When a Rows object is converted to a string it is automatically "
"serialized in CSV:"
msgstr ""

#: ../../chapter-07.rst:3708
msgid "You can serialize a single table in CSV and store it in a file “test.csv”:"
msgstr ""

#: ../../chapter-07.rst:3718
msgid ""
"Notice that converting a ``Rows`` object into a string using Python 2 "
"produces an utf8 encoded binary string. To obtain a different encoding "
"you have to ask for it explicitly, for example with:"
msgstr ""

#: ../../chapter-07.rst:3722
msgid "``unicode(str(db(db.person).select()), 'utf8').encode(...)``:pythonn"
msgstr ""

#: ../../chapter-07.rst:3724 ../../chapter-07.rst:3787
msgid "Or in Python 3:"
msgstr ""

#: ../../chapter-07.rst:3731
msgid "This is equivalent to"
msgstr ""

#: ../../chapter-07.rst:3739
msgid "You can read the CSV file back with:"
msgstr ""

#: ../../chapter-07.rst:3746
msgid ""
"Again, when using Python 3, you can be explict about the encoding for the"
" exporting file:"
msgstr ""

#: ../../chapter-07.rst:3755
msgid "and the importing one:"
msgstr ""

#: ../../chapter-07.rst:3762
msgid ""
"When importing, py4web looks for the field names in the CSV header. In "
"this example, it finds two columns: “person.id” and “person.name”. It "
"ignores the “person.” prefix, and it ignores the “id” fields. Then all "
"records are appended and assigned new ids. Both of these operations can "
"be performed via the appadmin web interface."
msgstr ""

#: ../../chapter-07.rst:3769
msgid "CSV (all tables at once)"
msgstr ""

#: ../../chapter-07.rst:3771
msgid "In py4web, you can backup/restore an entire database with two commands:"
msgstr ""

#: ../../chapter-07.rst:3773 ../../chapter-07.rst:3789
msgid "To export:"
msgstr ""

#: ../../chapter-07.rst:3780 ../../chapter-07.rst:3796
msgid "To import:"
msgstr ""

#: ../../chapter-07.rst:3803
msgid ""
"This mechanism can be used even if the importing database is of a "
"different type than the exporting database."
msgstr ""

#: ../../chapter-07.rst:3806
msgid ""
"The data is stored in “somefile.csv” as a CSV file where each table "
"starts with one line that indicates the tablename, and another line with "
"the fieldnames:"
msgstr ""

#: ../../chapter-07.rst:3815
msgid ""
"Two tables are separated by ``\\r\\n\\r\\n`` (that is two empty lines). "
"The file ends with the line"
msgstr ""

#: ../../chapter-07.rst:3822
msgid ""
"The file does not include uploaded files if these are not stored in the "
"database. The upload files stored on filesystem must be dumped "
"separately, a zip of the “uploads” folder may suffice in most cases."
msgstr ""

#: ../../chapter-07.rst:3826
msgid ""
"When importing, the new records will be appended to the database if it is"
" not empty. In general the new imported records will not have the same "
"record id as the original (saved) records but py4web will restore "
"references so they are not broken, even if the id values may change."
msgstr ""

#: ../../chapter-07.rst:3831
msgid ""
"If a table contains a field called ``uuid``, this field will be used to "
"identify duplicates. Also, if an imported record has the same ``uuid`` as"
" an existing record, the previous record will be updated."
msgstr ""

#: ../../chapter-07.rst:3836
msgid "CSV and remote database synchronization"
msgstr ""

#: ../../chapter-07.rst:3838
msgid "Consider once again the following model:"
msgstr ""

#: ../../chapter-07.rst:3854
msgid ""
"Each record is identified by an identifier and referenced by that id. If "
"you have two copies of the database used by distinct py4web "
"installations, the id is unique only within each database and not across "
"the databases. This is a problem when merging records from different "
"databases."
msgstr ""

#: ../../chapter-07.rst:3860
msgid ""
"In order to make records uniquely identifiable across databases, they "
"must: - have a unique id (UUID), - have a last modification time to track"
" the most recent among multiple copies, - reference the UUID instead of "
"the id."
msgstr ""

#: ../../chapter-07.rst:3865
msgid "This can be achieved changing the above model into:"
msgstr ""

#: ../../chapter-07.rst:3894
msgid ""
"Notice that in the above table definitions, the default value for the two"
" ``uuid`` fields is set to a lambda function, which returns a UUID "
"(converted to a string). The lambda function is called once for each "
"record inserted, ensuring that each record gets a unique UUID, even if "
"multiple records are inserted in a single transaction."
msgstr ""

#: ../../chapter-07.rst:3900
msgid "Create a controller action to export the database:"
msgstr ""

#: ../../chapter-07.rst:3910
msgid ""
"Create a controller action to import a saved copy of the other database "
"and sync records:"
msgstr ""

#: ../../chapter-07.rst:3932
msgid ""
"Optionally you should create an index manually to make the search by uuid"
" faster."
msgstr ""

#: ../../chapter-07.rst:3935
msgid "Alternatively, you can use XML-RPC to export/import the file."
msgstr ""

#: ../../chapter-07.rst:3937
msgid ""
"If the records reference uploaded files, you also need to export/import "
"the content of the uploads folder. Notice that files therein are already "
"labeled by UUIDs so you do not need to worry about naming conflicts and "
"references."
msgstr ""

#: ../../chapter-07.rst:3943
msgid "HTML and XML (one Table at a time)"
msgstr ""

#: ../../chapter-07.rst:3945
msgid ""
"Rows objects also have an ``xml`` method (like helpers) that serializes "
"it to XML/HTML:"
msgstr ""

#: ../../chapter-07.rst:3982
msgid ""
"If you need to serialize the Rows in any other XML format with custom "
"tags, you can easily do that using the universal ``TAG`` helper "
"(described in `Chapter 11 <#chapter-08#TAGs>`__ and the Python syntax "
"``*<iterable>`` allowed in function calls:"
msgstr ""

#: ../../chapter-07.rst:4001
msgid "Data representation"
msgstr ""

#: ../../chapter-07.rst:4003
msgid ""
"The ``Rows.export_to_csv_file`` method accepts a keyword argument named "
"``represent``. When ``True`` it will use the columns ``represent`` "
"function while exporting the data instead of the raw data."
msgstr ""

#: ../../chapter-07.rst:4007
msgid ""
"The function also accepts a keyword argument named ``colnames`` that "
"should contain a list of column names one wish to export. It defaults to "
"all columns."
msgstr ""

#: ../../chapter-07.rst:4011
msgid ""
"Both ``export_to_csv_file`` and ``import_from_csv_file`` accept keyword "
"arguments that tell the csv parser the format to save/load the files: - "
"``delimiter``: delimiter to separate values (default ‘,’) - "
"``quotechar``: character to use to quote string values (default to double"
" quotes) - ``quoting``: quote system (default ``csv.QUOTE_MINIMAL``)"
msgstr ""

#: ../../chapter-07.rst:4018
msgid "Here is some example usage:"
msgstr ""

#: ../../chapter-07.rst:4030
msgid "Which would render something similar to"
msgstr ""

#: ../../chapter-07.rst:4036
msgid "For more information consult the official Python documentation"
msgstr ""

#: ../../chapter-07.rst:4039
msgid "Caching selects"
msgstr ""

#: ../../chapter-07.rst:4041
msgid ""
"The select method also takes a ``cache`` argument, which defaults to "
"None. For caching purposes, it should be set to a tuple where the first "
"element is the cache model (``cache.ram``, ``cache.disk``, etc.), and the"
" second element is the expiration time in seconds."
msgstr ""

#: ../../chapter-07.rst:4046
msgid ""
"In the following example, you see a controller that caches a select on "
"the previously defined db.log table. The actual select fetches data from "
"the back-end database no more frequently than once every 60 seconds and "
"stores the result in memory. If the next call to this controller occurs "
"in less than 60 seconds since the last database IO, it simply fetches the"
" previous data from memory."
msgstr ""

#: ../../chapter-07.rst:4059
msgid ""
"The ``select`` method has an optional ``cacheable`` argument, normally "
"set to False. When ``cacheable=True`` the resulting ``Rows`` is "
"serializable but The ``Row``\\ s lack ``update_record`` and "
"``delete_record`` methods."
msgstr ""

#: ../../chapter-07.rst:4064
msgid ""
"If you do not need these methods you can speed up selects a lot by "
"setting the ``cacheable`` attribute:"
msgstr ""

#: ../../chapter-07.rst:4071
msgid ""
"When the ``cache`` argument is set but ``cacheable=False`` (default) only"
" the database results are cached, not the actual Rows object. When the "
"``cache`` argument is used in conjunction with ``cacheable=True`` the "
"entire Rows object is cached and this results in much faster caching:"
msgstr ""

#: ../../chapter-07.rst:4082
msgid "Self-Reference and aliases"
msgstr ""

#: ../../chapter-07.rst:4084
msgid ""
"It is possible to define tables with fields that refer to themselves, "
"here is an example:"
msgstr ""

#: ../../chapter-07.rst:4094
msgid ""
"Notice that the alternative notation of using a table object as field "
"type will fail in this case, because it uses a table before it is "
"defined:"
msgstr ""

#: ../../chapter-07.rst:4105
msgid ""
"In general ``db.tablename`` and ``'reference tablename'`` are equivalent "
"field types, but the latter is the only one allowed for self-references."
msgstr ""

#: ../../chapter-07.rst:4108
msgid ""
"When a table has a self-reference and you have to do join, for example to"
" select a person and its father, you need an alias for the table. In SQL "
"an alias is a temporary alternate name you can use to reference a "
"table/column into a query (or other SQL statement)."
msgstr ""

#: ../../chapter-07.rst:4113
msgid ""
"With py4web you can make an alias for a table using the ``with_alias`` "
"method. This works also for expressions, which means also for fields "
"since ``Field`` is derived from ``Expression``."
msgstr ""

#: ../../chapter-07.rst:4140
msgid ""
"Notice that we have chosen to make a distinction between: - “father_id”: "
"the field name used in the table “person”; - “father”: the alias we want "
"to use for the table referenced by the above field; this is communicated "
"to the database; - “Father”: the variable used by py4web to refer to that"
" alias."
msgstr ""

#: ../../chapter-07.rst:4146
msgid ""
"The difference is subtle, and there is nothing wrong in using the same "
"name for the three of them:"
msgstr ""

#: ../../chapter-07.rst:4171
msgid ""
"But it is important to have the distinction clear in order to build "
"correct queries."
msgstr ""

#: ../../chapter-07.rst:4175
msgid "Advanced features"
msgstr ""

#: ../../chapter-07.rst:4178
msgid "Table inheritance"
msgstr ""

#: ../../chapter-07.rst:4180
msgid ""
"It is possible to create a table that contains all the fields from "
"another table. It is sufficient to pass the other table in place of a "
"field to ``define_table``. For example"
msgstr ""

#: ../../chapter-07.rst:4191
msgid ""
"It is also possible to define a dummy table that is not stored in a "
"database in order to reuse it in multiple other places. For example:"
msgstr ""

#: ../../chapter-07.rst:4205
msgid "This example assumes that standard py4web authentication is enabled."
msgstr ""

#: ../../chapter-07.rst:4207
msgid ""
"Notice that if you use ``Auth`` py4web already creates one such table for"
" you:"
msgstr ""

#: ../../chapter-07.rst:4215
msgid ""
"When using table inheritance, if you want the inheriting table to inherit"
" validators, be sure to define the validators of the parent table before "
"defining the inheriting table."
msgstr ""

#: ../../chapter-07.rst:4220
msgid "``filter_in`` and ``filter_out``"
msgstr ""

#: ../../chapter-07.rst:4222
msgid ""
"It is possible to define a filter for each field to be called before a "
"value is inserted into the database for that field and after a value is "
"retrieved from the database."
msgstr ""

#: ../../chapter-07.rst:4226
msgid ""
"Imagine for example that you want to store a serializable Python data "
"structure in a field in the json format. Here is how it could be "
"accomplished:"
msgstr ""

#: ../../chapter-07.rst:4245
msgid ""
"Another way to accomplish the same is by using a Field of type "
"``SQLCustomType``, as discussed in next `Custom ``Field`` types "
"<#Custom_Field_Types>`__ section."
msgstr ""

#: ../../chapter-07.rst:4250
msgid "callbacks on record insert, delete and update"
msgstr ""

#: ../../chapter-07.rst:4252
msgid ""
"PY4WEB provides a mechanism to register callbacks to be called before "
"and/or after insert, update and delete of records."
msgstr ""

#: ../../chapter-07.rst:4255
msgid "Each table stores six lists of callbacks:"
msgstr ""

#: ../../chapter-07.rst:4266
msgid ""
"You can register a callback function by appending it to the corresponding"
" list. The caveat is that depending on the functionality, the callback "
"has different signature."
msgstr ""

#: ../../chapter-07.rst:4270
msgid "This is best explained via some examples."
msgstr ""

#: ../../chapter-07.rst:4298
msgid ""
"As you can see: - ``f`` gets passed the ``OpRow`` object with data for "
"insert or update. - ``i`` gets passed the id of the newly inserted "
"record. - ``s`` gets passed the ``Set`` object used for update or delete."
" ``OpRow`` is an helper object specialized in storing (field, value) "
"pairs, you can think of it as a normal dictionary that you can use even "
"with the syntax of attribute notation (that is ``f.name`` and "
"``f['name']`` are equivalent)."
msgstr ""

#: ../../chapter-07.rst:4306
msgid ""
"The return values of these callback should be ``None`` or ``False``. If "
"any of the ``_before_*`` callback returns a ``True`` value it will abort "
"the actual insert/update/delete operation."
msgstr ""

#: ../../chapter-07.rst:4310
msgid ""
"Some times a callback may need to perform an update in the same or a "
"different table and one wants to avoid firing other callbacks, which "
"could cause an infinite loop."
msgstr ""

#: ../../chapter-07.rst:4314
msgid ""
"For this purpose there the ``Set`` objects have an ``update_naive`` "
"method that works like ``update`` but ignores before and after callbacks."
msgstr ""

#: ../../chapter-07.rst:4319
msgid "Database cascades"
msgstr ""

#: ../../chapter-07.rst:4321
msgid ""
"Database schema can define relationships which trigger deletions of "
"related records, known as cascading. The DAL is not informed when a "
"record is deleted due to a cascade. So no \\*_delete callaback will ever "
"be called as conseguence of a cascade-deletion."
msgstr ""

#: ../../chapter-07.rst:4327
msgid "Record versioning"
msgstr ""

#: ../../chapter-07.rst:4329
msgid ""
"It is possible to ask py4web to save every copy of a record when the "
"record is individually modified. There are different ways to do it and it"
" can be done for all tables at once using the syntax:"
msgstr ""

#: ../../chapter-07.rst:4337
msgid ""
"this requires ``Auth``. It can also be done for each individual table as "
"discussed below."
msgstr ""

#: ../../chapter-07.rst:4340
msgid "Consider the following table:"
msgstr ""

#: ../../chapter-07.rst:4350
msgid ""
"Notice the hidden boolean field called ``is_active`` and defaulting to "
"True."
msgstr ""

#: ../../chapter-07.rst:4353
msgid ""
"We can tell py4web to create a new table (in the same or a different "
"database) and store all previous versions of each record in the table, "
"when modified."
msgstr ""

#: ../../chapter-07.rst:4357
msgid "This is done in the following way:"
msgstr ""

#: ../../chapter-07.rst:4363
msgid "or in a more verbose syntax:"
msgstr ""

#: ../../chapter-07.rst:4372
msgid ""
"The ``archive_db=db`` tells py4web to store the archive table in the same"
" database as the ``stored_item`` table. The ``archive_name`` sets the "
"name for the archive table. The archive table has the same fields as the "
"original table ``stored_item`` except that unique fields are no longer "
"unique (because it needs to store multiple versions) and has an extra "
"field which name is specified by ``current_record`` and which is a "
"reference to the current record in the ``stored_item`` table."
msgstr ""

#: ../../chapter-07.rst:4380
msgid ""
"When records are deleted, they are not really deleted. A deleted record "
"is copied in the ``stored_item_archive`` table (like when it is modified)"
" and the ``is_active`` field is set to False. By enabling record "
"versioning py4web sets a ``common_filter`` on this table that hides all "
"records in table ``stored_item`` where the ``is_active`` field is set to "
"False. The ``is_active`` parameter in the ``_enable_record_versioning`` "
"method allows to specify the name of the field used by the "
"``common_filter`` to determine if the field was deleted or not."
msgstr ""

#: ../../chapter-07.rst:4390
msgid ""
"``common_filter``\\ s will be discussed in next `Common filters "
"<#common_filters>`__ section."
msgstr ""

#: ../../chapter-07.rst:4394
msgid "Common fields and multi-tenancy"
msgstr ""

#: ../../chapter-07.rst:4396
msgid ""
"``db._common_fields`` is a list of fields that should belong to all the "
"tables. This list can also contain tables and it is understood as all "
"fields from the table."
msgstr ""

#: ../../chapter-07.rst:4400
msgid ""
"For example occasionally you find yourself in need to add a signature to "
"all your tables but the ``Auth`` tables. In this case, after you "
"``auth.define_tables()`` but before defining any other table, insert:"
msgstr ""

#: ../../chapter-07.rst:4408
msgid ""
"One field is special: ``request_tenant``, you can set a different name in"
" ``db._request_tenant``. This field does not exist but you can create it "
"and add it to any of your tables (or all of them):"
msgstr ""

#: ../../chapter-07.rst:4418
msgid ""
"For every table with such a field, all records for all queries are always"
" automatically filtered by:"
msgstr ""

#: ../../chapter-07.rst:4425
msgid ""
"and for every record inserted, this field is set to the default value. In"
" the example above we have chosen:"
msgstr ""

#: ../../chapter-07.rst:4432
msgid ""
"this means we have chosen to ask our app to filter all tables in all "
"queries with:"
msgstr ""

#: ../../chapter-07.rst:4439
msgid ""
"This simple trick allow us to turn any application into a multi-tenant "
"application. Even though we run one instance of the application and we "
"use one single database, when the application is accessed under two or "
"more domains the visitors will see different data depending on the domain"
" (in the example the domain name is retrieved from "
"``request.env.http_host``)."
msgstr ""

#: ../../chapter-07.rst:4446
msgid ""
"You can turn off multi tenancy filters using "
"``ignore_common_filters=True`` at ``Set`` creation time:"
msgstr ""

#: ../../chapter-07.rst:4454
msgid "Common filters"
msgstr ""

#: ../../chapter-07.rst:4456
msgid ""
"A common filter is a generalization of the above multi-tenancy idea. It "
"provides an easy way to prevent repeating of the same query. Consider for"
" example the following table:"
msgstr ""

#: ../../chapter-07.rst:4468
msgid ""
"Any select, delete or update in this table, will include only public blog"
" posts. The attribute can also be modified at runtime:"
msgstr ""

#: ../../chapter-07.rst:4475
msgid ""
"It serves both as a way to avoid repeating the "
"“db.blog_post.is_public==True” phrase in each blog post search, and also "
"as a security enhancement, that prevents you from forgetting to disallow "
"viewing of non-public posts."
msgstr ""

#: ../../chapter-07.rst:4480
msgid ""
"In case you actually do want items left out by the common filter (for "
"example, allowing the admin to see non-public posts), you can either "
"remove the filter:"
msgstr ""

#: ../../chapter-07.rst:4488
msgid "or ignore it:"
msgstr ""

#: ../../chapter-07.rst:4496
msgid "Note that common_filters are ignored by the appadmin interface."
msgstr ""

#: ../../chapter-07.rst:4499
msgid "Custom ``Field`` types"
msgstr ""

#: ../../chapter-07.rst:4501
msgid ""
"Aside for using ``filter_in`` and ``filter_out``, it is possible to "
"define new/custom field types. For example, suppose that you want to "
"define a custom type to store an IP address:"
msgstr ""

#: ../../chapter-07.rst:4546
msgid ""
"``SQLCustomType`` is a field type factory. Its ``type`` argument must be "
"one of the standard py4web types. It tells py4web how to treat the field "
"values at the py4web level. ``native`` is the type of the field as far as"
" the database is concerned. Allowed names depend on the database engine. "
"``encoder`` is an optional transformation function applied when the data "
"is stored and ``decoder`` is the optional reverse transformation "
"function."
msgstr ""

#: ../../chapter-07.rst:4554
msgid ""
"This feature is marked as experimental. In practice it has been in py4web"
" for a long time and it works but it can make the code not portable, for "
"example when the native type is database specific."
msgstr ""

#: ../../chapter-07.rst:4558
msgid "It does not work on Google App Engine NoSQL."
msgstr ""

#: ../../chapter-07.rst:4561
msgid "Using DAL without define tables"
msgstr ""

#: ../../chapter-07.rst:4563
msgid "The DAL can be used from any Python program simply by doing this:"
msgstr ""

#: ../../chapter-07.rst:4570
msgid ""
"i.e. import the DAL, connect and specify the folder which contains the "
".table files (the app/databases folder)."
msgstr ""

#: ../../chapter-07.rst:4573
msgid ""
"To access the data and its attributes we still have to define all the "
"tables we are going to access with ``db.define_table``."
msgstr ""

#: ../../chapter-07.rst:4576
msgid ""
"If we just need access to the data but not to the py4web table "
"attributes, we get away without re-defining the tables but simply asking "
"py4web to read the necessary info from the metadata in the .table files:"
msgstr ""

#: ../../chapter-07.rst:4585
msgid "This allows us to access any db.table without need to re-define it."
msgstr ""

#: ../../chapter-07.rst:4588
msgid "PostGIS, SpatiaLite, and MS Geo (experimental)"
msgstr ""

#: ../../chapter-07.rst:4590
msgid ""
"The DAL supports geographical APIs using PostGIS (for PostgreSQL), "
"SpatiaLite (for SQLite), and MSSQL and Spatial Extensions. This is a "
"feature that was sponsored by the Sahana project and implemented by Denes"
" Lengyel."
msgstr ""

#: ../../chapter-07.rst:4595
msgid ""
"DAL provides geometry and geography fields types and the following "
"functions:"
msgstr ""

#: ../../chapter-07.rst:4613
msgid "Here are some examples:"
msgstr ""

#: ../../chapter-07.rst:4621
msgid "Below we insert a point, a line, and a polygon:"
msgstr ""

#: ../../chapter-07.rst:4632
msgid "Notice that"
msgstr ""

#: ../../chapter-07.rst:4638
msgid ""
"Always returns the geometry data serialized as text. You can also do the "
"same more explicitly using ``st_astext()``:"
msgstr ""

#: ../../chapter-07.rst:4649
msgid ""
"You can ask for the native representation by using ``st_asgeojson()`` (in"
" PostGIS only):"
msgstr ""

#: ../../chapter-07.rst:4660
msgid ""
"(notice an array is a point, an array of arrays is a line, and an array "
"of array of arrays is a polygon)."
msgstr ""

#: ../../chapter-07.rst:4663
msgid "Here are example of how to use geographical functions:"
msgstr ""

#: ../../chapter-07.rst:4674
msgid "Computed distances can also be retrieved as floating point numbers:"
msgstr ""

#: ../../chapter-07.rst:4686
msgid "Copy data from one db into another"
msgstr ""

#: ../../chapter-07.rst:4688
msgid ""
"Consider the situation in which you have been using the following "
"database:"
msgstr ""

#: ../../chapter-07.rst:4695
msgid ""
"and you wish to move to another database using a different connection "
"string:"
msgstr ""

#: ../../chapter-07.rst:4702
msgid ""
"Before you switch, you want to move the data and rebuild all the metadata"
" for the new database. We assume the new database to exist but we also "
"assume it is empty."
msgstr ""

#: ../../chapter-07.rst:4706
msgid "PY4WEB provides a script that does this work for you:"
msgstr ""

#: ../../chapter-07.rst:4717
msgid ""
"After running the script you can simply switch the connection string in "
"the model and everything should work out of the box. The new data should "
"be there."
msgstr ""

#: ../../chapter-07.rst:4721
msgid ""
"This script provides various command line options that allows you to move"
" data from one application to another, move all tables or only some "
"tables, clear the data in the tables. For more info try:"
msgstr ""

#: ../../chapter-07.rst:4730
msgid "Note on new DAL and adapters"
msgstr ""

#: ../../chapter-07.rst:4732
msgid ""
"The source code of the Database Abstraction Layer was completely "
"rewritten in 2010. While it stays backward compatible, the rewrite made "
"it more modular and easier to extend. Here we explain the main logic."
msgstr ""

#: ../../chapter-07.rst:4736
msgid "The file “gluon/dal.py” defines, among other, the following classes."
msgstr ""

#: ../../chapter-07.rst:4752
msgid ""
"Their use has been explained in the previous sections, except for "
"``BaseAdapter``. When the methods of a ``Table`` or ``Set`` object need "
"to communicate with the database they delegate to methods of the adapter "
"the task to generate the SQL and or the function call."
msgstr ""

#: ../../chapter-07.rst:4763
msgid "calls"
msgstr ""

#: ../../chapter-07.rst:4769
msgid "which delegates the adapter by returning:"
msgstr ""

#: ../../chapter-07.rst:4775
msgid ""
"Here ``db.mytable._listify`` converts the dict of arguments into a list "
"of ``(field,value)`` and calls the ``insert`` method of the ``adapter``. "
"``db._adapter`` does more or less the following:"
msgstr ""

#: ../../chapter-07.rst:4784
msgid "where the first line builds the query and the second executes it."
msgstr ""

#: ../../chapter-07.rst:4786
msgid "``BaseAdapter`` defines the interface for all adapters."
msgstr ""

#: ../../chapter-07.rst:4788
msgid ""
"“gluon/dal.py” at the moment of writing this book, contains the following"
" adapters:"
msgstr ""

#: ../../chapter-07.rst:4821
msgid "which override the behavior of the ``BaseAdapter``."
msgstr ""

#: ../../chapter-07.rst:4823
msgid "Each adapter has more or less this structure:"
msgstr ""

#: ../../chapter-07.rst:4860
msgid ""
"Looking at the various adapters as example should be easy to write new "
"ones."
msgstr ""

#: ../../chapter-07.rst:4863
msgid "When ``db`` instance is created:"
msgstr ""

#: ../../chapter-07.rst:4869
msgid ""
"the prefix in the uri string defines the adapter. The mapping is defined "
"in the following dictionary also in “gluon/dal.py”:"
msgstr ""

#: ../../chapter-07.rst:4912
msgid "the uri string is then parsed in more detail by the adapter itself."
msgstr ""

#: ../../chapter-07.rst:4914
msgid "For any adapter you can replace the driver with a different one:"
msgstr ""

#: ../../chapter-07.rst:4922
msgid ""
"i.e. ``mysqldb`` has to be *that module* with a .connect() method. You "
"can specify optional driver arguments and adapter arguments:"
msgstr ""

#: ../../chapter-07.rst:4930
msgid "Gotchas"
msgstr ""

#: ../../chapter-07.rst:4935
msgid ""
"SQLite does not support dropping and altering columns. That means that "
"py4web migrations will work up to a point. If you delete a field from a "
"table, the column will remain in the database but will be invisible to "
"py4web. If you decide to reinstate the column, py4web will try re-create "
"it and fail. In this case you must set ``fake_migrate=True`` so that "
"metadata is rebuilt without attempting to add the column again. Also, for"
" the same reason, **SQLite** is not aware of any change of column type. "
"If you insert a number in a string field, it will be stored as string. If"
" you later change the model and replace the type “string” with type "
"“integer”, SQLite will continue to keep the number as a string and this "
"may cause problem when you try to extract the data."
msgstr ""

#: ../../chapter-07.rst:4947
msgid ""
"SQLite doesn’t have a boolean type. py4web internally maps booleans to a "
"1 character string, with ‘T’ and ‘F’ representing True and False. The DAL"
" handles this completely; the abstraction of a true boolean value works "
"well. But if you are updating the SQLite table with SQL directly, be "
"aware of the py4web implementation, and avoid using 0 and 1 values."
msgstr ""

#: ../../chapter-07.rst:4956
msgid ""
"MySQL does not support multiple ALTER TABLE within a single transaction. "
"This means that any migration process is broken into multiple commits. If"
" something happens that causes a failure it is possible to break a "
"migration (the py4web metadata are no longer in sync with the actual "
"table structure in the database). This is unfortunate but it can be "
"prevented (migrate one table at the time) or it can be fixed a posteriori"
" (revert the py4web model to what corresponds to the table structure in "
"database, set ``fake_migrate=True`` and after the metadata has been "
"rebuilt, set ``fake_migrate=False`` and migrate the table again)."
msgstr ""

#: ../../chapter-07.rst:4968
msgid "Google SQL"
msgstr ""

#: ../../chapter-07.rst:4970
msgid ""
"Google SQL has the same problems as MySQL and more. In particular table "
"metadata itself must be stored in the database in a table that is not "
"migrated by py4web. This is because Google App Engine has a read-only "
"file system. PY4WEB migrations in Google SQL combined with the MySQL "
"issue described above can result in metadata corruption. Again, this can "
"be prevented (by migrating the table at once and then setting "
"migrate=False so that the metadata table is not accessed any more) or it "
"can fixed a posteriori (by accessing the database using the Google "
"dashboard and deleting any corrupted entry from the table called "
"``py4web_filesystem``."
msgstr ""

#: ../../chapter-07.rst:4982
msgid "MSSQL (Microsoft SQL Server)"
msgstr ""

#: ../../chapter-07.rst:4984
msgid ""
"MSSQL < 2012 does not support the SQL OFFSET keyword. Therefore the "
"database cannot do pagination. When doing a ``limitby=(a, b)`` py4web "
"will fetch the first ``a + b`` rows and discard the first ``a``. This may"
" result in a considerable overhead when compared with other database "
"engines. If you’re using MSSQL >= 2005, the recommended prefix to use is "
"``mssql3://`` which provides a method to avoid the issue of fetching the "
"entire non-paginated resultset. If you’re on MSSQL >= 2012, use "
"``mssql4://`` that uses the ``OFFSET ... ROWS ... FETCH NEXT ... ROWS "
"ONLY`` construct to support natively pagination without performance hits "
"like other backends. The ``mssql://`` uri also enforces (for historical "
"reasons) the use of ``text`` columns, that are superseeded in more recent"
" versions (from 2005 onwards) by ``varchar(max)``. ``mssql3://`` and "
"``mssql4://`` should be used if you don’t want to face some limitations "
"of the - officially deprecated - ``text`` columns."
msgstr ""

#: ../../chapter-07.rst:5000
msgid ""
"MSSQL has problems with circular references in tables that have ONDELETE "
"CASCADE. This is an MSSQL bug and you work around it by setting the "
"ondelete attribute for all reference fields to “NO ACTION”. You can also "
"do it once and for all before you define tables:"
msgstr ""

#: ../../chapter-07.rst:5012
msgid ""
"MSSQL also has problems with arguments passed to the DISTINCT keyword and"
" therefore while this works,"
msgstr ""

#: ../../chapter-07.rst:5019
msgid "this does not"
msgstr ""

#: ../../chapter-07.rst:5028
msgid ""
"Oracle also does not support pagination. It does not support neither the "
"OFFSET nor the LIMIT keywords. PY4WEB achieves pagination by translating "
"a ``db(...).select(limitby=(a, b))`` into a complex three-way nested "
"select (as suggested by official Oracle documentation). This works for "
"simple select but may break for complex selects involving aliased fields "
"and or joins."
msgstr ""

#: ../../chapter-07.rst:5036
msgid "Google NoSQL (Datastore)"
msgstr ""

#: ../../chapter-07.rst:5038
msgid ""
"Google NoSQL (Datastore) does not allow joins, left joins, aggregates, "
"expression, OR involving more than one table, the ‘like’ operator "
"searches in “text” fields."
msgstr ""

#: ../../chapter-07.rst:5042
msgid ""
"Transactions are limited and not provided automatically by py4web (you "
"need to use the Google API ``run_in_transaction`` which you can look up "
"in the Google App Engine documentation online)."
msgstr ""

#: ../../chapter-07.rst:5046
msgid ""
"Google also limits the number of records you can retrieve in each one "
"query (1000 at the time of writing). On the Google datastore record IDs "
"are integer but they are not sequential. While on SQL the “list:string” "
"type is mapped into a “text” type, on the Google Datastore it is mapped "
"into a ``ListStringProperty``. Similarly “list:integer” and "
"“list:reference” are mapped into ``ListProperty``. This makes searches "
"for content inside these fields types more efficient on Google NoSQL than"
" on SQL databases."
msgstr ""

