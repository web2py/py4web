# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, BSDv3 License
# This file is distributed under the same license as the py4web package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: py4web 1.20201127.1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-12-02 20:25-0300\n"
"PO-Revision-Date: 2020-12-08 10:39-0300\n"
"Last-Translator: potranslator 1.1.5\n"
"Language-Team: \n"
"Language: pt\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Translated-By: potranslator 1.1.5\n"
"X-Generator: Poedit 2.4.2\n"

#: ../../chapter-07.rst:3
msgid "The database abstraction layer (DAL)"
msgstr "A camada de abstracção de banco de dados (DAL)"

#: ../../chapter-07.rst:6
msgid "Dependencies"
msgstr "Dependências"

#: ../../chapter-07.rst:8
msgid ""
"py4web comes with a Database Abstraction Layer (DAL), an API that maps "
"Python objects into database objects such as queries, tables, and records. "
"The DAL dynamically generates the SQL in real time using the specified "
"dialect for the database back end, so that you do not have to write SQL "
"code or learn different SQL dialects (the term SQL is used generically), "
"and the application will be portable among different types of databases. A "
"partial list of supported databases is show in the table below. Please "
"check on the py4web web site and mailing list for more recent adapters. "
"Google NoSQL is treated as a particular case."
msgstr ""
"py4web vem com uma camada de abstração de banco de dados (DAL), uma API que "
"mapeia Python objetos no banco de dados objetos, como consultas, tabelas e "
"registros. A DAL gera dinamicamente o SQL em tempo real usando o dialeto "
"especificado para o back-end de banco de dados, de modo que você não "
"precisa de código SQL gravação ou aprender diferentes dialetos SQL (SQL "
"termo é utilizado genericamente), ea aplicação irá ser portátil entre "
"diferentes tipos de bancos de dados. Uma lista parcial de bases de dados "
"suportadas é mostrado na tabela abaixo. Por favor, verifique no site py4web "
"e lista de endereços para adaptadores mais recentes. Google NoSQL é tratado "
"como um case particular."

#: ../../chapter-07.rst:18
msgid ""
"The Gotchas section at the end of this chapter has some more information "
"about specific databases."
msgstr ""
"A seção Gotchas no final deste capítulo tem mais algumas informações sobre "
"bancos de dados específicos."

#: ../../chapter-07.rst:21
msgid ""
"The Windows binary distribution works out of the box with SQLite, MSSQL, "
"PostgreSQL and MySQL. The Mac binary distribution works out of the box with "
"SQLite. To use any other database back-end, run from the source "
"distribution and install the appropriate driver for the required back end."
msgstr ""
"A distribuição binária Windows funciona fora da caixa com SQLite, MSSQL, "
"PostgreSQL e MySQL. A distribuição binária Mac funciona fora da caixa com "
"SQLite. Para usar qualquer outro banco de dados back-end, executado a "
"partir da distribuição fonte e instalar o driver apropriado para o back-end "
"necessário."

#: ../../chapter-07.rst:27
msgid ""
"Once the proper driver is installed, start py4web from source, and it will "
"find the driver. Here is a list of the drivers py4web can use:"
msgstr ""
"Uma vez que o driver apropriado está instalado, inicie py4web a partir da "
"fonte, e vai encontrar o driver. Aqui está uma lista de drivers py4web pode "
"usar:"

#: ../../chapter-07.rst:31
msgid "database"
msgstr "banco de dados"

#: ../../chapter-07.rst:31
msgid "drivers (source)"
msgstr "motoristas (fonte)"

#: ../../chapter-07.rst:33 ../../chapter-07.rst:4933
msgid "SQLite"
msgstr "SQLite"

#: ../../chapter-07.rst:33
msgid "sqlite3 or pysqlite2 or zxJDBC (on Jython)"
msgstr "sqlite3 ou pySqlite2 ou zxJDBC (em Jython)"

#: ../../chapter-07.rst:34
msgid "PostgreSQL"
msgstr "PostgreSQL"

#: ../../chapter-07.rst:34
msgid "psycopg2 or zxJDBC (on Jython)"
msgstr "psycopg2 ou zxJDBC (em Jython)"

#: ../../chapter-07.rst:35 ../../chapter-07.rst:4954
msgid "MySQL"
msgstr "MySQL"

#: ../../chapter-07.rst:35
msgid "pymysql or MySQLdb"
msgstr "pymysql ou MySQLdb"

#: ../../chapter-07.rst:36 ../../chapter-07.rst:5026
msgid "Oracle"
msgstr "Oráculo"

#: ../../chapter-07.rst:36
msgid "cx_Oracle"
msgstr "cx_Oracle"

#: ../../chapter-07.rst:37
msgid "MSSQL"
msgstr "MSSQL"

#: ../../chapter-07.rst:37
msgid "pyodbc or pypyodbc"
msgstr "pyodbc ou pypyodbc"

#: ../../chapter-07.rst:38
msgid "FireBird"
msgstr "FireBird"

#: ../../chapter-07.rst:38
msgid "kinterbasdb or fdb or pyodbc"
msgstr "KInterbasDB ou FDB ou pyodbc"

#: ../../chapter-07.rst:39
msgid "DB2"
msgstr "DB2"

#: ../../chapter-07.rst:39 ../../chapter-07.rst:44
msgid "pyodbc"
msgstr "pyodbc"

#: ../../chapter-07.rst:40
msgid "Informix"
msgstr "Informix"

#: ../../chapter-07.rst:40
msgid "informixdb"
msgstr "informixdb"

#: ../../chapter-07.rst:41
msgid "Ingres"
msgstr "Ingres"

#: ../../chapter-07.rst:41
msgid "ingresdbi"
msgstr "ingresdbi"

#: ../../chapter-07.rst:42
msgid "Cubrid"
msgstr "CUBRID"

#: ../../chapter-07.rst:42
msgid "cubriddb"
msgstr "cubriddb"

#: ../../chapter-07.rst:43
msgid "Sybase"
msgstr "Sybase"

#: ../../chapter-07.rst:44
msgid "Teradata"
msgstr "Teradata"

#: ../../chapter-07.rst:45
msgid "SAPDB"
msgstr "SAPDB"

#: ../../chapter-07.rst:45
msgid "sapdb"
msgstr "sapdb"

#: ../../chapter-07.rst:46
msgid "MongoDB"
msgstr "MongoDB"

#: ../../chapter-07.rst:46
msgid "pymongo"
msgstr "pymongo"

#: ../../chapter-07.rst:47
msgid "IMAP"
msgstr "IMAP"

#: ../../chapter-07.rst:47
msgid "imaplib"
msgstr "imaplib"

#: ../../chapter-07.rst:50
msgid ""
"``sqlite3``, ``pymysql``, and ``imaplib`` ship with py4web. Support of "
"MongoDB is experimental. The IMAP option allows to use DAL to access IMAP."
msgstr ""
"`` Sqlite3``, `` pymysql``, e `` navio imaplib`` com py4web. Apoio do "
"MongoDB é experimental. A opção IMAP permite usar DAL para acesso IMAP."

#: ../../chapter-07.rst:55
msgid "The DAL: A quick tour"
msgstr "A DAL: Um rápido passeio"

#: ../../chapter-07.rst:57
msgid "py4web defines the following classes that make up the DAL:"
msgstr "define py4web as seguintes classes que compõem o DAL:"

#: ../../chapter-07.rst:59
msgid "The **DAL** object represents a database connection. For example:"
msgstr ""
"O ** DAL ** objeto representa uma conexão de banco de dados. Por exemplo:"

#: ../../chapter-07.rst:65
msgid ""
"**Table** represents a database table. You do not directly instantiate "
"Table; instead, ``DAL.define_table`` instantiates it."
msgstr ""
"** Tabela ** representa uma tabela de banco de dados. Você faz Tabela não "
"diretamente instanciar; em vez disso, `` DAL.define_table`` instancia-lo."

#: ../../chapter-07.rst:72
msgid "The most important methods of a Table are:"
msgstr "Os métodos mais importantes de uma tabela são:"

#: ../../chapter-07.rst:74
msgid "``insert``, ``truncate``, ``drop``, and ``import_from_csv_file``."
msgstr "`` Insert``, `` truncate``, `` drop``, e `` import_from_csv_file``."

#: ../../chapter-07.rst:76
msgid ""
"**Field** represents a database field. It can be instantiated and passed as "
"an argument to ``DAL.define_table``."
msgstr ""
"** Campo ** representa um campo de banco de dados. Ele pode ser instanciado "
"e passado como um argumento para `` DAL.define_table``."

#: ../../chapter-07.rst:79
msgid ""
"**DAL Rows** is the object returned by a database select. It can be thought "
"of as a list of ``Row`` rows:"
msgstr ""
"** Linhas DAL ** é o objeto retornado por um banco de dados selecionado. "
"Ele pode ser pensado como uma lista de `` linhas row``:"

#: ../../chapter-07.rst:86
msgid "**Row** contains field values."
msgstr "** Row ** contém valores de campo."

#: ../../chapter-07.rst:93
msgid "**Query** is an object that represents a SQL “where” clause:"
msgstr "** consulta ** é um objeto que representa um SQL cláusula “where”:"

#: ../../chapter-07.rst:99
msgid ""
"**Set** is an object that represents a set of records. Its most important "
"methods are ``count``, ``select``, ``update``, and ``delete``. For example:"
msgstr ""
"** Set ** é um objeto que representa um conjunto de registros. Seus métodos "
"mais importantes são `` count``, `` SELECT``, `` update``, e `` DELETE``. "
"Por exemplo:"

#: ../../chapter-07.rst:110
msgid ""
"**Expression** is something like an ``orderby`` or ``groupby`` expression. "
"The Field class is derived from the Expression. Here is an example."
msgstr ""
"** Expressão ** é algo como um `` orderby`` ou `` expressão groupby``. A "
"classe campo é derivado da expressão. Aqui está um exemplo."

#: ../../chapter-07.rst:120
msgid "Using the DAL “stand-alone”"
msgstr "Usando o DAL “stand-alone”"

#: ../../chapter-07.rst:122
msgid "The DAL can be used in a non-py4web environment via"
msgstr "A DAL pode ser usado num ambiente não-py4web através"

#: ../../chapter-07.rst:129
msgid "DAL constructor"
msgstr "Construtor DAL"

#: ../../chapter-07.rst:131
msgid "Basic use:"
msgstr "Uso básico:"

#: ../../chapter-07.rst:137
msgid ""
"The database is now connected and the connection is stored in the global "
"variable ``db``."
msgstr ""
"O banco de dados agora está conectado e a conexão é armazenado na variável "
"global `` db``."

#: ../../chapter-07.rst:140
msgid "At any time you can retrieve the connection string."
msgstr "A qualquer momento você pode recuperar a string de conexão."

#: ../../chapter-07.rst:147
msgid "and the database name"
msgstr "e o nome do banco"

#: ../../chapter-07.rst:154
msgid ""
"The connection string is called a ``_uri`` because it is an instance of a "
"Uniform Resource Identifier."
msgstr ""
"A seqüência de conexão é chamado de `` _uri`` porque é uma instância de um "
"Uniform Resource Identifier."

#: ../../chapter-07.rst:157
msgid ""
"The DAL allows multiple connections with the same database or with "
"different databases, even databases of different types. For now, we will "
"assume the presence of a single database since this is the most common "
"situation."
msgstr ""
"A DAL permite várias ligações com o mesmo banco de dados ou com diferentes "
"bases de dados, mesmo bases de dados de diferentes tipos. Por enquanto, "
"vamos supor a presença de um único banco de dados uma vez que esta é a "
"situação mais comum."

#: ../../chapter-07.rst:163
msgid "DAL signature"
msgstr "Assinatura da DAL"

#: ../../chapter-07.rst:193
msgid "Connection strings (the uri parameter)"
msgstr "Strings de conexão (o parâmetro uri)"

#: ../../chapter-07.rst:195
msgid ""
"A connection with the database is established by creating an instance of "
"the DAL object:"
msgstr ""
"Uma ligação com o banco de dados é estabelecida através da criação de uma "
"instância do objecto DAL:"

#: ../../chapter-07.rst:202
msgid ""
"``db`` is not a keyword; it is a local variable that stores the connection "
"object ``DAL``. You are free to give it a different name. The constructor "
"of ``DAL`` requires a single argument, the connection string. The "
"connection string is the only py4web code that depends on a specific back-"
"end database. Here are examples of connection strings for specific types of "
"supported back-end databases (in all cases, we assume the database is "
"running from localhost on its default port and is named “test”):"
msgstr ""
"`` Db`` não é uma palavra-chave; é uma variável local que armazena o objeto "
"de conexão `` DAL``. Você é livre para dar-lhe um nome diferente. O "
"construtor de `` DAL`` requer um único argumento, a string de conexão. A "
"seqüência de conexão é o único código py4web que depende de um banco de "
"dados específico back-end. Aqui estão alguns exemplos de strings de conexão "
"para tipos específicos de bancos de dados de back-end suportados (em todos "
"os cases, assumimos o banco de dados está sendo executado a partir de "
"localhost na sua porta padrão e é chamado de “teste”):"

#: ../../chapter-07.rst:212
msgid "**SQLite**"
msgstr "** ** SQLite"

#: ../../chapter-07.rst:212
msgid "``sqlite://storage.sqlite``"
msgstr "`` SQLite: // storage.sqlite``"

#: ../../chapter-07.rst:214 ../../chapter-07.rst:456
msgid "**MySQL**"
msgstr "** ** MySQL"

#: ../../chapter-07.rst:214
msgid "``mysql://username:pa ssword@localhost/test?set_encoding=utf8mb4``"
msgstr ""
"`` Mysql: // username:? Pa ssword @ localhost / test set_encoding = "
"utf8mb4``"

#: ../../chapter-07.rst:217 ../../chapter-07.rst:454
msgid "**PostgreSQL**"
msgstr "** ** PostgreSQL"

#: ../../chapter-07.rst:217
msgid "``p ostgres://username:password@localhost/test``"
msgstr "`` P ostgres: // username: password @ localhost / test``"

#: ../../chapter-07.rst:220
msgid "**MSSQL (legacy)**"
msgstr "** MSSQL (legado) **"

#: ../../chapter-07.rst:220
msgid "``mssql://username:password@localhost/test``"
msgstr "`` Mssql: // username: password @ localhost / test``"

#: ../../chapter-07.rst:222
msgid "**MSSQL (>=2005)**"
msgstr "** MSSQL (> = 2005) **"

#: ../../chapter-07.rst:222
msgid "` `mssql3://username:password@localhost/test``"
msgstr "`` Mssql3: // username: password @ localhost / test``"

#: ../../chapter-07.rst:225
msgid "**MSSQL (>=2012)**"
msgstr "** MSSQL (> = 2012) **"

#: ../../chapter-07.rst:225
msgid "` `mssql4://username:password@localhost/test``"
msgstr "`` Mssql4: // username: password @ localhost / test``"

#: ../../chapter-07.rst:228 ../../chapter-07.rst:457
msgid "**FireBird**"
msgstr "** ** FireBird"

#: ../../chapter-07.rst:228
msgid "``f irebird://username:password@localhost/test``"
msgstr "`` Irebird f: // username: password @ localhost / test``"

#: ../../chapter-07.rst:231 ../../chapter-07.rst:459
msgid "**Oracle**"
msgstr "**Oráculo**"

#: ../../chapter-07.rst:231
msgid "``oracle://username/password@test``"
msgstr "`` Oracle: // username / password @ test``"

#: ../../chapter-07.rst:233
msgid "**DB2**"
msgstr "** ** DB2"

#: ../../chapter-07.rst:233
msgid "``db2://username:password@test``"
msgstr "`` Db2: // username: password @ test``"

#: ../../chapter-07.rst:235
msgid "**Ingres**"
msgstr "** ** Ingres"

#: ../../chapter-07.rst:235
msgid "` `ingres://username:password@localhost/test``"
msgstr "`` Ingres: // username: password @ localhost / test``"

#: ../../chapter-07.rst:238
msgid "**Sybase**"
msgstr "** ** Sybase"

#: ../../chapter-07.rst:238
msgid "` `sybase://username:password@localhost/test``"
msgstr "`` Sybase: // username: password @ localhost / test``"

#: ../../chapter-07.rst:241
msgid "**Informix**"
msgstr "** ** Informix"

#: ../../chapter-07.rst:241
msgid "``informix://username:password@test``"
msgstr "`` Informix: // username: password @ test``"

#: ../../chapter-07.rst:243
msgid "**Teradata**"
msgstr "** ** Teradata"

#: ../../chapter-07.rst:243
msgid "``teradata ://DSN=dsn;UID=user;PWD=pass;DATABASE=test``"
msgstr ""
"`` Teradata: // DSN = dsn; UID = utilizador; PWD = pass; DATABASE = test``"

#: ../../chapter-07.rst:246
msgid "**Cubrid**"
msgstr "** ** CUBRID"

#: ../../chapter-07.rst:246
msgid "` `cubrid://username:password@localhost/test``"
msgstr "`` CUBRID: // username: password @ localhost / test``"

#: ../../chapter-07.rst:249
msgid "**SAPDB**"
msgstr "** ** SAPDB"

#: ../../chapter-07.rst:249
msgid "``sapdb://username:password@localhost/test``"
msgstr "`` Sapdb: // username: password @ localhost / test``"

#: ../../chapter-07.rst:251
msgid "**IMAP**"
msgstr "** ** IMAP"

#: ../../chapter-07.rst:251
msgid "``imap://user:password@server:port``"
msgstr "`` Imap: // utilizador: senha @ servidor: port``"

#: ../../chapter-07.rst:253
msgid "**MongoDB**"
msgstr "** ** MongoDB"

#: ../../chapter-07.rst:253
msgid "`` mongodb://username:password@localhost/test``"
msgstr "`` Mongodb: // username: password @ localhost / test``"

#: ../../chapter-07.rst:256
msgid "**Google/SQL**"
msgstr "** Google / SQL **"

#: ../../chapter-07.rst:256
msgid "``google:sql://project:instance/database``"
msgstr "`` Google: sql: // projecto: instance / database``"

#: ../../chapter-07.rst:258
msgid "**Google/NoSQL**"
msgstr "** Google / NoSQL **"

#: ../../chapter-07.rst:258
msgid "``google:datastore``"
msgstr "`` Google: datastore``"

#: ../../chapter-07.rst:260
msgid "**Google/NoSQL/NDB**"
msgstr "** Google / NoSQL / NDB **"

#: ../../chapter-07.rst:260
msgid "``google:datastore+ndb``"
msgstr "`` Google: armazenamento de dados + ndb``"

#: ../../chapter-07.rst:263
msgid ""
"Notice that in SQLite the database consists of a single file. If it does "
"not exist, it is created. This file is locked every time it is accessed. In "
"the case of MySQL, PostgreSQL, MSSQL, FireBird, Oracle, DB2, Ingres and "
"Informix the database “test” must be created outside py4web. Once the "
"connection is established, py4web will create, alter, and drop tables "
"appropriately."
msgstr ""
"Observe que em SQLite banco de dados consiste em um único arquivo. Se ele "
"não existir, ele será criado. Este arquivo está bloqueado cada vez que é "
"acessado. No case do MySQL, PostgreSQL, MSSQL, Firebird, Oracle, DB2, "
"Ingres e Informix o “teste” de banco de dados deve ser criado py4web fora. "
"Uma vez que a conexão é estabelecida, py4web irá criar, alterar e eliminar "
"tabelas de forma adequada."

#: ../../chapter-07.rst:270
msgid ""
"In the MySQL connection string, the ``?set_encoding=utf8mb4`` at the end "
"sets the encoding to UTF-8 and avoids an ``Invalid utf8 character string:`` "
"error on Unicode characters that consist of four bytes, as by default, "
"MySQL can only handle Unicode characters that consist of one to three bytes."
msgstr ""
"? Na seqüência de conexão MySQL, o `` set_encoding = utf8mb4`` no final "
"define a codificação para UTF-8 e evita um `` inválido seqüência de "
"caracteres utf8: `` erro em caracteres Unicode que consistem em quatro "
"bytes, como por padrão , MySQL só pode lidar com caracteres Unicode que "
"consistem de uma de três bytes."

#: ../../chapter-07.rst:276
msgid ""
"In the Google/NoSQL case the ``+ndb`` option turns on NDB. NDB uses a "
"Memcache buffer to read data that is accessed often. This is completely "
"automatic and done at the datastore level, not at the py4web level."
msgstr ""
"No case Google / NoSQL os `` + voltas opção ndb`` no NDB. NDB usa um buffer "
"Memcache para ler dados que são acessados ​​frequentemente. Isto é "
"completamente automático e feito no nível de armazenamento de dados, não no "
"nível py4web."

#: ../../chapter-07.rst:280
msgid ""
"It is also possible to set the connection string to ``None``. In this case "
"DAL will not connect to any back-end database, but the API can still be "
"accessed for testing."
msgstr ""
"Também é possível definir a seqüência de conexão para `` None``. Neste case "
"DAL não vai conectar a qualquer banco de dados back-end, mas a API ainda "
"pode ser acessado para testar."

#: ../../chapter-07.rst:284
msgid ""
"Some times you may need to generate SQL as if you had a connection but "
"without actually connecting to the database. This can be done with"
msgstr ""
"Algumas vezes pode ser necessário para gerar SQL como se você tivesse uma "
"conexão, mas sem realmente conectar ao banco de dados. Isso pode ser feito "
"com"

#: ../../chapter-07.rst:291
msgid ""
"In this case you will be able to call ``_select``, ``_insert``, "
"``_update``, and ``_delete`` to generate SQL but not call ``select``, "
"``insert``, ``update``, and ``delete``. In most of the cases you can use "
"``do_connect=False`` even without having the required database drivers."
msgstr ""
"Neste case, você será capaz de chamar `` _select``, `` _insert``, `` "
"_update``, e `` _delete`` para gerar SQL, mas não chamar `` SELECT``, `` "
"insert`` , `` update``, e `` DELETE``. Na maioria dos cases, você pode usar "
"`` do_connect = False`` mesmo sem ter os drivers de banco de dados "
"necessárias."

#: ../../chapter-07.rst:296
msgid ""
"Notice that by default py4web uses utf8 character encoding for databases. "
"If you work with existing databases that behave differently, you have to "
"change it with the optional parameter ``db_codec`` like"
msgstr ""
"Observe que, por padrão py4web usos utf8 codificação de caracteres para "
"bancos de dados. Se você trabalha com bancos de dados que se comportam de "
"forma diferente existente, você tem que mudá-lo com o parâmetro opcional `` "
"db_codec`` como"

#: ../../chapter-07.rst:304
msgid "Otherwise you’ll get UnicodeDecodeError tickets."
msgstr "Caso contrário, você vai ter bilhetes UnicodeDecodeError."

#: ../../chapter-07.rst:307
msgid "Connection pooling"
msgstr "O pool de conexões"

#: ../../chapter-07.rst:309
msgid ""
"A common argument of the DAL constructor is the ``pool_size``; it defaults "
"to zero."
msgstr ""
"Um argumento comum do construtor DAL é a `` pool_size``; o padrão é zero."

#: ../../chapter-07.rst:312
msgid ""
"As it is rather slow to establish a new database connection for each "
"request, py4web implements a mechanism for connection pooling. Once a "
"connection is established and the page has been served and the transaction "
"completed, the connection is not closed but goes into a pool. When the next "
"http request arrives, py4web tries to recycle a connection from the pool "
"and use that for the new transaction. If there are no available connections "
"in the pool, a new connection is established."
msgstr ""
"Como é bastante lento para estabelecer uma nova conexão com o banco para "
"cada solicitação, implementos py4web um mecanismo para o pool de conexão. "
"Uma vez que uma conexão é estabelecida e a página foi servido ea transação "
"concluída, a conexão não é fechada, mas vai para uma piscina. Quando o "
"próximo pedido http chega, py4web tenta reciclar uma conexão do pool e uso "
"que para a nova transação. Se não há conexões disponíveis na piscina, uma "
"nova conexão é estabelecida."

#: ../../chapter-07.rst:321
msgid ""
"When py4web starts, the pool is always empty. The pool grows up to the "
"minimum between the value of ``pool_size`` and the max number of concurrent "
"requests. This means that if ``pool_size=10`` but our server never receives "
"more than 5 concurrent requests, then the actual pool size will only grow "
"to 5. If ``pool_size=0`` then connection pooling is not used."
msgstr ""
"Quando py4web começa, a piscina é sempre vazio. A piscina cresce até o "
"mínimo entre o valor de `` pool_size`` e o número máximo de solicitações "
"simultâneas. Isto significa que se `` POOL_SIZE = 10`` mas o nosso servidor "
"nunca recebe mais de 5 solicitações simultâneas, em seguida, o tamanho real "
"piscina só vai crescer a 5. Se `` POOL_SIZE = 0`` então o pool de conexão "
"não é usada."

#: ../../chapter-07.rst:328
msgid ""
"Connections in the pools are shared sequentially among threads, in the "
"sense that they may be used by two different but not simultaneous threads. "
"There is only one pool for each py4web process."
msgstr ""
"Conexões nas piscinas são compartilhados sequencialmente entre threads, no "
"sentido de que eles podem ser usados ​​por dois tópicos diferentes, mas não "
"simultâneas. Há apenas uma piscina para cada processo py4web."

#: ../../chapter-07.rst:332
msgid ""
"The ``pool_size`` parameter is ignored by SQLite and Google App Engine. "
"Connection pooling is ignored for SQLite, since it would not yield any "
"benefit."
msgstr ""
"O parâmetro `` pool_size`` é ignorado pelo SQLite e Google App Engine. pool "
"de conexão é ignorado para SQLite, uma vez que não daria qualquer benefício."

#: ../../chapter-07.rst:337
msgid "Connection failures (attempts parameter)"
msgstr "Falhas de conexão (parâmetro tentativas)"

#: ../../chapter-07.rst:339
msgid ""
"If py4web fails to connect to the database it waits 1 second and by default "
"tries again up to 5 times before declaring a failure. In case of connection "
"pooling it is possible that a pooled connection that stays open but unused "
"for some time is closed by the database end. Thanks to the retry feature "
"py4web tries to re-establish these dropped connections. The number of "
"attempts is set via the attempts parameter."
msgstr ""
"Se py4web não consegue se conectar ao banco de dados que espera 1 segundo e "
"por tentativas padrão novamente até 5 vezes antes de declarar um fracasso. "
"No case do pool de conexão, é possível que uma conexão em pool que "
"permanece aberta, mas sem uso por algum tempo está fechado até o final de "
"banco de dados. Graças à py4web recurso repetição tenta restabelecer essas "
"ligações interrompidas. O número de tentativas é definido através do "
"parâmetro tentativas."

#: ../../chapter-07.rst:347
msgid "Lazy Tables"
msgstr "Tabelas preguiçosos"

#: ../../chapter-07.rst:349
msgid ""
"setting ``lazy_tables = True`` provides a major performance boost. See "
"below: `lazy tables <#lazy_tables>`__"
msgstr ""
"ajuste `` lazy_tables = True`` fornece um grande aumento de desempenho. "
"Veja abaixo: `tabelas preguiçosos <#lazy_tables>` __"

#: ../../chapter-07.rst:353
msgid "Model-less applications"
msgstr "Aplicativos de modelo-less"

#: ../../chapter-07.rst:355
msgid ""
"Using py4web’s model directory for your application models is very "
"convenient and productive. With lazy tables and conditional models, "
"performance is usually acceptable even for large applications. Many "
"experienced developers use this in production environments."
msgstr ""
"Usando o diretório model de py4web para seus modelos de aplicação é muito "
"conveniente e produtiva. Com mesas preguiçosos e modelos condicionais, o "
"desempenho é normalmente aceitável, mesmo para grandes aplicações. Muitos "
"desenvolvedores experientes usar isso em ambientes de produção."

#: ../../chapter-07.rst:360
msgid ""
"However, it is possible to define DAL tables on demand inside controller "
"functions or modules. This may make sense when the number or complexity of "
"table definitions overloads the use of lazy tables and conditional models."
msgstr ""
"No entanto, é possível definir tabelas DAL sob demanda dentro de funções de "
"controlador ou módulos. Isso pode fazer sentido quando o número ou a "
"complexidade das definições de tabela sobrecarrega o uso de tabelas "
"preguiçosos e modelos condicionais."

#: ../../chapter-07.rst:365
msgid ""
"This is referred to as “model-less” development by the py4web community. It "
"means less use of the automatic execution of Python files in the model "
"directory. It does not imply abandoning the concept of models, views and "
"controllers."
msgstr ""
"Isto é referido como “modelo-less” desenvolvimento pela comunidade py4web. "
"Isso significa menos uso da execução automática de arquivos Python no "
"diretório model. Isso não implica o abandono do conceito de modelos, "
"visualizações e controladores."

#: ../../chapter-07.rst:370
msgid ""
"PY4WEB’s auto-execution of Python code inside the model directory does this "
"for you:"
msgstr ""
"A auto-execução de código Python do PY4WEB  dentro do diretório model faz "
"isso para você:"

#: ../../chapter-07.rst:373
msgid "models are run automatically every time a request is processed"
msgstr ""
"modelos são executados automaticamente cada vez que um pedido é processado"

#: ../../chapter-07.rst:374
msgid "models access py4web’s global scope."
msgstr "modelos acessar escopo global do py4web."

#: ../../chapter-07.rst:376
msgid ""
"Models also make for useful interactive shell sessions when py4web is "
"started with the -M commandline option."
msgstr ""
"Modelos também para fazer sessões de shell interativo úteis quando py4web é "
"iniciado com a opção -M comando."

#: ../../chapter-07.rst:379
msgid ""
"Also, remember maintainability: other py4web developers expect to find "
"model definitions in the model directory."
msgstr ""
"Além disso, lembre manutenção: outros desenvolvedores py4web esperar "
"encontrar definições de modelo no diretório de modelo."

#: ../../chapter-07.rst:382
msgid ""
"To use the “model-less” approach, you take responsibility for doing these "
"two housekeeping tasks. You call the table definitions when you need them, "
"and provide necessary access passed as parameter."
msgstr ""
"Para usar o “-modelo menos” abordagem, você assumir a responsabilidade de "
"fazer essas duas tarefas domésticas. Você chama as definições de tabela "
"quando você precisar deles, e proporcionar o acesso necessário passado como "
"parâmetro."

#: ../../chapter-07.rst:386
msgid ""
"For example, a typical model-less application may leave the definitions of "
"the database connection objects in the model file, but define the tables on "
"demand per controller function."
msgstr ""
"Por exemplo, uma aplicação típica modelo de menos pode deixar as definições "
"dos objetos de conexão de banco de dados no arquivo de modelo, mas definir "
"as tabelas na demanda por função de controlador."

#: ../../chapter-07.rst:390
msgid ""
"The typical case is to move the table definitions to a module file (a "
"Python file saved in the modules directory)."
msgstr ""
"O case típico é mover as definições de tabela para um arquivo de módulo (um "
"arquivo Python salvos no diretório de módulos)."

#: ../../chapter-07.rst:393
msgid ""
"If the function to define a set of tables is called "
"``define_employee_tables()`` in a module called “table_setup.py”, your "
"controller that wants to refer to the tables related to employee records in "
"order to make an SQLFORM needs to call the ``define_employee_tables()`` "
"function before accessing any tables. The ``define_employee_tables()`` "
"function needs to access the database connection object in order to define "
"tables. You need to pass the db object to the ``define_employee_tables()`` "
"(as mentioned above)."
msgstr ""
"Se a função de definir um conjunto de tabelas é chamado `` "
"define_employee_tables () `` em um módulo chamado “table_setup.py”, seu "
"controlador que quer consulte as tabelas relacionadas a registros de "
"funcionários, a fim de fazer uma SQLFORM precisa chamar os `` "
"define_employee_tables () função `` antes de acessar qualquer tabela. Os `` "
"define_employee_tables () `` necessidades de função para aceder ao objecto "
"de ligação da banco de dados, a fim de definir tabelas. É necessário passar "
"o objecto db para os `` define_employee_tables () `` (como mencionado "
"acima)."

#: ../../chapter-07.rst:403
msgid "Replicated databases"
msgstr "Bancos de dados replicados"

#: ../../chapter-07.rst:405
msgid ""
"The first argument of ``DAL(...)`` can be a list of URIs. In this case "
"py4web tries to connect to each of them. The main purpose for this is to "
"deal with multiple database servers and distribute the workload among "
"them). Here is a typical use case:"
msgstr ""
"O primeiro argumento de `` DAL (...) `` pode ser uma lista de URIs. Neste "
"case py4web tenta se conectar a cada um deles. O objetivo principal para "
"isso é que lidar com vários servidores de banco de dados e distribuir a "
"carga de trabalho entre eles). Aqui está um case de uso típico:"

#: ../../chapter-07.rst:414
msgid ""
"In this case the DAL tries to connect to the first and, on failure, it will "
"try the second and the third. This can also be used to distribute load in a "
"database master-slave configuration."
msgstr ""
"Neste case, as tentativas DAL para conectar-se a primeira e, em case de "
"falha, ele vai tentar o segundo eo terceiro. Isto também pode ser utilizado "
"para distribuir a carga em uma configuração de banco de dados mestre-"
"escravo."

#: ../../chapter-07.rst:419
msgid "Reserved keywords"
msgstr "Palavras-chave reservadas"

#: ../../chapter-07.rst:421
msgid ""
"``check_reserved`` tells the constructor to check table names and column "
"names against reserved SQL keywords in target back-end databases. "
"``check_reserved`` defaults to None."
msgstr ""
"`` Check_reserved`` diz o construtor para verificar nomes de tabela e nomes "
"de coluna contra palavras-chave reservada SQL em bancos de dados de back-"
"end-alvo. `` padrões check_reserved`` a nenhum."

#: ../../chapter-07.rst:425
msgid ""
"This is a list of strings that contain the database back-end adapter names."
msgstr ""
"Esta é uma lista de strings que contêm os nomes de adaptador de banco de "
"dados back-end."

#: ../../chapter-07.rst:428
msgid ""
"The adapter name is the same as used in the DAL connection string. So if "
"you want to check against PostgreSQL and MSSQL then your connection string "
"would look as follows:"
msgstr ""
"O nome do adaptador é o mesmo que o utilizado na strings de ligação DAL. "
"Então, se você quiser verificar contra PostgreSQL e MSSQL, em seguida, sua "
"seqüência de conexão ficaria da seguinte forma:"

#: ../../chapter-07.rst:436
msgid "The DAL will scan the keywords in the same order as of the list."
msgstr "A DAL irá analisar as palavras-chave na mesma ordem da lista."

#: ../../chapter-07.rst:438
msgid ""
"There are two extra options “all” and “common”. If you specify all, it will "
"check against all known SQL keywords. If you specify common, it will only "
"check against common SQL keywords such as ``SELECT``, ``INSERT``, "
"``UPDATE``, etc."
msgstr ""
"Existem duas opções extras “todos” e “comum”. Se você especificar tudo, ele "
"irá verificar contra todas as palavras-chave SQL conhecidos. Se você "
"especificar comum, ele só irá verificar contra palavras-chave SQL comuns, "
"tais como `` SELECT``, `` INSERT``, `` update``, etc."

#: ../../chapter-07.rst:443
msgid ""
"For supported back-ends you may also specify if you would like to check "
"against the non-reserved SQL keywords as well. In this case you would "
"append ``_nonreserved`` to the name. For example:"
msgstr ""
"Para back-ends suportados você também pode especificar se você gostaria de "
"verificar contra as palavras-chave SQL não reservados bem. Neste case, você "
"poderia acrescentar `` _nonreserved`` ao nome. Por exemplo:"

#: ../../chapter-07.rst:451
msgid "The following database backends support reserved words checking."
msgstr ""
"Os seguintes backends de banco de dados suportar palavras reservadas "
"verificação."

#: ../../chapter-07.rst:454
msgid "``postgres(_nonreserved)``"
msgstr "`` Postgres (_nonreserved) ``"

#: ../../chapter-07.rst:456
msgid "``mysql``"
msgstr "`` Mysql``"

#: ../../chapter-07.rst:457
msgid "``firebird(_nonreserved)``"
msgstr "`` Firebird (_nonreserved) ``"

#: ../../chapter-07.rst:458
msgid "**MSSQL**"
msgstr "** ** MSSQL"

#: ../../chapter-07.rst:458
msgid "``mssql``"
msgstr "`` mssql``"

#: ../../chapter-07.rst:459
msgid "``oracle``"
msgstr "`` oracle``"

#: ../../chapter-07.rst:463
msgid "Database quoting and case settings"
msgstr "Configurações de quoting e case e do  banco de dados"

#: ../../chapter-07.rst:465
msgid "Quoting of SQL entities are enabled by default in DAL, that is:"
msgstr "Citando de entidades SQL são ativadas por padrão em DAL, isto é:"

#: ../../chapter-07.rst:467
msgid "``entity_quoting = True``"
msgstr "`` Entity_quoting = True``"

#: ../../chapter-07.rst:469
msgid ""
"This way identifiers are automatically quoted in SQL generated by DAL. At "
"SQL level keywords and unquoted identifiers are case insensitive, thus "
"quoting an SQL identifier makes it case sensitive."
msgstr ""
"Desta forma, os identificadores são automaticamente citado em SQL gerado "
"pelo DAL. No SQL palavras-chave de nível e identificadores não cotadas são "
"maiúsculas e minúsculas, quoting assim uma SQL identificador torna "
"maiúsculas de minúsculas."

#: ../../chapter-07.rst:473
msgid ""
"Notice that unquoted identifiers should always be folded to lower case by "
"the back-end engine according to SQL standard but not all engines are "
"compliant with this (for example PostgreSQL default folding is upper case)."
msgstr ""
"Note-se que os identificadores não indicada deve sempre ser dobrado para "
"minúsculas pelo motor de back-end acordo com a norma SQL, mas nem todos os "
"motores estão em conformidade com o presente (por exemplo de dobragem "
"PostgreSQL padrão é maiúsculas)."

#: ../../chapter-07.rst:478
msgid "By default DAL ignores field case too, to change this use:"
msgstr "Por DAL padrão ignora case de campo também, para mudar este uso:"

#: ../../chapter-07.rst:480
msgid "``ignore_field_case = False``"
msgstr "`` Ignore_field_case = False``"

#: ../../chapter-07.rst:482
msgid ""
"To be sure of using the same names in python and in the DB schema, you must "
"arrange for both settings above. Here is an example:"
msgstr ""
"Para ter certeza de usar os mesmos nomes em python e no esquema DB, você "
"deve organizar para ambas as configurações acima. Aqui está um exemplo:"

#: ../../chapter-07.rst:492
msgid "Making a secure connection"
msgstr "Fazendo uma conexão segura"

#: ../../chapter-07.rst:494
msgid ""
"Sometimes it is necessary (and advised) to connect to your database using "
"secure connection, especially if your database is not on the same server as "
"your application. In this case you need to pass additional parameters to "
"the database driver. You should refer to database driver documentation for "
"details."
msgstr ""
"Às vezes é necessário (e recomendado) para se conectar ao seu banco de "
"dados usando conexão segura, especialmente se o seu banco de dados não está "
"no mesmo servidor como a sua aplicação. Neste case, você precisa passar "
"parâmetros adicionais para o driver de banco de dados. Você deve consultar "
"a documentação do driver de banco de dados para obter detalhes."

#: ../../chapter-07.rst:500
msgid "For PostgreSQL with psycopg2 it should look like this:"
msgstr "Para PostgreSQL com psycopg2 ele deve ser parecido com isto:"

#: ../../chapter-07.rst:508
msgid ""
"where parameters ``sslrootcert``, ``sslcert`` and ``sslkey`` should contain "
"the full path to the files. You should refer to PostgreSQL documentation on "
"how to configure PostgreSQL server to accept secure connections."
msgstr ""
"onde os parâmetros `` sslrootcert``, `` sslcert`` e `` sslkey`` deve conter "
"o caminho completo para os arquivos. Você deve consultar a documentação do "
"PostgreSQL sobre como configurar o servidor PostgreSQL para aceitar "
"conexões seguras."

#: ../../chapter-07.rst:514
msgid "Other DAL constructor parameters"
msgstr "Outros parâmetros do construtor DAL"

#: ../../chapter-07.rst:517
msgid "Database folder location"
msgstr "Local de pasta do banco de dados"

#: ../../chapter-07.rst:519
msgid ""
"``folder`` sets the place where migration files will be created (see "
"`Migrations <#table_migrations>`__ section in this chapter for details). It "
"is also used for SQLite databases. Automatically set within py4web. Set a "
"path when using DAL outside py4web."
msgstr ""
"`` Folder`` define o lugar onde migração arquivos serão criados (ver "
"`Migrações <#table_migrations>` __ seção neste capítulo para mais "
"detalhes). Ele também é usado para bancos de dados SQLite. Definida "
"automaticamente entre py4web. Definir um caminho ao utilizar DAL fora "
"py4web."

#: ../../chapter-07.rst:525
msgid "Default migration settings"
msgstr "Configurações padrão de migração"

#: ../../chapter-07.rst:527
msgid ""
"The DAL constructor migration settings are booleans affecting defaults and "
"global behaviour."
msgstr ""
"As configurações de migração construtor DAL são booleans que afetam padrões "
"e comportamento global."

#: ../../chapter-07.rst:530
msgid "``migrate = True`` sets default migrate behavior for all tables"
msgstr ""
"`` Migrar = True`` define o comportamento de migração padrão para todas as "
"tabelas"

#: ../../chapter-07.rst:532
msgid ""
"``fake_migrate = False`` sets default fake_migrate behavior for all tables"
msgstr ""
"`` Fake_migrate = False`` define o comportamento fake_migrate padrão para "
"todas as tabelas"

#: ../../chapter-07.rst:535
msgid "``migrate_enabled = True`` If set to False disables ALL migrations"
msgstr ""
"`` Migrate_enabled = True`` se definido como desativa falsas todas as "
"migrações"

#: ../../chapter-07.rst:537
msgid "``fake_migrate_all = False`` If set to True fake migrates ALL tables"
msgstr ""
"`` Fake_migrate_all = False`` Se definido como falso migra Verdadeiros "
"todas as tabelas"

#: ../../chapter-07.rst:540
msgid "Experiment with the py4web shell"
msgstr "Experimentar com o shell py4web"

#: ../../chapter-07.rst:542
msgid ""
"You can experiment with the DAL API using the py4web shell, that is "
"available using the ``shell`` command (read more in `Chapter 1 "
"<#chapter-01#command_line_options>`__)."
msgstr ""
"Você pode experimentar com a API DAL usando o shell py4web, que está "
"disponível usando o comando `` shell`` (leia mais no `Capítulo 1 <# "
"capítulo 01 # command_line_options>` __)."

#: ../../chapter-07.rst:546
msgid ""
"You need to choose an application to run the shell on, mind that database "
"changes may be persistent. So be carefull and do NOT exitate to create a "
"new application for doing testing instead of tampering with an existing one."
msgstr ""
"Você precisa escolher uma aplicação para executar o shell on, mente que as "
"mudanças de banco de dados pode ser persistente. Portanto, tenha cuidado e "
"NÃO exitate para criar uma nova aplicação para fazer testes em vez de "
"adulteração de um já existente."

#: ../../chapter-07.rst:551
msgid ""
"Start by creating a connection. For the sake of example, you can use "
"SQLite. Nothing in this discussion changes when you change the back-end "
"engine."
msgstr ""
"Comece por criar uma conexão. Por uma questão de exemplo, você pode usar "
"SQLite. Nada nesta discussão muda quando você alterar o motor de back-end."

#: ../../chapter-07.rst:555
msgid ""
"Note that most of the code snippets that contain the python prompt ``>>>`` "
"are directly executable via a plain shell, which you can obtain using ``-"
"PS`` command line options."
msgstr ""
"Note-se que a maior parte dos trechos de código que contêm o python prompt "
"de `` >>> `` estão diretamente executável através de um shell simples, que "
"você pode obter usando `` opções de linha de comando -PS``."

#: ../../chapter-07.rst:560
msgid "Table constructor"
msgstr "Construtor Table"

#: ../../chapter-07.rst:562
msgid "Tables are defined in the DAL via ``define_table``."
msgstr "As tabelas são definidos na DAL via `` define_table``."

#: ../../chapter-07.rst:565
msgid "define_table signature"
msgstr "assinatura define_table"

#: ../../chapter-07.rst:567
msgid "The signature for define_table method is:"
msgstr "A assinatura para o método define_table é:"

#: ../../chapter-07.rst:573
msgid ""
"It accepts a mandatory table name and an optional number of ``Field`` "
"instances (even none). You can also pass a ``Table`` (or subclass) object "
"instead of a ``Field`` one, this clones and adds all the fields (but the "
"“id”) to the defining table. Other optional keyword args are: ``rname``, "
"``redefine``, ``common_filter``, ``fake_migrate``, ``fields``, ``format``, "
"``migrate``, ``on_define``, ``plural``, ``polymodel``, ``primarykey``, "
"``sequence_name``, ``singular``, ``table_class``, and ``trigger_name``, "
"which are discussed below."
msgstr ""
"Ele aceita um nome de tabela de preenchimento obrigatório e um número "
"opcional de `` cases Field`` (mesmo nenhum). Você também pode passar um "
"Table`` objeto (ou subclasse) `` em vez de um `` Field`` um, este clones e "
"adiciona todos os campos (mas o “id”) com a tabela de definição. Outros "
"argumentos de palavra-chave opcionais são: `` rname``, `` redefine``, `` "
"common_filter``, `` fake_migrate``, `` fields``, `` format``, `` migrate``, "
"`` on_define``, `` plural``, `` polymodel``, `` primarykey``, `` "
"sequence_name``, `` singular``, `` table_class``, e `` trigger_name``, que "
"são discutidos abaixo."

#: ../../chapter-07.rst:582 ../../chapter-07.rst:4757
msgid "For example:"
msgstr "Por exemplo:"

#: ../../chapter-07.rst:589
msgid ""
"It defines, stores and returns a ``Table`` object called “person” "
"containing a field (column) “name”. This object can also be accessed via "
"``db.person``, so you do not need to catch the value returned by "
"define_table."
msgstr ""
"Ele define, lojas e retorna um objeto `` Table`` chamado “pessoa” contendo "
"um campo (coluna) “nome”. Este objeto também pode ser acessado via `` db."
"person``, assim você não precisa pegar o valor retornado pelo define_table."

#: ../../chapter-07.rst:595
msgid "``id``: Notes about the primary key"
msgstr "`` Id``: Notas sobre a chave primária"

#: ../../chapter-07.rst:597
msgid ""
"Do not declare a field called “id”, because one is created by py4web "
"anyway. Every table has a field called “id” by default. It is an auto-"
"increment integer field (usually starting at 1) used for cross-reference "
"and for making every record unique, so “id” is a primary key. (Note: the id "
"counter starting at 1 is back-end specific. For example, this does not "
"apply to the Google App Engine NoSQL.)"
msgstr ""
"Não declare um campo chamado “id”, porque um é criado por py4web de "
"qualquer maneira. Cada tabela tem um campo chamado “id” por padrão. É um "
"campo inteiro de auto-incremento (geralmente a partir de 1) utilizados para "
"referência cruzada e para fazer cada registro original, assim que “id” é "
"uma chave primária. (Nota: o contador id a partir de 1 é específico back-"
"end Por exemplo, isto não se aplica ao Google App Engine NoSQL..)"

#: ../../chapter-07.rst:604
msgid ""
"Optionally you can define a field of ``type='id'`` and py4web will use this "
"field as auto-increment id field. This is not recommended except when "
"accessing legacy database tables which have a primary key under a different "
"name. With some limitation, you can also use different primary keys using "
"the ``primarykey`` parameter."
msgstr ""
"Opcionalmente, você pode definir um campo de 'type =' id'`` `e py4web usará "
"este campo como campo id auto-incremento. Isso não é recomendado, exceto "
"quando acessar as tabelas de banco de dados legado que têm uma chave "
"primária com um nome diferente. Com alguma limitação, você também pode usar "
"diferentes chaves primárias usando o parâmetro `` primarykey``."

#: ../../chapter-07.rst:611
msgid "``plural`` and ``singular``"
msgstr "`` `` Plural`` e singular``"

#: ../../chapter-07.rst:613
msgid ""
"As pydal is a general DAL, it includes plural and singular attributes to "
"refer to the table names so that external elements can use the proper name "
"for a table. A use case is in web2py with Smartgrid objects with references "
"to external tables."
msgstr ""
"Como pydal é uma DAL geral, ele inclui atributos singular e plural para se "
"referir aos nomes de tabela para que os elementos externos podem usar o "
"nome apropriado para uma mesa. Um case de uso está em web2py com objetos "
"SmartGrid com referências a tabelas externas."

#: ../../chapter-07.rst:619
msgid "``redefine``"
msgstr "`` Redefine``"

#: ../../chapter-07.rst:621
msgid ""
"Tables can be defined only once but you can force py4web to redefine an "
"existing table:"
msgstr ""
"As tabelas podem ser definidas apenas uma vez, mas você pode forçar py4web "
"redefinir uma tabela existente:"

#: ../../chapter-07.rst:629
msgid "The redefinition may trigger a migration if table definition changes."
msgstr "A redefinição pode provocar uma migração se definição tabela muda."

#: ../../chapter-07.rst:632
msgid "``format``: Record representation"
msgstr "`` Format``: representação da ficha"

#: ../../chapter-07.rst:634
msgid ""
"It is optional but recommended to specify a format representation for "
"records with the ``format`` parameter."
msgstr ""
"É opcional, mas recomendado para especificar uma representação formato para "
"registros com o parâmetro `` format``."

#: ../../chapter-07.rst:641
msgid "or"
msgstr "ou"

#: ../../chapter-07.rst:647
msgid "or even more complex ones using a function:"
msgstr "ou mesmo os mais complexos usando uma função:"

#: ../../chapter-07.rst:654
msgid ""
"The format attribute will be used for two purposes: - To represent "
"referenced records in select/option drop-downs. - To set the ``db."
"othertable.otherfield.represent`` attribute for all fields referencing this "
"table. This means that the ``Form`` constructor will not show references by "
"id but will use the preferred format representation instead."
msgstr ""
"O atributo formato será usado para duas finalidades: - Para representar "
"registros referenciados em select / opção menus suspensos. - Para definir o "
"atributo `` db.othertable.otherfield.represent`` para todos os campos que "
"referenciam esta tabela. Isto significa que o `` construtor Form`` não vai "
"mostrar referências de ID mas vai usar a representação formato preferido "
"vez."

#: ../../chapter-07.rst:662
msgid "``rname``: Real name"
msgstr "`` Rname``: nome real"

#: ../../chapter-07.rst:664
msgid ""
"``rname`` sets a database backend name for the table. This makes the py4web "
"table name an alias, and ``rname`` is the real name used when constructing "
"the query for the backend. To illustrate just one use, ``rname`` can be "
"used to provide MSSQL fully qualified table names accessing tables "
"belonging to other databases on the server: ``rname = 'db1.dbo.table1'``:"
"python"
msgstr ""
"`` Rname`` define um nome de back-end de banco de dados para a tabela. Isso "
"faz com que o nome da tabela py4web um alias, e `` rname`` é o verdadeiro "
"nome usado ao construir a consulta para o backend. Para ilustrar apenas um "
"uso, `` rname`` pode ser usado para fornecer MSSQL nomes de tabela "
"totalmente qualificado acessar as tabelas pertencentes a outras bases de "
"dados no servidor: `` rname = 'db1.dbo.table1'``: python"

#: ../../chapter-07.rst:672
msgid "``primarykey``: Support for legacy tables"
msgstr "`` Primarykey``: Suporte para tabelas legadas"

#: ../../chapter-07.rst:674
msgid ""
"``primarykey`` helps support legacy tables with existing primary keys, even "
"multi-part. See `Legacy databases and keyed tables <#LegacyDatabases>`__ "
"section in this chapter."
msgstr ""
"`` Primarykey`` ajuda tabelas legadas de apoio com chaves primárias "
"existentes, até mesmo multi-parte. Veja `bancos de dados legados e tabelas "
"com chave <#LegacyDatabases>` __ neste capítulo."

#: ../../chapter-07.rst:679
msgid "``migrate``, ``fake_migrate``"
msgstr "`` Migrate``, `` fake_migrate``"

#: ../../chapter-07.rst:681
msgid ""
"``migrate`` sets migration options for the table. Refer to `Migrations "
"<#table_migrations>`__ section in this chapter for details."
msgstr ""
"`` Migrate`` define migração opções para a mesa. Consulte `Migrações "
"<#table_migrations>` __ seção neste capítulo para obter detalhes."

#: ../../chapter-07.rst:685
msgid "``table_class``"
msgstr "`` Table_class``"

#: ../../chapter-07.rst:687
msgid ""
"If you define your own Table class as a sub-class of pydal.objects.Table, "
"you can provide it here; this allows you to extend and override methods. "
"Example:"
msgstr ""
"Se você definir sua própria classe Table como uma sub-classe de pydal."
"objects.Table, você pode fornecê-la aqui; isso permite-lhe ampliar e "
"métodos de substituição. Exemplo:"

#: ../../chapter-07.rst:701
msgid "``sequence_name``"
msgstr "`` Sequence_name``"

#: ../../chapter-07.rst:703
msgid ""
"The name of a custom table sequence (if supported by the database). Can "
"create a SEQUENCE (starting at 1 and incrementing by 1) or use this for "
"legacy tables with custom sequences."
msgstr ""
"O nome de uma seqüência tabela personalizada (se suportado pelo banco de "
"dados). Pode criar uma seqüência (a partir de 1 e incrementando por 1) ou "
"usar isso para tabelas legadas com seqüências personalizadas."

#: ../../chapter-07.rst:707
msgid ""
"Note that when necessary, py4web will create sequences automatically by "
"default."
msgstr ""
"Observe que, quando necessário, py4web vai criar seqüências automaticamente "
"por padrão."

#: ../../chapter-07.rst:711
msgid "``trigger_name``"
msgstr "`` Trigger_name``"

#: ../../chapter-07.rst:713
msgid ""
"Relates to ``sequence_name``. Relevant for some backends which do not "
"support auto-increment numeric fields."
msgstr ""
"Refere-se a `` sequence_name``. Relevante para alguns backends que não "
"suportam campos numéricos auto-incremento."

#: ../../chapter-07.rst:717
msgid "``polymodel``"
msgstr "`` polymodel``"

#: ../../chapter-07.rst:719
msgid "For Google App Engine"
msgstr "Para o Google App Engine"

#: ../../chapter-07.rst:722
msgid "``on_define``"
msgstr "`` On_define``"

#: ../../chapter-07.rst:724
msgid ""
"``on_define`` is a callback triggered when a lazy_table is instantiated, "
"although it is called anyway if the table is not lazy. This allows dynamic "
"changes to the table without losing the advantages of delayed instantiation."
msgstr ""
"`` On_define`` é uma chamada de retorno acionado quando um lazy_table é "
"instanciado, embora ela é chamada de qualquer maneira, se a tabela não é "
"preguiçoso. Isso permite que mudanças dinâmicas para a mesa sem perder as "
"vantagens de instanciação adiada."

#: ../../chapter-07.rst:729
msgid "Example:"
msgstr "Exemplo:"

#: ../../chapter-07.rst:741
msgid ""
"Note this example shows how to use ``on_define`` but it is not actually "
"necessary. The simple ``requires`` values could be added to the Field "
"definitions and the table would still be lazy. However, ``requires`` which "
"take a Set object as the first argument, such as IS_IN_DB, will make a "
"query like ``db.sometable.somefield == some_value`` which would cause "
"``sometable`` to be defined early. This is the situation saved by "
"``on_define``."
msgstr ""
"Nota Este exemplo mostra como usar `` on_define`` mas não é realmente "
"necessário. O simples `` valores requires`` poderiam ser adicionados às "
"definições de campo ea mesa ainda seria preguiçoso. No entanto, `` "
"requires`` que tomar um objeto definido como o primeiro argumento, como "
"IS_IN_DB, vai fazer uma consulta como `` db.sometable.somefield == "
"some_value`` que causaria `` sometable`` a ser definido no início . Esta é "
"a situação salvos por `` on_define``."

#: ../../chapter-07.rst:750
msgid "Lazy Tables, a major performance boost"
msgstr "Tabelas de descanso, um grande aumento de desempenho"

#: ../../chapter-07.rst:752
msgid ""
"py4web models are executed before controllers, so all tables are defined at "
"every request. Not all tables are needed to handle each request, so it is "
"possible that some of the time spent defining tables is wasted. Conditional "
"models (see `Model-less applications <#model_less_applications>`__) can "
"help, but py4web offers a big performance boost via lazy_tables. This "
"feature means that table creation is deferred until the table is actually "
"referenced. Enabling lazy tables is made when initialising a database via "
"the DAL constructor. It requires setting the lazy_tables parameter: "
"``DAL(..., lazy_tables=True)``:python This is one of the most significant "
"response-time performance boosts in py4web."
msgstr ""
"modelos py4web são executados antes de controladores, por isso, todas as "
"tabelas são definidas em cada solicitação. Nem todas as tabelas são "
"necessários para lidar com cada pedido, por isso é possível que algum do "
"tempo gasto definindo tabelas é desperdiçado. modelos condicionais (veja "
"`Model-menos aplicações <#model_less_applications>` __) pode ajudar, mas "
"ofertas py4web um grande aumento de desempenho através lazy_tables. Este "
"meio de recursos que a criação da tabela é adiada até que a tabela é "
"realmente referenciado. Permitindo tabelas preguiçosos é feita quando "
"inicializar um banco de dados via o construtor DAL. Ele requer definir os "
"lazy_tables parâmetro: `` DAL (..., lazy_tables = True) ``: python Este é "
"um dos impulsos mais significativos de desempenho em tempo de resposta em "
"py4web."

#: ../../chapter-07.rst:765
msgid "Adding attributes to fields and tables"
msgstr "Adicionando atributos para campos e tabelas"

#: ../../chapter-07.rst:767
msgid ""
"If you need to add custom attributes to fields, you can simply do this: "
"``db.table.field.extra = {}``"
msgstr ""
"Se você precisa adicionar atributos personalizados aos campos, você pode "
"simplesmente fazer isso: `` db.table.field.extra = {} ``"

#: ../../chapter-07.rst:770
msgid ""
"“extra” is not a keyword ; it’s a custom attributes now attached to the "
"field object. You can do it with tables too but they must be preceded by an "
"underscore to avoid naming conflicts with fields:"
msgstr ""
"“Extra” não é uma palavra-chave; é um atributos personalizados agora "
"ligados ao objeto de campo. Você pode fazê-lo com mesas também, mas eles "
"devem ser precedidos por um sublinhado para evitar conflitos de nomes com "
"campos:"

#: ../../chapter-07.rst:774
msgid "``db.table._extra = {}``:python"
msgstr "`` Db.table._extra = {} ``: pitão"

#: ../../chapter-07.rst:777
msgid "Field constructor"
msgstr "Construtor Field"

#: ../../chapter-07.rst:779
msgid "These are the default values of a Field constructor:"
msgstr "Estes são os valores padrão de um construtor de campo:"

#: ../../chapter-07.rst:793
msgid ""
"where DEFAULT is a special value used to allow the value None for a "
"parameter."
msgstr ""
"onde padrão é um valor especial usado para permitir que o valor Nenhum para "
"um parâmetro."

#: ../../chapter-07.rst:796
msgid ""
"Not all of them are relevant for every field. ``length`` is relevant only "
"for fields of type “string”. ``uploadfield``, ``authorize``, and "
"``autodelete`` are relevant only for fields of type “upload”. ``ondelete`` "
"is relevant only for fields of type “reference” and “upload”."
msgstr ""
"Nem todos eles são relevantes para todos os campos. `` Length`` é relevante "
"apenas para campos do tipo “string”. `` Uploadfield``, `` authorize``, e `` "
"autodelete`` são relevantes apenas para campos do tipo “Upload”. `` "
"Ondelete`` é relevante apenas para campos do tipo “referência” e “Upload”."

#: ../../chapter-07.rst:802
msgid ""
"``length`` sets the maximum length of a “string”, “password” or “upload” "
"field. If ``length`` is not specified a default value is used but the "
"default value is not guaranteed to be backward compatible. *To avoid "
"unwanted migrations on upgrades, we recommend that you always specify the "
"length for string, password and upload fields.*"
msgstr ""
"`` Length`` define o comprimento máximo de uma “string”, “password” ou "
"campo “Upload”. Se `` length`` não for especificado um valor padrão é "
"usado, mas o valor padrão não é garantido para ser compatível. * Para "
"evitar migrações indesejadas em upgrades, recomendamos que você sempre "
"especificar o comprimento de campos de cordas, senha e upload. *"

#: ../../chapter-07.rst:808
msgid ""
"``default`` sets the default value for the field. The default value is used "
"when performing an insert if a value is not explicitly specified. It is "
"also used to pre-populate forms built from the table using ``Form``. Note, "
"rather than being a fixed value, the default can instead be a function "
"(including a lambda function) that returns a value of the appropriate type "
"for the field. In that case, the function is called once for each record "
"inserted, even when multiple records are inserted in a single transaction."
msgstr ""
"`` Default`` define o valor padrão para o campo. O valor padrão é utilizada "
"quando se realiza uma inserção se um valor não for especificado "
"explicitamente. É também usado para formas construídas a partir da tabela "
"usando `` Form``-preencher previamente. Note, em vez de ser um valor fixo, "
"o padrão em vez disso pode ser uma função (incluindo uma função lambda) que "
"retorna um valor do tipo apropriado para o campo. Nesse case, a função é "
"chamada uma vez para cada registro inserido, mesmo quando vários registros "
"são inseridos em uma única transação."

#: ../../chapter-07.rst:816
msgid ""
"``required`` tells the DAL that no insert should be allowed on this table "
"if a value for this field is not explicitly specified."
msgstr ""
"`` Required`` conta a DAL que nenhuma inserção deve ser permitido nesta "
"tabela se um valor para este campo não é especificado explicitamente."

#: ../../chapter-07.rst:818
msgid ""
"``requires`` is a validator or a list of validators. This is not used by "
"the DAL, but it is used by ``Form``. The default validators for the given "
"types are shown in the next section."
msgstr ""
"`` Requires`` é um validador ou uma lista de validadores. Isto não é usado "
"pelo DAL, mas ele é usado por `` Form``. Os validadores predefinidos para "
"os tipos de dados são mostrados na próxima seção."

#: ../../chapter-07.rst:824
msgid ""
"Notice that while ``requires=...`` is enforced at the level of forms, "
"``required=True`` is enforced at the level of the DAL (insert). In "
"addition, ``notnull``, ``unique`` and ``ondelete`` are enforced at the "
"level of the database. While they sometimes may seem redundant, it is "
"important to maintain the distinction when programming with the DAL."
msgstr ""
"Note-se que enquanto `` requer = ... `` é aplicada ao nível de formas, `` "
"required = True`` é aplicada ao nível da DAL (inserção). Além disso, `` "
"notnull``, `` `` unique`` e ondelete`` são aplicadas ao nível da banco de "
"dados. Enquanto eles, por vezes, pode parecer redundante, é importante "
"manter a distinção ao programar com o DAL."

#: ../../chapter-07.rst:831
msgid ""
"``rname`` provides the field with a “real name”, a name for the field known "
"to the database adapter; when the field is used, it is the rname value "
"which is sent to the database. The py4web name for the field is then "
"effectively an alias."
msgstr ""
"`` Rname`` fornece o campo com um “nome real”, um nome para o campo "
"conhecido para o adaptador de banco de dados; quando o campo é usado, ele é "
"o valor rname que é enviado para o banco de dados. O nome py4web para o "
"campo é então efetivamente um alias."

#: ../../chapter-07.rst:836
msgid ""
"``ondelete`` translates into the “ON DELETE” SQL statement. By default it "
"is set to “CASCADE”. This tells the database that when it deletes a record, "
"it should also delete all records that refer to it. To disable this "
"feature, set ``ondelete`` to “NO ACTION” or “SET NULL”."
msgstr ""
"`` Ondelete`` traduz na “ON DELETE” instrução SQL. Por padrão, ele é "
"definido como “em cascata”. Isso diz ao banco de dados que quando se exclui "
"um registro, ele também deve excluir todos os registros que se referem a "
"ele. Para desativar este recurso, conjunto de `` ondelete`` a “nenhuma "
"acção” ou “NULL SET”."

#: ../../chapter-07.rst:842
msgid ""
"``notnull=True`` translates into the “NOT NULL” SQL statement. It prevents "
"the database from inserting null values for the field."
msgstr ""
"`` Notnull = True`` se traduz na “NOT NULL” instrução SQL. Ela impede que a "
"banco de dados a partir da inserção de valores nulos para o campo."

#: ../../chapter-07.rst:845
msgid ""
"``unique=True`` translates into the “UNIQUE” SQL statement and it makes "
"sure that values of this field are unique within the table. It is enforced "
"at the database level."
msgstr ""
"`` Unique = True`` se traduz na instrução SQL “único” e ele garante que os "
"valores deste campo são exclusivos dentro da tabela. Ela é aplicada no "
"nível de banco de dados."

#: ../../chapter-07.rst:849
msgid ""
"``uploadfield`` applies only to fields of type “upload”. A field of type "
"“upload” stores the name of a file saved somewhere else, by default on the "
"filesystem under the application “uploads/” folder. If ``uploadfield`` is "
"set to True, then the file is stored in a blob field within the same table "
"and the value of ``uploadfield`` is the name of the blob field. This will "
"be discussed in more detail later in the *More on uploads* section in this "
"chapter."
msgstr ""
"`` Uploadfield`` só se aplica aos campos do tipo “Upload”. Um campo de "
"lojas do tipo “Carregar” o nome de um arquivo salvo em outro lugar, por "
"padrão no sistema de arquivos na pasta “uploads /” aplicação. Se `` "
"uploadfield`` é definida como True, em seguida, o arquivo é armazenado em "
"um campo blob dentro da mesma tabela eo valor de `` uploadfield`` é o nome "
"do campo blob. Isso será discutido com mais detalhes posteriormente no * "
"Mais informações sobre os envios * neste capítulo."

#: ../../chapter-07.rst:857
msgid ""
"``uploadfolder`` sets the folder for uploaded files. By default, an "
"uploaded file goes into the application’s “uploads/” folder, that is into "
"``os.path.join(request.folder, 'uploads')`` (this seems not the case for "
"MongoAdapter at present). For example: ``Field(..., uploadfolder=os.path."
"join(request.folder, 'static/temp'))``:python will upload files to the "
"“py4web/applications/myapp/static/temp” folder."
msgstr ""
"`` Uploadfolder`` define a pasta para arquivos enviados. Por padrão, um "
"arquivo carregado vai para a pasta da aplicação “uploads /”, que é em `` os."
"path.join (request.folder, 'uploads') `` (isto não parece ser o case para "
"MongoAdapter no presente). Por exemplo: `` Field (..., uploadfolder = os."
"path.join (request.folder, 'static / temp')) ``: python vai fazer upload de "
"arquivos para a “py4web / aplicativos / myapp / static / temp” pasta."

#: ../../chapter-07.rst:865
msgid ""
"``uploadseparate`` if set to True will upload files under different "
"subfolders of the *uploadfolder* folder. This is optimized to avoid too "
"many files under the same folder/subfolder. ATTENTION: You cannot change "
"the value of ``uploadseparate`` from True to False without breaking links "
"to existing uploads. py4web either uses the separate subfolders or it does "
"not. Changing the behavior after files have been uploaded will prevent "
"py4web from being able to retrieve those files. If this happens it is "
"possible to move files and fix the problem but this is not described here."
msgstr ""
"`` Uploadseparate`` Se definido como verdadeiro vai fazer upload de "
"arquivos em diferentes subpastas da * uploadfolder pasta *. Esta é "
"otimizado para evitar muitos arquivos na mesma pasta / subpasta. ATENÇÃO: "
"Não é possível alterar o valor de `` uploadseparate`` de True para False "
"sem quebrar links para uploads existentes. py4web ou usa as subpastas "
"separadas ou não. Alterar o comportamento após arquivos foram enviados "
"impedirá py4web de ser capaz de recuperar esses arquivos. Se isso acontece, "
"é possível mover arquivos e corrigir o problema, mas isso não é descrito "
"aqui."

#: ../../chapter-07.rst:875
msgid ""
"``uploadfs`` allows you specify a different file system where to upload "
"files, including an Amazon S3 storage or a remote SFTP storage."
msgstr ""
"`` Uploadfs`` permite que você especificar um sistema de arquivos "
"diferente, onde fazer o upload de arquivos, incluindo um armazenamento "
"Amazon S3 ou um armazenamento de SFTP remoto."

#: ../../chapter-07.rst:881
msgid ""
"You need to have PyFileSystem installed for this to work. ``uploadfs`` must "
"point to PyFileSystem."
msgstr ""
"Você precisa ter PyFileSystem instalado para que isso funcione. `` "
"Uploadfs`` deve apontar para PyFileSystem."

#: ../../chapter-07.rst:884
msgid ""
"``autodelete`` determines if the corresponding uploaded file should be "
"deleted when the record referencing the file is deleted. For “upload” "
"fields only. However, records deleted by the database itself due to a "
"CASCADE operation will not trigger py4web’s autodelete. The py4web Google "
"group has workaround discussions."
msgstr ""
"`` Autodelete`` determina se o arquivo enviado correspondente deve ser "
"suprimido quando o registro referenciando o arquivo é excluído. Por apenas "
"os campos “Upload”. No entanto, os registros excluídos pelo próprio banco "
"de dados devido a uma operação em cascata não vai autodelete gatilho de "
"py4web. O grupo Google py4web tem solução discussões."

#: ../../chapter-07.rst:889
msgid ""
"``widget`` must be one of the available widget objects, including custom "
"widgets, for example: ``SQLFORM.widgets.string.widget``. A list of "
"available widgets will be discussed later. Each field type has a default "
"widget."
msgstr ""
"`` Widget`` deve ser um dos objetos de widgets disponíveis, incluindo "
"widgets personalizados, por exemplo: `` SQLFORM.widgets.string.widget``. "
"Uma lista de widgets disponíveis será discutido mais tarde. Cada tipo de "
"campo tem um widget padrão."

#: ../../chapter-07.rst:893
msgid ""
"``label`` is a string (or a helper or something that can be serialized to a "
"string) that contains the label to be used for this field in auto-generated "
"forms."
msgstr ""
"`` Label`` é uma string (ou um ajudante ou algo que pode ser serializado "
"para uma string) que contém o rótulo a ser usado para este campo em formas "
"geradas automaticamente."

#: ../../chapter-07.rst:896
msgid ""
"``comment`` is a string (or a helper or something that can be serialized to "
"a string) that contains a comment associated with this field, and will be "
"displayed to the right of the input field in the autogenerated forms."
msgstr ""
"`` Comment`` é uma string (ou um ajudante ou algo que pode ser serializado "
"para uma string) que contém um comentário associado a este campo, e será "
"exibido à direita do campo de entrada nos formulários gerados "
"automaticamente."

#: ../../chapter-07.rst:900
msgid "``writable`` declares whether a field is writable in forms."
msgstr "`` Writable`` declara se um campo é gravável em formulários."

#: ../../chapter-07.rst:901
msgid ""
"``readable`` declares whether a field is readable in forms. If a field is "
"neither readable nor writable, it will not be displayed in create and "
"update forms."
msgstr ""
"`` Readable`` declara se um campo é legível em formulários. Se um campo não "
"é nem legível, nem gravável, não será exibido em criar e atualizar formas."

#: ../../chapter-07.rst:904
msgid ""
"``searchable`` declares whether a field is searchable in grids (``SQLFORM."
"grid`` and ``SQLFORM.smartgrid`` are described in *Chapter 7 ../07* ). "
"Notice that a field must also be readable to be searched."
msgstr ""
"`` Searchable`` declara se um campo é pesquisável em grades ( `` `` SQLFORM."
"grid`` e SQLFORM.smartgrid`` são descritos em * Capítulo 7 ../07*). Observe "
"que um campo também deve ser legível a ser pesquisado."

#: ../../chapter-07.rst:907
msgid ""
"``listable`` declares whether a field is visible in grids (when listing "
"multiple records)"
msgstr ""
"`` Listable`` declara se um campo é visível em grades (quando listando "
"vários registros)"

#: ../../chapter-07.rst:909
msgid ""
"``update`` contains the default value for this field when the record is "
"updated."
msgstr ""
"`` Update`` contém o valor padrão para este campo quando o registro é "
"atualizado."

#: ../../chapter-07.rst:911
msgid ""
"``compute`` is an optional function. If a record is inserted or updated, "
"the compute function will be executed and the field will be populated with "
"the function result. The record is passed to the compute function as a "
"``dict``, and the dict will not include the current value of that, or any "
"other compute field."
msgstr ""
"`` Compute`` é uma função opcional. Se um registro é inserido ou "
"atualizado, a função de computação será executado eo campo será preenchido "
"com o resultado da função. O registro é passado para a função de computação "
"como um `` dict``, eo dict não incluirá o valor atual de que, ou qualquer "
"outro campo de computação."

#: ../../chapter-07.rst:916
msgid ""
"``authorize`` can be used to require access control on the corresponding "
"field, for “upload” fields only. It will be discussed more in detail in the "
"context of Authentication and Authorization."
msgstr ""
"`` Authorize`` pode ser usado para exigir o controle de acesso no campo "
"correspondente, para apenas os campos “Upload”. Ele será discutido mais em "
"detalhe no contexto de autenticação e autorização."

#: ../../chapter-07.rst:919
msgid ""
"``represent`` can be None or can point to a function that takes a field "
"value and returns an alternate representation for the field value. Examples:"
msgstr ""
"`` Represent`` pode ser Nenhum ou pode apontar para uma função que recebe "
"um valor de campo e retorna uma representação alternativa para o valor do "
"campo. Exemplos:"

#: ../../chapter-07.rst:929
msgid ""
"``filter_in`` and ``filter_out`` can be set to callables for further "
"processing of field’s value. ``filter_in`` is passed the field’s value to "
"be written to the database before an insert or update while ``filter_out`` "
"is passed the value retrieved from the database before field assignment. "
"The value returned by the callable is then used. See `filter_in and "
"filter_out <#filter_in_filter_out>`__ section in this chapter."
msgstr ""
"`` Filter_in`` e `` filter_out`` pode ser configurado para chamáveis ​​para "
"processamento adicional do valor de campo. `` Filter_in`` é passado o valor "
"do campo a serem gravados para o banco de dados antes de uma inserção ou "
"atualização enquanto `` filter_out`` é passado o valor recuperado do banco "
"de dados antes da atribuição de campo. O valor retornado pelo que pode ser "
"chamado é então utilizado. Veja `filter_in e filter_out "
"<#filter_in_filter_out>` __ neste capítulo."

#: ../../chapter-07.rst:936
msgid ""
"``custom_qualifier`` is a custom SQL qualifier for the field to be used at "
"table creation time (cannot use for field of type “id”, “reference”, or "
"“big-reference”)."
msgstr ""
"`` Custom_qualifier`` é um qualificador SQL personalizado para o campo para "
"ser usado na criação da tabela (não pode usar para campo do tipo “id”, "
"“referência” ou “big-referência”)."

#: ../../chapter-07.rst:941
msgid "Field types"
msgstr "Tipos de campo"

#: ../../chapter-07.rst:944
msgid "**field type**"
msgstr "**tipo de campo**"

#: ../../chapter-07.rst:944
msgid "**default field validators**"
msgstr "** validadores de campo padrão **"

#: ../../chapter-07.rst:946
msgid "``string``"
msgstr "`` String``"

#: ../../chapter-07.rst:946 ../../chapter-07.rst:970
msgid "``IS_LENGTH(length)`` default length is 512"
msgstr "`` IS_LENGTH (comprimento) `` comprimento padrão é 512"

#: ../../chapter-07.rst:949
msgid "``text``"
msgstr "`` text``"

#: ../../chapter-07.rst:949
msgid "``IS_LENGTH(length)`` default length is 32768"
msgstr "`` IS_LENGTH (comprimento) `` comprimento padrão é 32.768"

#: ../../chapter-07.rst:952
msgid "``blob``"
msgstr "`` blob``"

#: ../../chapter-07.rst:952
msgid "``None`` default length is 2**31 (2 GiB)"
msgstr "`` Comprimento padrão None`` é 2 ** 31 (2 GIB)"

#: ../../chapter-07.rst:955
msgid "``boolean``"
msgstr "`` boolean``"

#: ../../chapter-07.rst:955 ../../chapter-07.rst:977 ../../chapter-07.rst:979
#: ../../chapter-07.rst:989 ../../chapter-07.rst:991
msgid "``None``"
msgstr "`` None``"

#: ../../chapter-07.rst:957
msgid "``integer``"
msgstr "`` integer``"

#: ../../chapter-07.rst:957
msgid "``IS_INT_IN_RANGE(-2**31, 2**31)``"
msgstr "`` IS_INT_IN_RANGE (** -2 31, 2 ** 31) ``"

#: ../../chapter-07.rst:959
msgid "``double``"
msgstr "`` Double``"

#: ../../chapter-07.rst:959
msgid "``IS_FLOAT_IN_RANGE(-1e100, 1e100)``"
msgstr "`` IS_FLOAT_IN_RANGE (-1e100, 1e100) ``"

#: ../../chapter-07.rst:961
msgid "``decimal(n,m)``"
msgstr "`` Decimal (n, m) ``"

#: ../../chapter-07.rst:961
msgid "`` IS_DECIMAL_IN_RANGE(-10**10, 10**10)``"
msgstr "`` IS_DECIMAL_IN_RANGE (-10 ** 10, 10 ** 10) ``"

#: ../../chapter-07.rst:964
msgid "``date``"
msgstr "`` date``"

#: ../../chapter-07.rst:964
msgid "``IS_DATE()``"
msgstr "`` IS_DATE () ``"

#: ../../chapter-07.rst:966
msgid "``time``"
msgstr "`` Time``"

#: ../../chapter-07.rst:966
msgid "``IS_TIME()``"
msgstr "`` IS_TIME () ``"

#: ../../chapter-07.rst:968
msgid "``datetime``"
msgstr "`` datetime``"

#: ../../chapter-07.rst:968
msgid "``IS_DATETIME()``"
msgstr "`` IS_DATETIME () ``"

#: ../../chapter-07.rst:970
msgid "``password``"
msgstr "`` password``"

#: ../../chapter-07.rst:973
msgid "``upload``"
msgstr "`` Upload``"

#: ../../chapter-07.rst:973
msgid "``None`` default length is 512"
msgstr "`` Comprimento padrão é 512 None``"

#: ../../chapter-07.rst:975
msgid "``reference <table>``"
msgstr "`` Referência <table> ``"

#: ../../chapter-07.rst:975
msgid "``IS_IN_DB(db, table.field, format)``"
msgstr "`` IS_IN_DB (db, table.field, formato) ``"

#: ../../chapter-07.rst:977
msgid "``list:string``"
msgstr "`` Lista: string``"

#: ../../chapter-07.rst:979
msgid "``list:integer``"
msgstr "`` Lista: integer``"

#: ../../chapter-07.rst:981
msgid "``list:reference <table>``"
msgstr "`` Lista: referência <table> ``"

#: ../../chapter-07.rst:981
msgid "``IS_IN_DB(d b, table._id, format, multiple=True)``"
msgstr "`` IS_IN_DB (d b, table._id, formato, múltiplos = TRUE) ``"

#: ../../chapter-07.rst:984
msgid "``json``"
msgstr "`` json``"

#: ../../chapter-07.rst:984
msgid "``IS_EMPTY_OR(IS_JSON())`` default length is 512"
msgstr "`` IS_EMPTY_OR (IS_JSON ()) `` comprimento padrão é 512"

#: ../../chapter-07.rst:987
msgid "``bigint``"
msgstr "`` bigint``"

#: ../../chapter-07.rst:987
msgid "``IS_INT_IN_RANGE(-2**63, 2**63)``"
msgstr "`` IS_INT_IN_RANGE (** -2 63, 2 ** 63) ``"

#: ../../chapter-07.rst:989
msgid "``big-id``"
msgstr "`` Grande-id``"

#: ../../chapter-07.rst:991
msgid "``big-reference``"
msgstr "`` Grande-reference``"

#: ../../chapter-07.rst:994
msgid ""
"Decimal requires and returns values as ``Decimal`` objects, as defined in "
"the Python ``decimal`` module. SQLite does not handle the ``decimal`` type "
"so internally we treat it as a ``double``. The (n,m) are the number of "
"digits in total and the number of digits after the decimal point "
"respectively."
msgstr ""
"Decimal requer e devolve valores como `` objectos Decimal``, como definidos "
"na Python `` decimal`` módulo. SQLite não lidar com o `` decimal`` tipo "
"assim internamente que tratá-lo como um `` double``. O (n, m) são o número "
"de dígitos no total e o número de dígitos após o ponto decimal, "
"respectivamente."

#: ../../chapter-07.rst:1000
msgid ""
"The ``big-id`` and, ``big-reference`` are only supported by some of the "
"database engines and are experimental. They are not normally used as field "
"types unless for legacy tables, however, the DAL constructor has a "
"``bigint_id`` argument that when set to ``True`` makes the ``id`` fields "
"and ``reference`` fields ``big-id`` and ``big-reference`` respectively."
msgstr ""
"A `` grande-id`` e, `` grande-reference`` são suportados apenas por alguns "
"dos mecanismos de bases de dados e são experimentais. Eles não são "
"normalmente usados ​​como tipos de campo a menos de tabelas legadas, no "
"entanto, o construtor DAL tem um argumento `` bigint_id`` que, quando "
"definido para `` True`` faz com que os `` campos id`` e `` campos "
"reference`` `` grande-id`` e `` grande-reference`` respectivamente."

#: ../../chapter-07.rst:1006
msgid ""
"The ``list:<type>`` fields are special because they are designed to take "
"advantage of certain denormalization features on NoSQL (in the case of "
"Google App Engine NoSQL, the field types ``ListProperty`` and "
"``StringListProperty``) and back-port them all the other supported "
"relational databases. On relational databases lists are stored as a "
"``text`` field. The items are separated by a ``|`` and each ``|`` in string "
"item is escaped as a ``||``. They are discussed in *list: and contains* "
"section in this chapter."
msgstr ""
"O `` lista: <type> `` campos são especiais porque eles são projetados para "
"tirar proveito de certas características Desnormalização on NoSQL (no case "
"do Google App Engine NoSQL, os tipos de campo `` ListProperty`` e `` "
"StringListProperty`` ) e volta-porta-lhes todas as outras bases de dados "
"relacionais suportados. Em bancos de dados relacionais listas são "
"armazenados como um `` text`` campo. Os itens são separados por um `` | `` "
"e cada `` | `` no item corda escapou, como um `` || ``. Eles são discutidos "
"na lista *: e contém seção * neste capítulo."

#: ../../chapter-07.rst:1015
msgid ""
"The ``json`` field type is pretty much explanatory. It can store any json "
"serializable object. It is designed to work specifically for MongoDB and "
"backported to the other database adapters for portability."
msgstr ""
"O `` tipo de campo json`` é bastante explicativo. Ele pode armazenar "
"qualquer objeto JSON serializado. Ele é projetado para trabalhar "
"especificamente para MongoDB e portadas para os outros adaptadores de banco "
"de dados para portabilidade."

#: ../../chapter-07.rst:1019
msgid ""
"``blob`` fields are also special. By default, binary data is encoded in "
"base64 before being stored into the actual database field, and it is "
"decoded when extracted. This has the negative effect of using 33% more "
"storage space than necessary in blob fields, but has the advantageof making "
"the communication independent of back-end-specific escaping conventions."
msgstr ""
"`` Campos blob`` também são especiais. Por padrão, os dados binários são "
"codificados em Base64 antes de ser armazenado no campo banco de dados real, "
"e é decodificado quando extraído. Isto tem o efeito negativo de utilizar "
"33% mais espaço de armazenagem do que o necessário em campos blob, mas tem "
"o advantageof fazendo a comunicação independente de convenções específico "
"de back-end-escapam."

#: ../../chapter-07.rst:1027
msgid "Run-time field and table modification"
msgstr "modificação da tabela e campo em tempo de execução"

#: ../../chapter-07.rst:1029
msgid ""
"Most attributes of fields and tables can be modified after they are defined:"
msgstr ""
"A maioria dos atributos de campos e tabelas podem ser modificados depois "
"que eles são definidos:"

#: ../../chapter-07.rst:1039
msgid ""
"notice that attributes of tables are usually prefixed by an underscore to "
"avoid conflict with possible field names."
msgstr ""
"aviso de que os atributos de tabelas são geralmente precedido por um "
"sublinhado para evitar conflitos com possíveis nomes de campo."

#: ../../chapter-07.rst:1042
msgid ""
"You can list the tables that have been defined for a given database "
"connection:"
msgstr ""
"Você pode listar as tabelas que foram definidos para uma determinada "
"conexão com o banco:"

#: ../../chapter-07.rst:1050
msgid "You can query for the type of a table:"
msgstr "Você pode consultar para o tipo de uma tabela:"

#: ../../chapter-07.rst:1057
msgid "You can access a table using different syntaxes:"
msgstr "Você pode acessar uma tabela utilizando diferentes sintaxes:"

#: ../../chapter-07.rst:1064
msgid "You can also list the fields that have been defined for a given table:"
msgstr ""
"Você também pode listar os campos que foram definidos para uma determinada "
"tabela:"

#: ../../chapter-07.rst:1071
msgid ""
"Similarly you can access fields from their name in multiple equivalent ways:"
msgstr ""
"Da mesma forma você pode acessar campos de seu nome de várias maneiras "
"equivalentes:"

#: ../../chapter-07.rst:1081
msgid "Given a field, you can access the attributes set in its definition:"
msgstr ""
"Dado um campo, você pode acessar os atributos definidos em sua definição:"

#: ../../chapter-07.rst:1094
msgid "including its parent table, tablename, and parent connection:"
msgstr "incluindo a sua tabela pai, tablename, e ligação parent:"

#: ../../chapter-07.rst:1105
msgid ""
"A field also has methods. Some of them are used to build queries and we "
"will see them later. A special method of the field object is ``validate`` "
"and it calls the validators for the field."
msgstr ""
"Um campo também tem métodos. Alguns deles são utilizados para consultas de "
"construção e vamos vê-los mais tarde. Um método especial do objeto de campo "
"é `` validate`` e chama os validadores para o campo."

#: ../../chapter-07.rst:1114
msgid ""
"which returns a tuple ``(value, error)``. ``error`` is ``None`` if the "
"input passes validation."
msgstr ""
"que retorna um tuplo `` (valor, erro) ``. `` `` Error`` é None`` se a "
"entrada passa a validação."

#: ../../chapter-07.rst:1118
msgid "Migrations"
msgstr "Migrações"

#: ../../chapter-07.rst:1120
msgid ""
"``define_table`` checks whether or not the corresponding table exists. If "
"it does not, it generates the SQL to create it and executes the SQL. If the "
"table does exist but differs from the one being defined, it generates the "
"SQL to alter the table and executes it. If a field has changed type but not "
"name, it will try to convert the data (If you do not want this, you need to "
"redefine the table twice, the first time, letting py4web drop the field by "
"removing it, and the second time adding the newly defined field so that "
"py4web can create it.). If the table exists and matches the current "
"definition, it will leave it alone. In all cases it will create the ``db."
"person`` object that represents the table."
msgstr ""
"`` Controlos define_table`` se existe ou não a tabela correspondente. Se "
"isso não acontecer, ele gera o SQL para criá-lo e executa o SQL. Se a "
"tabela existe, mas difere do que está sendo definido, gera o SQL para "
"alterar a tabela e executa-lo. Se um campo mudou tipo, mas não o nome, ele "
"vai tentar converter os dados (se você não quer isso, você precisa "
"redefinir a tabela duas vezes, a primeira vez, deixando py4web largar o "
"campo removendo-o, e pela segunda vez adicionar o campo recém-definido para "
"que py4web pode criá-lo.). Se a tabela existe e coincide com a definição "
"atual, ele vai deixá-lo sozinho. Em todos os cases ele irá criar o `` db."
"person`` objeto que representa a mesa."

#: ../../chapter-07.rst:1132
msgid ""
"We refer to this behavior as a “migration”. py4web logs all migrations and "
"migration attempts in the file “sql.log”."
msgstr ""
"Referimo-nos a esse comportamento como uma “migração”. py4web registra "
"todas as migrações e migração tentativas no arquivo “Sql.log”."

#: ../../chapter-07.rst:1135
msgid ""
"Notice that by default py4web uses the “app/databases” folder for the log "
"file and all other migration files it needs. You can change this setting "
"the ``folder`` argument to DAL. To set a different log file name, for "
"example “migrate.log” you can do ``db = DAL(..., "
"adapter_args=dict(logfile='migrate.log'))``:python"
msgstr ""
"Observe que por py4web padrão usa a pasta “app / bancos de dados” para o "
"arquivo de log e todos os outros arquivos de migração de que necessita. "
"Você pode alterar essa configuração o argumento `` folder`` para DAL. Para "
"definir um nome de arquivo de log diferente, por exemplo “migrate.log” você "
"pode fazer `` db = DAL (..., adapter_args = dict (logfile = 'migrate.log')) "
"``: python"

#: ../../chapter-07.rst:1141
msgid ""
"The first argument of ``define_table`` is always the table name. The other "
"unnamed arguments are the fields (Field). The function also takes an "
"optional keyword argument called “migrate”:"
msgstr ""
"O primeiro argumento de `` define_table`` é sempre o nome da tabela. Os "
"outros argumentos sem nome são os campos (campo). A função também tem um "
"argumento palavra-chave opcional chamado “migrar”:"

#: ../../chapter-07.rst:1149
msgid ""
"The value of migrate is the filename where py4web stores internal migration "
"information for this table. These files are very important and should never "
"be removed while the corresponding tables exist. In cases where a table has "
"been dropped and the corresponding file still exist, it can be removed "
"manually. By default, migrate is set to True. This causes py4web to "
"generate the filename from a hash of the connection string. If migrate is "
"set to False, the migration is not performed, and py4web assumes that the "
"table exists in the datastore and it contains (at least) the fields listed "
"in ``define_table``."
msgstr ""
"O valor de migrar é o nome do arquivo onde as informações lojas py4web "
"migração interna para esta tabela. Esses arquivos são muito importantes e "
"nunca deve ser removido enquanto existirem as tabelas correspondentes. Nos "
"cases em que uma tabela foi descartado eo arquivo correspondente ainda "
"existem, ele pode ser removido manualmente. Por padrão, migre é definida "
"como True. Este causas py4web para gerar o nome do arquivo a partir de um "
"hash da string de conexão. Se migre é definida como falso, a migração não é "
"realizada, e py4web assume que a tabela existe no armazenamento de dados e "
"que contém (pelo menos) os campos listados no `` define_table``."

#: ../../chapter-07.rst:1159
msgid ""
"There may not be two tables in the same application with the same migrate "
"filename."
msgstr ""
"Não pode haver duas tabelas no mesmo aplicativo com o mesmo nome migrar."

#: ../../chapter-07.rst:1162
msgid ""
"The DAL class also takes a “migrate” argument, which determines the default "
"value of migrate for calls to ``define_table``. For example,"
msgstr ""
"A classe DAL também leva um argumento “migrar”, que determina o valor "
"padrão de migrar para chamadas para `` define_table``. Por exemplo,"

#: ../../chapter-07.rst:1169
msgid ""
"will set the default value of migrate to False whenever ``db.define_table`` "
"is called without a migrate argument."
msgstr ""
"irá definir o valor padrão de migrar para Falso quando `` db.define_table`` "
"é chamado sem um argumento migrar."

#: ../../chapter-07.rst:1172
msgid ""
"Notice that py4web only migrates new columns, removed columns, and changes "
"in column type (except in SQLite). py4web does not migrate changes in "
"attributes such as changes in the values of ``default``, ``unique``, "
"``notnull``, and ``ondelete``."
msgstr ""
"Note-se que só migra py4web novas colunas, as colunas removido, e mudanças "
"no tipo de coluna (excepto no SQLite). py4web não altere de migram em "
"atributos tais como alterações nos valores de default`` ``: `` unique``, `` "
"notnull``, e `` ondelete``."

#: ../../chapter-07.rst:1177
msgid "Migrations can be disabled for all tables at once:"
msgstr ""
"As migrações podem ser desativado para todas as tabelas de uma só vez:"

#: ../../chapter-07.rst:1183
msgid ""
"This is the recommended behavior when two apps share the same database. "
"Only one of the two apps should perform migrations, the other should "
"disabled them."
msgstr ""
"Este é o comportamento recomendado quando dois aplicativos compartilham o "
"mesmo banco de dados. Apenas um dos dois aplicativos devem executar "
"migrações, o outro deve desativada eles."

#: ../../chapter-07.rst:1188
msgid "Fixing broken migrations"
msgstr "Fixação migrações quebrados"

#: ../../chapter-07.rst:1190
msgid ""
"There are two common problems with migrations and there are ways to recover "
"from them."
msgstr ""
"Há dois problemas comuns com as migrações e existem formas de recuperar a "
"partir deles."

#: ../../chapter-07.rst:1193
msgid ""
"One problem is specific with SQLite. SQLite does not enforce column types "
"and cannot drop columns. This means that if you have a column of type "
"string and you remove it, it is not really removed. If you add the column "
"again with a different type (for example datetime) you end up with a "
"datetime column that contains strings (junk for practical purposes). py4web "
"does not complain about this because it does not know what is in the "
"database, until it tries to retrieve records and fails."
msgstr ""
"Um problema é específico com SQLite. SQLite não impor tipos de coluna e não "
"pode soltar colunas. Isto significa que se você tiver uma coluna do tipo "
"string e você removê-lo, não é realmente removido. Se você adicionar a "
"coluna novamente com um tipo diferente (por exemplo, data e hora) você "
"acaba com uma coluna de data e hora que contém strings (lixo para fins "
"práticos). não py4web não reclamar sobre isso, porque ele não sabe o que "
"está no banco de dados, até que ele tenta recuperar registros e falha."

#: ../../chapter-07.rst:1201
msgid ""
"If py4web returns an error in some parse function when selecting records, "
"most likely this is due to corrupted data in a column because of the above "
"issue."
msgstr ""
"Se py4web retorna um erro em alguma função de análise ao selecionar "
"registros, muito provavelmente isso é devido a dados corrompidos em uma "
"coluna por causa da questão acima."

#: ../../chapter-07.rst:1205
msgid ""
"The solution consists in updating all records of the table and updating the "
"values in the column in question with None."
msgstr ""
"A solução consiste em actualizar todos os registos da tabela e a "
"actualização dos valores na coluna em questão com Nenhum."

#: ../../chapter-07.rst:1208
msgid ""
"The other problem is more generic but typical with MySQL. MySQL does not "
"allow more than one ALTER TABLE in a transaction. This means that py4web "
"must break complex transactions into smaller ones (one ALTER TABLE at the "
"time) and commit one piece at the time. It is therefore possible that part "
"of a complex transaction gets committed and one part fails, leaving py4web "
"in a corrupted state. Why would part of a transaction fail? Because, for "
"example, it involves altering a table and converting a string column into a "
"datetime column, py4web tries to convert the data, but the data cannot be "
"converted. What happens to py4web? It gets confused about what exactly is "
"the table structure actually stored in the database."
msgstr ""
"O outro problema é mais genérico, mas típico com MySQL. O MySQL não "
"permitem mais de um ALTER TABLE em uma transação. Isto significa que py4web "
"deve quebrar transações complexas em partes menores (um ALTER TABLE na "
"época) e cometem uma peça no momento. Por isso, é possível que parte de uma "
"transação complexa fica comprometida e uma parte falhar, deixando py4web em "
"um estado corrompido. Por que parte de uma transação falhar? Uma vez que, "
"por exemplo, envolve a alteração de uma tabela de conversão e uma coluna de "
"strings dentro de uma coluna de data e hora, tentativas py4web para "
"converter os dados, mas os dados não podem ser convertidos. O que acontece "
"com py4web? Ele fica confuso sobre o que exatamente é a estrutura da tabela "
"realmente armazenados no banco de dados."

#: ../../chapter-07.rst:1220
msgid "The solution consists of enabling fake migrations:"
msgstr "A solução consiste em permitir migrações falsos:"

#: ../../chapter-07.rst:1226
msgid ""
"This will rebuild py4web metadata about the table according to the table "
"definition. Try multiple table definitions to see which one works (the one "
"before the failed migration and the one after the failed migration). Once "
"successful remove the ``fake_migrate=True`` parameter."
msgstr ""
"Isto irá reconstruir metadados py4web sobre a tabela de acordo com a "
"definição da tabela. Tente várias definições de tabela para ver qual delas "
"funciona (aquele antes da migração falhou ea uma após a migração falhou). "
"Uma vez que remove sucesso do `` fake_migrate = True`` parâmetro."

#: ../../chapter-07.rst:1231
msgid ""
"Before attempting to fix migration problems it is prudent to make a copy of "
"\"applications/yourapp/databases/\\*.table\" files."
msgstr ""
"Antes de tentar correção de migração problemas é prudente fazer uma cópia "
"de <quotechar> aplicações / yourapp / databases / \\ *. Mesa <quotechar> "
"arquivos."

#: ../../chapter-07.rst:1234
msgid "Migration problems can also be fixed for all tables at once:"
msgstr ""
"Migração problemas também pode ser fixada para todas as tabelas de uma só "
"vez:"

#: ../../chapter-07.rst:1240
msgid ""
"This also fails if the model describes tables that do not exist in the "
"database, but it can help narrowing down the problem."
msgstr ""
"Isso também falhará se o modelo descreve tabelas que não existem no banco "
"de dados, mas pode ajudar a estreitar o problema."

#: ../../chapter-07.rst:1244
msgid "Migration control summary"
msgstr "Migração resumo controle"

#: ../../chapter-07.rst:1246
msgid ""
"The logic of the various migration arguments are summarized in this pseudo-"
"code:"
msgstr ""
"A lógica dos vários argumentos de migração estão resumidos neste pseudo-"
"código:"

#: ../../chapter-07.rst:1258
msgid "``insert``"
msgstr "`` Insert``"

#: ../../chapter-07.rst:1260
msgid "Given a table, you can insert records"
msgstr "Dada uma tabela, você pode inserir registros"

#: ../../chapter-07.rst:1269
msgid "Insert returns the unique “id” value of each record inserted."
msgstr "Inserir retorna o valor único “id” de cada registro inserido."

#: ../../chapter-07.rst:1271
msgid ""
"You can truncate the table, i.e., delete all records and reset the counter "
"of the id."
msgstr ""
"Você pode truncar a tabela, ou seja, excluir todos os registros e reinicie "
"o contador do id."

#: ../../chapter-07.rst:1278
msgid ""
"Now, if you insert a record again, the counter starts again at 1 (this is "
"back-end specific and does not apply to Google NoSQL):"
msgstr ""
"Agora, se você inserir um registro novo, o contador recomeça a 1 (isto é "
"específico back-end e não se aplica ao Google NoSQL):"

#: ../../chapter-07.rst:1286
msgid ""
"Notice you can pass a parameter to ``truncate``, for example you can tell "
"SQLite to restart the id counter."
msgstr ""
"Observe que você pode passar um parâmetro para `` truncate``, por exemplo, "
"você pode dizer SQLite para reiniciar o contador id."

#: ../../chapter-07.rst:1293
msgid "The argument is in raw SQL and therefore engine specific."
msgstr "O argumento é em SQL puro e, portanto, específico do motor."

#: ../../chapter-07.rst:1295
msgid "py4web also provides a bulk_insert method"
msgstr "py4web também fornece um método bulk_insert"

#: ../../chapter-07.rst:1302
msgid ""
"It takes a list of dictionaries of fields to be inserted and performs "
"multiple inserts at once. It returns the list of “id” values of the "
"inserted records. On the supported relational databases there is no "
"advantage in using this function as opposed to looping and performing "
"individual inserts but on Google App Engine NoSQL, there is a major speed "
"advantage."
msgstr ""
"É preciso uma lista de dicionários de campos a serem inseridas e executa "
"várias inserções ao mesmo tempo. Ele retorna a lista de valores “id” dos "
"registros inseridos. Nos bancos de dados relacionais suportadas não há "
"nenhuma vantagem em usar esta função ao invés de looping e realizando "
"inserções individuais, mas no Google App Engine NoSQL, há uma grande "
"vantagem de velocidade."

#: ../../chapter-07.rst:1310
msgid "``commit`` and ``rollback``"
msgstr "`` `` commit`` e rollback``"

#: ../../chapter-07.rst:1312
msgid ""
"The insert, truncate, delete, and update operations aren’t actually "
"committed until py4web issues the commit command. The create and drop "
"operations may be executed immediately, depending on the database engine. "
"Calls to py4web actions are automatically wrapped in transactions. If you "
"executed commands via the shell, you are required to manually commit:"
msgstr ""
"Inserir, truncado, excluir e operações de atualização não estão realmente "
"comprometidos até que as questões py4web o comando cometer. A criar e "
"operações de gota pode ser executado imediatamente, dependendo do motor de "
"banco de dados. Chamadas para ações py4web são automaticamente envolvido em "
"transações. Se você executou os comandos da shell, você é obrigado a "
"cometer manualmente:"

#: ../../chapter-07.rst:1323
msgid "To check it let’s insert a new record:"
msgstr "Para verificar isso, vamos inserir um novo registro:"

#: ../../chapter-07.rst:1330
msgid "and roll back, i.e., ignore all operations since the last commit:"
msgstr ""
"and roll de volta, ou seja, ignorar todas as operações desde o último "
"commit:"

#: ../../chapter-07.rst:1336
msgid ""
"If you now insert again, the counter will again be set to 2, since the "
"previous insert was rolled back."
msgstr ""
"Se você agora inserir novamente, o contador voltará a ser definido para 2, "
"desde a inserção anterior foi revertida."

#: ../../chapter-07.rst:1344
msgid ""
"Code in models, views and controllers is enclosed in py4web code that looks "
"like this (pseudo code) :"
msgstr ""
"Código em modelos, visualizações e controladores está incluído no código "
"py4web parecida com esta (pseudo-código):"

#: ../../chapter-07.rst:1359
msgid ""
"So in models, views and controllers there is no need to ever call "
"``commit`` or ``rollback`` explicitly in py4web unless you need more "
"granular control. However, in modules you will need to use ``commit()``."
msgstr ""
"Assim, em modelos, visualizações e controladores não há necessidade de "
"chamar cada vez `` commit`` ou `` rollback`` explicitamente em py4web a "
"menos que você precisa um controle mais granular. No entanto, em módulos "
"que você vai precisar usar `` commit () ``."

#: ../../chapter-07.rst:1364
msgid "Raw SQL"
msgstr "Raw SQL"

#: ../../chapter-07.rst:1367
msgid "Timing queries"
msgstr "Temporização de consultas"

#: ../../chapter-07.rst:1369
msgid ""
"All queries are automatically timed by py4web. The variable ``db._timings`` "
"is a list of tuples. Each tuple contains the raw SQL query as passed to the "
"database driver and the time it took to execute in seconds. This variable "
"can be displayed in views using the toolbar:"
msgstr ""
"Todas as consultas são automaticamente cronometrado por py4web. A variável "
"`` db._timings`` é uma lista de tuplos. Cada tupla contém a consulta SQL "
"crus como passados ​​para o driver de banco de dados e o tempo que levou para "
"executar em segundos. Esta variável pode ser exibida em vistas usando a "
"barra de ferramentas:"

#: ../../chapter-07.rst:1379
msgid "``executesql``"
msgstr "`` executesql``"

#: ../../chapter-07.rst:1381
msgid "The DAL allows you to explicitly issue SQL statements."
msgstr "A DAL permite emitir explicitamente instruções SQL."

#: ../../chapter-07.rst:1388
msgid ""
"In this case, the return values are not parsed or transformed by the DAL, "
"and the format depends on the specific database driver. This usage with "
"selects is normally not needed, but it is more common with indexes."
msgstr ""
"Neste case, os valores de retorno não são analisados ​​ou transformados pela "
"DAL, eo formato depende do driver de banco de dados específico. Este uso "
"com selecciona normalmente não é necessário, mas é mais comum com índices."

#: ../../chapter-07.rst:1392
msgid ""
"``executesql`` takes five optional arguments: ``placeholders``, "
"``as_dict``, ``fields``, ``colnames``, and ``as_ordered_dict``."
msgstr ""
"`` Executesql`` leva cinco argumentos opcionais: `` placeholders``, `` "
"as_dict``, `` fields``, `` colnames``, e `` as_ordered_dict``."

#: ../../chapter-07.rst:1395
msgid ""
"``placeholders`` is an optional sequence of values to be substituted in or, "
"if supported by the DB driver, a dictionary with keys matching named "
"placeholders in your SQL."
msgstr ""
"`` Placeholders`` é uma seqüência opcional de valores a serem substituídos "
"ou, se suportado pelo driver DB, um dicionário com chaves correspondentes "
"chamado espaços reservados no seu SQL."

#: ../../chapter-07.rst:1399
msgid ""
"If ``as_dict`` is set to True, the results cursor returned by the DB driver "
"will be converted to a sequence of dictionaries keyed with the db field "
"names. Results returned with ``as_dict = True`` are the same as those "
"returned when applying **.as_list()** to a normal select:"
msgstr ""
"Se `` as_dict`` é definida como True, os resultados do cursor retornado "
"pelo driver DB será convertido em uma seqüência de dicionários introduzidos "
"com os nomes dos campos db. Os resultados retornados com `` as_dict = "
"True`` são os mesmos que os devolvido ao aplicar ** as_list () ** para um "
"select normal.:"

#: ../../chapter-07.rst:1408
msgid ""
"``as_ordered_dict`` is pretty much like ``as_dict`` but the former ensures "
"that the order of resulting fields (OrderedDict keys) reflect the order on "
"which they are returned from DB driver:"
msgstr ""
"`` As_ordered_dict`` é muito bonito como `` as_dict`` mas os antigos "
"garante que a ordem dos resultando campos (teclas OrderedDict) refletem a "
"ordem em que eles são retornados de DB motorista:"

#: ../../chapter-07.rst:1417
msgid ""
"The ``fields`` argument is a list of DAL Field objects that match the "
"fields returned from the DB. The Field objects should be part of one or "
"more Table objects defined on the DAL object. The ``fields`` list can "
"include one or more DAL Table objects in addition to or instead of "
"including Field objects, or it can be just a single table (not in a list). "
"In that case, the Field objects will be extracted from the table(s)."
msgstr ""
"O argumento `` fields`` é uma lista de objetos DAL de campo que "
"correspondem aos campos retornados da DB. Os objectos de campo devem ser "
"parte de um ou mais objectos Tabela definido no objecto DAL. A `` lista "
"fields`` pode incluir um ou mais DAL Tabela objetos em adição a ou em vez "
"de incluir Campo objetos, ou pode ser apenas uma única tabela (não de uma "
"lista). Nesse case, os objectos de campo vai ser extraído da tabela (s)."

#: ../../chapter-07.rst:1425
msgid ""
"Instead of specifying the ``fields`` argument, the ``colnames`` argument "
"can be specified as a list of field names in tablename.fieldname format. "
"Again, these should represent tables and fields defined on the DAL object."
msgstr ""
"Em vez de especificar o argumento `` fields``, o argumento `` colnames`` "
"pode ser especificado como uma lista de nomes de campos em formato tabela."
"campo. Novamente, estes devem representar tabelas e campos definidos no "
"objeto DAL."

#: ../../chapter-07.rst:1430
msgid ""
"It is also possible to specify both ``fields`` and the associated "
"``colnames``. In that case, ``fields`` can also include DAL Expression "
"objects in addition to Field objects. For Field objects in “fields”, the "
"associated ``colnames`` must still be in tablename.fieldname format. For "
"Expression objects in ``fields``, the associated ``colnames`` can be any "
"arbitrary labels."
msgstr ""
"Também é possível especificar `` fields`` eo associado `` colnames``. Nesse "
"case, `` fields`` pode também incluir objetos Expressão DAL, além de "
"objetos de campo. Para objetos de campo em “campos”, o associado `` "
"colnames`` ainda deve estar no formato tabela.campo. Para Expression "
"objetos em `` fields``, o associado `` colnames`` podem ser quaisquer "
"rótulos arbitrários."

#: ../../chapter-07.rst:1437
msgid ""
"Notice, the DAL Table objects referred to by ``fields`` or ``colnames`` can "
"be dummy tables and do not have to represent any real tables in the "
"database. Also, note that the ``fields`` and ``colnames`` must be in the "
"same order as the fields in the results cursor returned from the DB."
msgstr ""
"Observe, a Tabela DAL objectos referidos por `` fields`` ou `` colnames`` "
"pode ser fictícios mesas e não têm para representar todas as tabelas reais "
"no banco de dados. Além disso, nota que o `` fields`` e `` colnames`` devem "
"estar na mesma ordem que os campos nos resultados cursor retornado do DB."

#: ../../chapter-07.rst:1443
msgid "``_lastsql``"
msgstr "`` _Lastsql``"

#: ../../chapter-07.rst:1445
msgid ""
"Whether SQL was executed manually using executesql or was SQL generated by "
"the DAL, you can always find the SQL code in ``db._lastsql``. This is "
"useful for debugging purposes:"
msgstr ""
"Se SQL foi executado manualmente usando ExecuteSQL ou foi SQL gerado pelo "
"DAL, você sempre pode encontrar o código SQL em `` db._lastsql``. Isso é "
"útil para fins de depuração:"

#: ../../chapter-07.rst:1457
msgid ""
"py4web never generates queries using the \"*\" operator. py4web is always "
"explicit when selecting fields."
msgstr ""
"py4web não gera consultas usando o <quotechar> * <quotechar> operador. "
"py4web é sempre explícita ao selecionar campos."

#: ../../chapter-07.rst:1461
msgid "``drop``"
msgstr "`` Drop``"

#: ../../chapter-07.rst:1463
msgid "Finally, you can drop tables and all data will be lost:"
msgstr "Finalmente, você pode soltar tabelas e todos os dados serão perdidos:"

#: ../../chapter-07.rst:1470
msgid "Indexes"
msgstr "Índices"

#: ../../chapter-07.rst:1472
msgid ""
"Currently the DAL API does not provide a command to create indexes on "
"tables, but this can be done using the ``executesql`` command. This is "
"because the existence of indexes can make migrations complex, and it is "
"better to deal with them explicitly. Indexes may be needed for those fields "
"that are used in recurrent queries."
msgstr ""
"Atualmente, a API DAL não fornece um comando para criar índices em tabelas, "
"mas isso pode ser feito usando o comando `` executesql``. Isso ocorre "
"porque a existência de índices pode fazer migrações complexa, e é melhor "
"para lidar com eles de forma explícita. Os índices podem ser necessários "
"para esses campos que são usados ​​em consultas recorrentes."

#: ../../chapter-07.rst:1478
msgid "Here is an example of how to:"
msgstr "Aqui está um exemplo de como:"

#: ../../chapter-07.rst:1486
msgid ""
"Other database dialects have very similar syntaxes but may not support the "
"optional “IF NOT EXISTS” directive."
msgstr ""
"Outros dialetos banco de dados têm sintaxes muito semelhantes, mas pode não "
"suportar o opcional “SE NÃO EXISTE” directiva."

#: ../../chapter-07.rst:1490
msgid "Legacy databases and keyed tables"
msgstr "Bancos de dados legados e tabelas com chave"

#: ../../chapter-07.rst:1492
msgid "py4web can connect to legacy databases under some conditions."
msgstr ""
"py4web pode se conectar a bancos de dados legados sob algumas condições."

#: ../../chapter-07.rst:1494
msgid ""
"The easiest way is when these conditions are met: - Each table must have a "
"unique auto-increment integer field called “id” - Records must be "
"referenced exclusively using the “id” field."
msgstr ""
"A maneira mais fácil é quando essas condições forem atendidas: - Cada "
"tabela deve ter um campo inteiro de auto-incremento exclusivo chamado “id” "
"- Os registros devem ser referenciado exclusivamente usando o campo “id”."

#: ../../chapter-07.rst:1498
msgid ""
"When accessing an existing table, i.e., a table not created by py4web in "
"the current application, always set ``migrate=False``."
msgstr ""
"Ao acessar uma tabela existente, isto é, uma tabela não criado por py4web "
"no aplicativo atual, sempre definir `` migrar = False``."

#: ../../chapter-07.rst:1501
msgid ""
"If the legacy table has an auto-increment integer field but it is not "
"called “id”, py4web can still access it but the table definition must "
"declare the auto-increment field with ‘id’ type (that is using "
"``FIeld('...', 'id')``)."
msgstr ""
"Se a tabela de legado tem um campo inteiro de auto-incremento, mas não é "
"chamado de “id”, py4web ainda pode acessá-lo, mas a definição da tabela "
"deve declarar o campo de incremento automático com o tipo de 'id' (que está "
"usando campo `` (' ... ', 'id') ``)."

#: ../../chapter-07.rst:1506
msgid ""
"Finally if the legacy table uses a primary key that is not an auto-"
"increment id field it is possible to use a “keyed table”, for example:"
msgstr ""
"Finalmente se a tabela de legado usa uma chave primária que não é um campo "
"id auto-incremento é possível usar uma “mesa com chave”, por exemplo:"

#: ../../chapter-07.rst:1519
msgid ""
"``primarykey`` is a list of the field names that make up the primary key."
msgstr ""
"`` Primarykey`` é uma lista dos nomes de campo que compõem a chave primária."

#: ../../chapter-07.rst:1521
msgid "All primarykey fields have a ``NOT NULL`` set even if not specified."
msgstr ""
"Todos os campos PrimaryKey tem um `` NÃO NULL`` definido, mesmo se não "
"especificado."

#: ../../chapter-07.rst:1522
msgid "Keyed tables can only reference other keyed tables."
msgstr "Tabelas com chave só podem referenciar outras tabelas com chave."

#: ../../chapter-07.rst:1523
msgid ""
"Referencing fields must use the ``reference tablename.fieldname`` format."
msgstr "Campos de referência devem usar o ``reference tablename.fieldname``."

#: ../../chapter-07.rst:1525
msgid ""
"The ``update_record`` function is not available for Rows of keyed tables."
msgstr ""
"A `` função update_record`` não está disponível para filas de mesas com "
"chave."

#: ../../chapter-07.rst:1530
msgid ""
"Currently keyed tables are only supported for DB2, MSSQL, Ingres and "
"Informix, but others engines will be added."
msgstr ""
"Atualmente tabelas chaveadas são suportadas apenas para DB2, MSSQL, Ingres "
"e Informix, mas serão adicionados outros engines."

#: ../../chapter-07.rst:1533
msgid ""
"At the time of writing, we cannot guarantee that the ``primarykey`` "
"attribute works with every existing legacy table and every supported "
"database backend. For simplicity, we recommend, if possible, creating a "
"database view that has an auto-increment id field."
msgstr ""
"No momento da escrita, não podemos garantir que os `` obras de atributos "
"primarykey`` com cada mesa legado existente e cada backend de banco de "
"dados suportado. Para simplificar, recomendamos, se possível, criando uma "
"visão do banco de dados que tem um campo id auto-incremento."

#: ../../chapter-07.rst:1539
msgid "Distributed transaction"
msgstr "Transação distribuída"

#: ../../chapter-07.rst:1541
msgid ""
"At the time of writing this feature is only supported by PostgreSQL, MySQL "
"and Firebird, since they expose API for two-phase commits."
msgstr ""
"No momento da escrita deste recurso só é suportado pelo PostgreSQL, MySQL e "
"Firebird, uma vez que expõem API para commits de duas fases."

#: ../../chapter-07.rst:1544
msgid ""
"Assuming you have two (or more) connections to distinct PostgreSQL "
"databases, for example:"
msgstr ""
"Supondo que você tenha dois (ou mais) conexões com bancos de dados "
"PostgreSQL distintas, por exemplo:"

#: ../../chapter-07.rst:1552
msgid "In your models or controllers, you can commit them concurrently with:"
msgstr ""
"Em seus modelos ou controladores, você pode cometê-los simultaneamente com:"

#: ../../chapter-07.rst:1558
msgid "On failure, this function rolls back and raises an ``Exception``."
msgstr "Em case de falha, esta função desfaz e levanta uma `` Exception``."

#: ../../chapter-07.rst:1560
msgid ""
"In controllers, when one action returns, if you have two distinct "
"connections and you do not call the above function, py4web commits them "
"separately. This means there is a possibility that one of the commits "
"succeeds and one fails. The distributed transaction prevents this from "
"happening."
msgstr ""
"Em controladores, quando uma ação retornos, se você tiver duas ligações "
"distintas e você não chamar a função acima, py4web compromete-los "
"separadamente. Isto significa que há uma possibilidade de que um dos "
"commits sucede e uma falha. A transação distribuída impede que isso "
"aconteça."

#: ../../chapter-07.rst:1567
msgid "More on uploads"
msgstr "Mais sobre envios"

#: ../../chapter-07.rst:1569
msgid "Consider the following model:"
msgstr "Considere o seguinte modelo:"

#: ../../chapter-07.rst:1576
msgid ""
"In the case of an “upload” field, the default value can optionally be set "
"to a path (an absolute path or a path relative to the current app folder), "
"the default value is then assigned to each new record that does not specify "
"an image."
msgstr ""
"No case de um campo de “carregamento”, o valor padrão pode, opcionalmente, "
"ser definida como um caminho (um caminho absoluto ou um caminho relativo "
"para a pasta aplicativo atual), o valor padrão é então atribuído a cada "
"novo registro que não especifica um imagem."

#: ../../chapter-07.rst:1581
msgid ""
"Notice that this way multiple records may end to reference the same default "
"image file and this could be a problem on a Field having ``autodelete`` "
"enabled. When you do not want to allow duplicates for the image field (i."
"e. multiple records referencing the same file) but still want to set a "
"default value for the “upload” then you need a way to copy the default file "
"for each new record that does not specify an image. This can be obtained "
"using a file-like object referencing the default file as the ``default`` "
"argument to Field, or even with:"
msgstr ""
"Observe que desta forma vários registros podem acabar com referência ao "
"mesmo arquivo de imagem padrão e isso poderia ser um problema em um campo "
"ter `` autodelete`` habilitado. Quando você não quer permitir duplicatas "
"para o campo de imagem (ou seja, vários registros referenciando o mesmo "
"arquivo), mas ainda quer definir um valor padrão para o “carregamento”, "
"então você precisa de uma forma de copiar o arquivo padrão para cada novo "
"registro que faz não especificar uma imagem. Isto pode ser obtido usando um "
"arquivo-como objeto referenciando o arquivo padrão como o argumento `` "
"default`` ao campo, ou mesmo com:"

#: ../../chapter-07.rst:1594
msgid ""
"Normally an insert is handled automatically via a ``Form`` but occasionally "
"you already have the file on the filesystem and want to upload it "
"programmatically. This can be done in this way:"
msgstr ""
"Normalmente uma inserção é feita automaticamente através de um `` Form`` "
"mas ocasionalmente você já tem o arquivo no sistema de arquivos e quer "
"enviá-lo por meio de programação. Isso pode ser feito da seguinte maneira:"

#: ../../chapter-07.rst:1603
msgid ""
"It is also possible to insert a file in a simpler way and have the insert "
"method call ``store`` automatically:"
msgstr ""
"Também é possível inserir um arquivo de uma forma mais simples e tem a "
"chamada de método de inserção `` store`` automaticamente:"

#: ../../chapter-07.rst:1611
msgid ""
"In this case the filename is obtained from the stream object if available."
msgstr ""
"Neste case, o nome do ficheiro é obtido a partir do objecto corrente, se "
"disponível."

#: ../../chapter-07.rst:1614
msgid ""
"The ``store`` method of the upload field object takes a file stream and a "
"filename. It uses the filename to determine the extension (type) of the "
"file, creates a new temp name for the file (according to py4web upload "
"mechanism) and loads the file content in this new temp file (under the "
"uploads folder unless specified otherwise). It returns the new temp name, "
"which is then stored in the ``image`` field of the ``db.myfile`` table."
msgstr ""
"O método `store`` do objeto campo carregamento leva um fluxo de arquivo e "
"um nome de arquivo. Ele usa o nome do arquivo para determinar a extensão "
"(tipo) do arquivo, cria um novo nome temporário para o arquivo (de acordo "
"com mecanismo de upload py4web) e carrega o conteúdo do arquivo neste novo "
"arquivo temporário (sob os envios de pasta salvo indicação em contrário). "
"Ele retorna o novo nome temp, que é então armazenada no campo `` image`` da "
"tabela `` db.myfile``."

#: ../../chapter-07.rst:1622
msgid ""
"Note, if the file is to be stored in an associated blob field rather than "
"the file system, the ``store`` method will not insert the file in the blob "
"field (because ``store`` is called before the insert), so the file must be "
"explicitly inserted into the blob field:"
msgstr ""
"Note, se o arquivo deve ser armazenado em um campo blob associado ao invés "
"do sistema de arquivos, o método `store`` não irá inserir o arquivo no "
"campo blob (porque` `store`` é chamado antes da inserção), portanto, o "
"arquivo deve ser explicitamente inserido no campo blob:"

#: ../../chapter-07.rst:1636
msgid "The ``retrieve`` method does the opposite of ``store``."
msgstr "O método `retrieve`` faz o oposto do` `store``."

#: ../../chapter-07.rst:1638
msgid ""
"When uploaded files are stored on filesystem (as in the case of a plain "
"``Field('image', 'upload')``) the code:"
msgstr ""
"Quando os arquivos enviados são armazenados no sistema de arquivos (como no "
"case de um `` Field ( 'imagem' simples, 'upload') ``) o código:"

#: ../../chapter-07.rst:1646
msgid ""
"retrieves the original file name (filename) as seen by the user at upload "
"time and the name of stored file (fullname, with path relative to "
"application folder). While in general the call:"
msgstr ""
"recupera o nome do arquivo original (filename) como visto pelo usuário em "
"tempo de upload e o nome do arquivo armazenado (fullname, com caminho "
"relativo para a pasta da aplicação). Embora, em geral, a chamada:"

#: ../../chapter-07.rst:1654
msgid ""
"retrieves the original file name (filename) and a file-like object ready to "
"access uploaded file data (stream)."
msgstr ""
"recupera o nome original do arquivo (filename) e um arquivo-como objeto "
"pronto para dados de arquivo de acesso carregado (stream)."

#: ../../chapter-07.rst:1657
msgid ""
"Notice that the stream returned by ``retrieve`` is a real file object in "
"the case that uploaded files are stored on filesystem. In that case "
"remember to close the file when you are done, calling ``stream.close()``."
msgstr ""
"Observe que o fluxo retornado por `` retrieve`` é um objeto de arquivo real "
"no case de que os arquivos enviados são armazenados no sistema de arquivos. "
"Nesse case, lembre-se de fechar o arquivo quando você é feito, chamando `` "
"stream.close () ``."

#: ../../chapter-07.rst:1662
msgid "Here is an example of safe usage of ``retrieve``:"
msgstr "Aqui está um exemplo de uso seguro do `` retrieve``:"

#: ../../chapter-07.rst:1674
msgid "``Query``, ``Set``, ``Rows``"
msgstr "`` Query``, `` Set``, `` Rows``"

#: ../../chapter-07.rst:1676
msgid ""
"Let’s consider again the table defined (and dropped) previously and insert "
"three records:"
msgstr ""
"Vamos considerar novamente a tabela definida (e caiu) anteriormente e "
"inserir três registros:"

#: ../../chapter-07.rst:1690
msgid ""
"You can store the table in a variable. For example, with variable "
"``person``, you could do:"
msgstr ""
"Você pode armazenar a tabela em uma variável. Por exemplo, com variável `` "
"Person``, você poderia fazer:"

#: ../../chapter-07.rst:1697
msgid ""
"You can also store a field in a variable such as ``name``. For example, you "
"could also do:"
msgstr ""
"Você também pode armazenar um campo em uma variável como `` name``. Por "
"exemplo, você também pode fazer:"

#: ../../chapter-07.rst:1704
msgid ""
"You can even build a query (using operators like ==, !=, <, >, <=, >=, "
"like, belongs) and store the query in a variable ``q`` such as in:"
msgstr ""
"Você pode até criar uma consulta (usando operadores como ==, =, <,>, <=,> "
"=, como, pertence!) E armazenar a consulta em uma variável `` q`` tal como "
"em:"

#: ../../chapter-07.rst:1711
msgid ""
"When you call ``db`` with a query, you define a set of records. You can "
"store it in a variable ``s`` and write:"
msgstr ""
"Quando você chamar `` db`` com uma consulta, você define um conjunto de "
"registros. Você pode armazená-lo em uma variável `` s`` e escreve:"

#: ../../chapter-07.rst:1718
msgid ""
"Notice that no database query has been performed so far. DAL + Query simply "
"define a set of records in this db that match the query. py4web determines "
"from the query which table (or tables) are involved and, in fact, there is "
"no need to specify that."
msgstr ""
"Observe que nenhuma consulta de banco de dados foi realizada até agora. DAL "
"+ consulta simplesmente definir um conjunto de registros neste db que "
"correspondem a consulta. py4web determina a partir da consulta que tabela "
"(ou tabelas) estão envolvidos e, de fato, não há necessidade de especificar "
"isso."

#: ../../chapter-07.rst:1724
msgid "``select`` command"
msgstr "`` Comando SELECT``"

#: ../../chapter-07.rst:1726
msgid ""
"Given a Set, ``s``, you can fetch the records with the command ``select``:"
msgstr ""
"Dado um conjunto, `` s``, você pode buscar os registros com o comando `` "
"SELECT``:"

#: ../../chapter-07.rst:1733
msgid ""
"It returns an iterable object of class ``pydal.objects.Rows`` whose "
"elements are Row objects. ``pydal.objects.Row`` objects act like "
"dictionaries, but their elements can also be accessed as attributes, like "
"``gluon.storage.Storage``.The former differ from the latter because its "
"values are read-only."
msgstr ""
"Ele retorna um objecto de classe iteráveis ​​`` pydal.objects.Rows`` cujos "
"elementos são objectos da fileira. `` Pydal.objects.Row`` objetos agir como "
"dicionários, mas os seus elementos também pode ser acedida como atributos, "
"como `` gluon.storage.Storage``.The ex diferente do último porque os seus "
"valores são apenas para leitura."

#: ../../chapter-07.rst:1739
msgid ""
"The Rows object allows looping over the result of the select and printing "
"the selected field values for each row:"
msgstr ""
"O objecto Fileiras permite loop sobre o resultado do seleccionar e "
"imprimindo os valores dos campos seleccionados para cada linha:"

#: ../../chapter-07.rst:1749
msgid "You can do all the steps in one statement:"
msgstr "Você pode fazer todas as etapas em uma declaração:"

#: ../../chapter-07.rst:1758
msgid ""
"The select command can take arguments. All unnamed arguments are "
"interpreted as the names of the fields that you want to fetch. For example, "
"you can be explicit on fetching field “id” and field “name”:"
msgstr ""
"O comando select pode tomar argumentos. Todos os argumentos sem nome são "
"interpretados como os nomes dos campos que você deseja buscar. Por exemplo, "
"você pode ser explícita no campo “id” e no campo “nome” buscar:"

#: ../../chapter-07.rst:1771
msgid "The table attribute ALL allows you to specify all fields:"
msgstr "O atributo mesa ALL permite especificar todos os campos:"

#: ../../chapter-07.rst:1782
msgid ""
"Notice that there is no query string passed to db. py4web understands that "
"if you want all fields of the table person without additional information "
"then you want all records of the table person."
msgstr ""
"Observe que não há nenhuma strings de consulta passada para db. py4web "
"entende que se você quiser todos os campos da pessoa mesa sem informações "
"adicionais, então você quer todos os registros da pessoa mesa."

#: ../../chapter-07.rst:1786
msgid "An equivalent alternative syntax is the following:"
msgstr "Uma sintaxe alternativa equivalente é o seguinte:"

#: ../../chapter-07.rst:1797
msgid ""
"and py4web understands that if you ask for all records of the table person "
"without additional information, then you want all the fields of table "
"person."
msgstr ""
"e py4web entende que se você perguntar para todos os registros da pessoa "
"mesa sem informações adicionais, então você quer todos os campos da tabela "
"pessoa."

#: ../../chapter-07.rst:1801
msgid "Given one row"
msgstr "Dada uma linha"

#: ../../chapter-07.rst:1807
msgid "you can extract its values using multiple equivalent expressions:"
msgstr "você pode extrair seus valores usando várias expressões equivalentes:"

#: ../../chapter-07.rst:1818
msgid ""
"The latter syntax is particularly handy when selecting en expression "
"instead of a column. We will show this later."
msgstr ""
"O último sintaxe é particularmente útil quando se selecciona en expressão "
"em vez de uma coluna. Vamos mostrar isso mais tarde."

#: ../../chapter-07.rst:1821
msgid "You can also do"
msgstr "Você também pode fazer"

#: ../../chapter-07.rst:1827
msgid "to disable the notation"
msgstr "desativar a notação"

#: ../../chapter-07.rst:1833
msgid "and enable, instead, the less compact notation:"
msgstr "e permitir que, em vez disso, a notação menos compacto:"

#: ../../chapter-07.rst:1839
msgid "Yes this is unusual and rarely needed."
msgstr "Sim isso é incomum e raramente necessário."

#: ../../chapter-07.rst:1841
msgid "Row objects also have two important methods:"
msgstr "Row objetos também tem dois métodos importantes:"

#: ../../chapter-07.rst:1847
msgid "and"
msgstr "e"

#: ../../chapter-07.rst:1854
msgid "Using an iterator-based select for lower memory use"
msgstr "Usando um seleto para uso de memória inferior à base de iterador"

#: ../../chapter-07.rst:1856
msgid ""
"Python “iterators” are a type of “lazy-evaluation”. They ‘feed’ data one "
"step at time; traditional Python loops create the entire set of data in "
"memory before looping."
msgstr ""
"Python “iterators” são um tipo de “preguiçoso-avaliação”. Eles dados "
"‘alimentar’ um passo de tempo; laços tradicionais Python criar todo o "
"conjunto de dados na memória antes de looping."

#: ../../chapter-07.rst:1860
msgid "The traditional use of select is:"
msgstr "O uso tradicional de selecionar é:"

#: ../../chapter-07.rst:1867
msgid ""
"but for large numbers of rows, using an iterator-based alternative has "
"dramatically lower memory use:"
msgstr ""
"mas para um grande número de linhas, usando uma alternativa à base de "
"iterador tem uso de memória dramaticamente inferior:"

#: ../../chapter-07.rst:1875
msgid ""
"Testing shows this is around 10% faster as well, even on machines with "
"large RAM."
msgstr ""
"Testes mostram que  isto é de cerca de 10% mais rápido, mesmo em máquinas "
"com muita RAM."

#: ../../chapter-07.rst:1879
msgid "Rendering rows using represent"
msgstr "Renderizando Rows com represent"

#: ../../chapter-07.rst:1881
msgid ""
"You may wish to rewrite rows returned by select to take advantage of "
"formatting information contained in the represents setting of the fields."
msgstr ""
"Você pode querer reescrever linhas retornadas por seleção para tirar "
"proveito de informações de formatação contida na representa a criação dos "
"campos."

#: ../../chapter-07.rst:1890
msgid ""
"If you don’t specify an index, you get a generator to iterate over all the "
"rows:"
msgstr ""
"Se você não especificar um índice, você tem um gerador para iterar sobre "
"todas as linhas:"

#: ../../chapter-07.rst:1898
msgid "Can also be applied to slices:"
msgstr "Também pode ser aplicada a fatias:"

#: ../../chapter-07.rst:1905
msgid ""
"If you only want to transform selected fields via their “represent” "
"attribute, you can list them in the “fields” argument:"
msgstr ""
"Se você só quer transformar campos selecionados através do seu atributo "
"“representar”, você pode incluí-los no argumento “campos”:"

#: ../../chapter-07.rst:1912
msgid ""
"Note, it returns a transformed copy of the original Row, so there’s no "
"update_record (which you wouldn’t want anyway) or delete_record."
msgstr ""
"Note, ele retorna uma cópia transformada da linha original, então não há "
"nenhuma update_record (que você não iria querer de qualquer maneira) ou "
"delete_record."

#: ../../chapter-07.rst:1916
msgid "Shortcuts"
msgstr "Atalhos"

#: ../../chapter-07.rst:1918
msgid "The DAL supports various code-simplifying shortcuts. In particular:"
msgstr "A DAL suporta vários atalhos-simplificando código. Em particular:"

#: ../../chapter-07.rst:1924
msgid ""
"returns the record with the given ``id`` if it exists. If the ``id`` does "
"not exist, it returns ``None``. The above statement is equivalent to"
msgstr ""
"retorna o registro com o dado `` id`` se ele existir. Se o `` id`` não "
"existe, ele retorna `` None``. A declaração acima é equivalente a"

#: ../../chapter-07.rst:1932
msgid "You can delete records by id:"
msgstr "Você pode excluir registros por id:"

#: ../../chapter-07.rst:1938
msgid "and this is equivalent to"
msgstr "e isto é equivalente a"

#: ../../chapter-07.rst:1944
msgid "and deletes the record with the given ``id``, if it exists."
msgstr "e exclui o registro com o dado `` id``, se ele existir."

#: ../../chapter-07.rst:1946
msgid ""
"Note: this delete shortcut syntax does not currently work if *versioning* "
"is activated"
msgstr ""
"Nota: esta sintaxe de atalho de exclusão actualmente não trabalha se * "
"versionamento * é ativado"

#: ../../chapter-07.rst:1949
msgid "You can insert records:"
msgstr "Você pode inserir registros:"

#: ../../chapter-07.rst:1955
msgid "It is equivalent to"
msgstr "É equivalente a"

#: ../../chapter-07.rst:1961
msgid ""
"and it creates a new record with field values specified by the dictionary "
"on the right hand side."
msgstr ""
"e cria um novo registro com valores de campos especificados pelo dicionário "
"sobre o lado direito."

#: ../../chapter-07.rst:1964
msgid ""
"Note: insert shortcut was previously ``db.table[0] = ...``. It has changed "
"in PyDAL 19.02 to permit normal usage of id 0."
msgstr ""
"Nota: atalho inserção anteriormente era `` db.table [0] = ... ``. Ele mudou "
"em PyDAL 19,02 para permitir o uso normal de identificação 0."

#: ../../chapter-07.rst:1967
msgid "You can update records:"
msgstr "Você pode atualizar os registros:"

#: ../../chapter-07.rst:1973 ../../chapter-07.rst:2017
msgid "which is equivalent to"
msgstr "o qual é equivalente a"

#: ../../chapter-07.rst:1979
msgid ""
"and it updates an existing record with field values specified by the "
"dictionary on the right hand side."
msgstr ""
"e atualiza um registro existente com os valores dos campos especificados "
"pelo dicionário sobre o lado direito."

#: ../../chapter-07.rst:1983
msgid "Fetching a ``Row``"
msgstr "A obtenção de um `` row``"

#: ../../chapter-07.rst:1985
msgid "Yet another convenient syntax is the following:"
msgstr "No entanto, outra sintaxe conveniente é o seguinte:"

#: ../../chapter-07.rst:1993
msgid ""
"Apparently similar to ``db.mytable[id]`` the above syntax is more flexible "
"and safer. First of all it checks whether ``id`` is an int (or ``str(id)`` "
"is an int) and returns ``None`` if not (it never raises an exception). It "
"also allows to specify multiple conditions that the record must meet. If "
"they are not met, it also returns ``None``."
msgstr ""
"Aparentemente semelhante a `` db.mytable [id] `` a sintaxe acima é mais "
"flexível e mais seguro. Antes de tudo, verifica se `` id`` é um int (ou `` "
"str (id) `` é um int) e retorna `` None`` se não (nunca levanta uma "
"exceção). Ele também permite especificar várias condições que o registro "
"deve atender. Se eles não forem atendidas, ele também retorna `` None``."

#: ../../chapter-07.rst:2000
msgid "Recursive ``select``\\ s"
msgstr "Recursivas `` \\ s SELECT``"

#: ../../chapter-07.rst:2002
msgid ""
"Consider the previous table person and a new table “thing” referencing a "
"“person”:"
msgstr ""
"Considere a pessoa tabela anterior e uma nova tabela “coisa” fazendo "
"referência a uma “pessoa”:"

#: ../../chapter-07.rst:2011
msgid "and a simple select from this table:"
msgstr "e um simples selecionar a partir desta tabela:"

#: ../../chapter-07.rst:2023
msgid ""
"where ``_id`` is a reference to the primary key of the table. Normally ``db."
"thing._id`` is the same as ``db.thing.id`` and we will assume that in most "
"of this book."
msgstr ""
"onde `` _id`` é uma referência para a chave principal da tabela. "
"Normalmente `` db.thing._id`` é o mesmo que `` db.thing.id`` e vamos supor "
"que na maior parte deste livro."

#: ../../chapter-07.rst:2027
msgid ""
"For each Row of things it is possible to fetch not just fields from the "
"selected table (thing) but also from linked tables (recursively):"
msgstr ""
"Para cada linha de coisas é possível buscar não apenas campos da tabela "
"selecionada (coisa), mas também a partir de tabelas vinculadas (de forma "
"recursiva):"

#: ../../chapter-07.rst:2035
msgid ""
"Here ``thing.owner_id.name`` requires one database select for each thing in "
"things and it is therefore inefficient. We suggest using joins whenever "
"possible instead of recursive selects, nevertheless this is convenient and "
"practical when accessing individual records."
msgstr ""
"Aqui `` thing.owner_id.name`` requer um banco de dados escolha para cada "
"coisa em coisas e por isso é ineficiente. Sugerimos usando junta sempre que "
"possível, em vez de seleciona recursiva, no entanto, este é conveniente e "
"prático ao acessar registros individuais."

#: ../../chapter-07.rst:2040
msgid ""
"You can also do it backwards, by selecting the things referenced by a "
"person:"
msgstr ""
"Você também pode fazê-lo para trás, escolhendo os coisas referenciados por "
"uma pessoa:"

#: ../../chapter-07.rst:2049
msgid "In this last expression ``person.thing`` is a shortcut for"
msgstr "Nesta última expressão `` person.thing`` é um atalho para"

#: ../../chapter-07.rst:2055
msgid ""
"i.e. the Set of ``thing``\\ s referenced by the current ``person``. This "
"syntax breaks down if the referencing table has multiple references to the "
"referenced table. In this case one needs to be more explicit and use a full "
"Query."
msgstr ""
"isto é, o conjunto de thing`` `` \\ s referenciados pelos actuais `` "
"Person``. Esta sintaxe se decompõe se a tabela referenciando tem várias "
"referências à tabela referenciada. Neste case é preciso ser mais explícito "
"e usar uma consulta completa."

#: ../../chapter-07.rst:2061
msgid ""
"``orderby``, ``groupby``, ``limitby``, ``distinct``, ``having``, "
"``orderby_on_limitby``, ``join``, ``left``, ``cache``"
msgstr ""
"`` Orderby``, `` groupby``, `` limitby``, `` distinct``, `` having``, `` "
"orderby_on_limitby``, `` join``, `` left``, `` cache``"

#: ../../chapter-07.rst:2063
msgid "The ``select`` command takes a number of optional arguments."
msgstr "O comando `` SELECT`` leva uma série de argumentos opcionais."

#: ../../chapter-07.rst:2066
msgid "orderby"
msgstr "ordenar por"

#: ../../chapter-07.rst:2068
msgid "You can fetch the records sorted by name:"
msgstr "Você pode buscar os registros classificados pelo nome:"

#: ../../chapter-07.rst:2079
msgid ""
"You can fetch the records sorted by name in reverse order (notice the "
"tilde):"
msgstr ""
"Você pode buscar os registros classificados pelo nome em ordem inversa "
"(aviso o til):"

#: ../../chapter-07.rst:2091
msgid "You can have the fetched records appear in random order:"
msgstr "Você pode ter os registros obtida aparecem em ordem aleatória:"

#: ../../chapter-07.rst:2104
msgid ""
"The use of ``orderby='<random>'`` is not supported on Google NoSQL. "
"However, to overcome this limit, sorting can be accomplished on selected "
"rows:"
msgstr ""
"O uso de `` orderby = '<random>' `` não é suportada no Google NoSQL. No "
"entanto, para superar esse limite, a classificação pode ser feito em linhas "
"selecionadas:"

#: ../../chapter-07.rst:2113
msgid ""
"You can sort the records according to multiple fields by concatenating them "
"with a “\\|”:"
msgstr ""
"Você pode classificar os registros de acordo com vários campos concatenando-"
"los com um “\\ |”:"

#: ../../chapter-07.rst:2126
msgid "groupby, having"
msgstr "groupby, tendo"

#: ../../chapter-07.rst:2128
msgid ""
"Using ``groupby`` together with ``orderby``, you can group records with the "
"same value for the specified field (this is back-end specific, and is not "
"on the Google NoSQL):"
msgstr ""
"Usando `` groupby`` juntamente com `` orderby``, você pode agrupar "
"registros com o mesmo valor para o campo especificado (isto é back-end "
"específico, e não é sobre o Google NoSQL):"

#: ../../chapter-07.rst:2143
msgid ""
"You can use ``having`` in conjunction with ``groupby`` to group "
"conditionally (only those ``having`` the condition are grouped)."
msgstr ""
"Pode usar `` having`` em conjunto com `` groupby`` ao grupo "
"condicionalmente (apenas aqueles `` having`` a condição estão agrupados)."

#: ../../chapter-07.rst:2150
msgid ""
"Notice that query1 filters records to be displayed, query2 filters records "
"to be grouped."
msgstr ""
"Observe que os registros filtros Consulta1 a ser exibido, registros filtros "
"Query2 ser agrupados."

#: ../../chapter-07.rst:2154
msgid "distinct"
msgstr "distinto"

#: ../../chapter-07.rst:2156
msgid ""
"With the argument ``distinct=True``, you can specify that you only want to "
"select distinct records. This has the same effect as grouping using all "
"specified fields except that it does not require sorting. When using "
"distinct it is important not to select ALL fields, and in particular not to "
"select the “id” field, else all records will always be distinct."
msgstr ""
"Com o argumento `` distinta = True``, você pode especificar que você só "
"quer selecionar registros distintos. Isto tem o mesmo efeito que o "
"agrupamento usando todos os campos especificados, exceto que ele não "
"necessita de classificação. Ao usar distinta é importante não para "
"selecionar todos os campos, e em particular para não selecionar o campo "
"“id”, senão todos os registros serão sempre distintas."

#: ../../chapter-07.rst:2162 ../../chapter-07.rst:4117
msgid "Here is an example:"
msgstr "Aqui está um exemplo:"

#: ../../chapter-07.rst:2173
msgid "Notice that ``distinct`` can also be an expression, for example:"
msgstr "Note que `` distinct`` também pode ser uma expressão, por exemplo:"

#: ../../chapter-07.rst:2185
msgid "limitby"
msgstr "limitby"

#: ../../chapter-07.rst:2187
msgid ""
"With ``limitby=(min, max)``, you can select a subset of the records from "
"offset=min to but not including offset=max. In the next example we select "
"the first two records starting at zero:"
msgstr ""
"Com `` limitby = (min, max) ``, pode seleccionar um subconjunto dos "
"registos de deslocamento = min, mas não incluindo offset = máx. No próximo "
"exemplo nós selecionamos os dois primeiros registros a partir de zero:"

#: ../../chapter-07.rst:2200
msgid "orderby_on_limitby"
msgstr "orderby_on_limitby"

#: ../../chapter-07.rst:2202
msgid ""
"Note that the DAL defaults to implicitly adding an orderby when using a "
"limitby. This ensures the same query returns the same results each time, "
"important for pagination. But it can cause performance problems. use "
"``orderby_on_limitby = False`` to change this (this defaults to True)."
msgstr ""
"Note-se que os padrões DAL de adicionar implicitamente um orderby ao usar "
"um limitby. Isso garante a mesma consulta retorna os mesmos resultados de "
"cada vez, importante para a paginação. Mas pode causar problemas de "
"desempenho. use `` orderby_on_limitby = False`` para mudar isso (isso o "
"padrão é True)."

#: ../../chapter-07.rst:2208
msgid "join, left"
msgstr "juntar-se, deixou"

#: ../../chapter-07.rst:2210
msgid ""
"These are involved in managing *one to many relations* . They are described "
"in *Inner join* and *Left outer join* sections respectively."
msgstr ""
"Estes estão envolvidos na gestão * um para muitas relações *. Eles são "
"descritos em * INNER JOIN * e exterior * LEFT JOIN seções * respectivamente."

#: ../../chapter-07.rst:2214
msgid "cache, cacheable"
msgstr "cache, em cache"

#: ../../chapter-07.rst:2216
msgid ""
"An example use which gives much faster selects is: ``rows = db(query)."
"select(cache=(cache.get, 3600), cacheable=True)``:python Look at *Caching "
"selects* section in this chapter, to understand what the trade-offs are."
msgstr ""
"Um uso exemplo que dá muito mais rápido seleciona é: `` linhas = db "
"(query) .Select (cache = (cache.get, 3600), cacheable = True) ``: Olhar "
"python na seção * * Caching seleciona neste capítulo, para entender o que "
"os trade-offs são."

#: ../../chapter-07.rst:2222
msgid "Logical operators"
msgstr "Operadores lógicos"

#: ../../chapter-07.rst:2224
msgid "Queries can be combined using the binary AND operator “``&``”:"
msgstr ""
"As consultas podem ser combinados usando o binário operador AND “` `&` `”:"

#: ../../chapter-07.rst:2233
msgid "and the binary OR operator “``|``”:"
msgstr "eo binário operador OR “` `|` `”:"

#: ../../chapter-07.rst:2241
msgid "You can negate a sub-query inverting its operator:"
msgstr "Você pode negar uma sub-consulta invertendo o seu operador:"

#: ../../chapter-07.rst:2250
msgid "or by explicit negation with the “``~``” unary operator:"
msgstr "ou pela negação explícita com o “` `~` `” operador unário:"

#: ../../chapter-07.rst:2261
msgid ""
"Due to Python restrictions in overloading “``and``” and “``or``” operators, "
"these cannot be used in forming queries. The binary operators “``&``” and "
"“``|``” must be used instead. Note that these operators (unlike “``and``” "
"and “``or``”) have higher precedence than comparison operators, so the "
"“extra” parentheses in the above examples are mandatory. Similarly, the "
"unary operator “``~``” has higher precedence than comparison operators, so "
"``~``-negated comparisons must also be parenthesized."
msgstr ""
"Devido a restrições de Python em sobrecarga “` `and``” e “` `or``” "
"operadores, estes não podem ser utilizados na formação de consultas. Os "
"operadores binários “` `&` `” e “` `|` `” deve ser usado em seu lugar. Note-"
"se que estes operadores (ao contrário de “` `and``” e “` `or``”) tem "
"precedência maior do que os operadores de comparação, de modo que os "
"parênteses “extra” nos exemplos acima são de preenchimento obrigatório. Da "
"mesma forma, o operador unitário “~` `` `” tem precedência mais elevada do "
"que os operadores de comparação, de modo ~ `` `` comparações -negated "
"também deve estar entre parênteses."

#: ../../chapter-07.rst:2270
msgid "It is also possible to build queries using in-place logical operators:"
msgstr ""
"Também é possível consultas construir usando in-place operadores lógicos:"

#: ../../chapter-07.rst:2279
msgid "``count``, ``isempty``, ``delete``, ``update``"
msgstr "`` Count``, `` isempty``, `` DELETE``, `` update``"

#: ../../chapter-07.rst:2281
msgid "You can count records in a set:"
msgstr "Você pode contar registros em um conjunto:"

#: ../../chapter-07.rst:2288
msgid ""
"Notice that ``count`` takes an optional ``distinct`` argument which "
"defaults to False, and it works very much like the same argument for "
"``select``. ``count`` has also a ``cache`` argument that works very much "
"like the equivalent argument of the ``select`` method."
msgstr ""
"Note que `` count`` leva um opcional `` distinct`` argumento que o padrão é "
"falso, e ele funciona muito parecido com o mesmo argumento para `` "
"SELECT``. `` Count`` tem também um argumento `` cache`` que funciona muito "
"parecido com o argumento equivalente do método `SELECT``."

#: ../../chapter-07.rst:2293
msgid ""
"Sometimes you may need to check if a table is empty. A more efficient way "
"than counting is using the ``isempty`` method:"
msgstr ""
"Às vezes você pode precisar verificar se uma tabela está vazia. Uma maneira "
"mais eficiente do que a contagem está a utilizar o método `isempty``:"

#: ../../chapter-07.rst:2301
msgid "You can delete records in a set:"
msgstr "Você pode excluir registros em um jogo:"

#: ../../chapter-07.rst:2308
msgid "The ``delete`` method returns the number of records that were deleted."
msgstr ""
"A `` DELETE`` método devolve o número de registos que foram eliminados."

#: ../../chapter-07.rst:2310
msgid ""
"And you can update all records in a set by passing named arguments "
"corresponding to the fields that need to be updated:"
msgstr ""
"E você pode atualizar todos os registros em um conjunto, passando "
"argumentos nomeados correspondentes aos campos que precisam ser atualizados:"

#: ../../chapter-07.rst:2318
msgid "The ``update`` method returns the number of records that were updated."
msgstr ""
"O método `update`` retorna o número de registros que foram atualizados."

#: ../../chapter-07.rst:2321
msgid "Expressions"
msgstr "Expressões"

#: ../../chapter-07.rst:2323
msgid ""
"The value assigned an update statement can be an expression. For example "
"consider this model"
msgstr ""
"O valor atribuído uma instrução de atualização pode ser uma expressão. Por "
"exemplo, considere este modelo"

#: ../../chapter-07.rst:2334
msgid "The values used in queries can also be expressions"
msgstr "Os valores usados ​​em consultas também podem ser expressões"

#: ../../chapter-07.rst:2346
msgid "``case``"
msgstr "`` case``"

#: ../../chapter-07.rst:2348
msgid "An expression can contain a case clause for example:"
msgstr "Uma expressão pode conter uma cláusula case, por exemplo:"

#: ../../chapter-07.rst:2362
msgid "``update_record``"
msgstr "`` Update_record``"

#: ../../chapter-07.rst:2364
msgid ""
"py4web also allows updating a single record that is already in memory using "
"``update_record``"
msgstr ""
"py4web também permite actualizar um único registro que já está na memória "
"usando `` update_record``"

#: ../../chapter-07.rst:2373
msgid "``update_record`` should not be confused with"
msgstr "`` Update_record`` não deve ser confundido com"

#: ../../chapter-07.rst:2379
msgid ""
"because for a single row, the method ``update`` updates the row object but "
"not the database record, as in the case of ``update_record``."
msgstr ""
"porque para uma única linha, o método `` update`` atualiza o objeto de "
"linha, mas não o registro de banco de dados, como no case de `` "
"update_record``."

#: ../../chapter-07.rst:2382
msgid ""
"It is also possible to change the attributes of a row (one at a time) and "
"then call ``update_record()`` without arguments to save the changes:"
msgstr ""
"Também é possível alterar os atributos de uma linha (um de cada vez) e, em "
"seguida, chamar `` update_record () `` sem argumentos para salvar as "
"alterações:"

#: ../../chapter-07.rst:2394
msgid ""
"Note, you should avoid using ``row.update_record()`` with no arguments when "
"the ``row`` object contains fields that have an ``update`` attribute (e.g., "
"``Field('modified_on', update=request.now)``). Calling ``row."
"update_record()`` will retain *all* of the existing values in the ``row`` "
"object, so any fields with ``update`` attributes will have no effect in "
"this case. Be particularly mindful of this with tables that include ``auth."
"signature``."
msgstr ""
"Note, você deve evitar o uso de `` row.update_record () `` sem argumentos "
"quando o objeto `` row`` contém campos que têm um atributo `` update`` (por "
"exemplo, `` Field ( 'modified_on', update = request.now) ``). Chamando `` "
"row.update_record () `` irá reter * todos * os valores existentes no objeto "
"`` row``, portanto, quaisquer campos com `` atributos update`` não terá "
"nenhum efeito neste case. Seja particularmente atento a isso com mesas que "
"incluem `` auth.signature``."

#: ../../chapter-07.rst:2403
msgid ""
"The ``update_record`` method is available only if the table’s ``id`` field "
"is included in the select, and ``cacheable`` is not set to ``True``."
msgstr ""
"O método `update_record`` está disponível apenas se campo` `id`` da tabela "
"está incluído no seleto, e` `cacheable`` não está definido para` `True``."

#: ../../chapter-07.rst:2408
msgid "Inserting and updating from a dictionary"
msgstr "Inserir e atualizar a partir de um dicionário"

#: ../../chapter-07.rst:2410
msgid ""
"A common issue consists of needing to insert or update records in a table "
"where the name of the table, the field to be updated, and the value for the "
"field are all stored in variables. For example: ``tablename``, "
"``fieldname``, and ``value``."
msgstr ""
"Um problema comum é composto de precisar inserir ou atualizar registros em "
"uma tabela onde o nome da tabela, o campo para ser atualizado, eo valor "
"para o campo são armazenados em variáveis. Por exemplo: `` tablename``, `` "
"fieldname``, e `` value``."

#: ../../chapter-07.rst:2415
msgid "The insert can be done using the following syntax:"
msgstr "A inserção pode ser feito usando a seguinte sintaxe:"

#: ../../chapter-07.rst:2421
msgid "The update of record with given id can be done with:"
msgstr "A atualização do registro com dado id pode ser feito com:"

#: ../../chapter-07.rst:2427
msgid ""
"Notice we used ``table._id`` instead of ``table.id``. In this way the query "
"works even for tables with a primary key field with type other than “id”."
msgstr ""
"Observe que usamos `` table._id`` ao invés de `` table.id``. Desta forma, a "
"consulta funciona mesmo para tabelas com um campo de chave primária com o "
"tipo diferente de “id”."

#: ../../chapter-07.rst:2432
msgid "``first`` and ``last``"
msgstr "`` `` First`` e last``"

#: ../../chapter-07.rst:2434
msgid "Given a Rows object containing records:"
msgstr "Dado um objecto linhas contendo registos:"

#: ../../chapter-07.rst:2442
msgid "are equivalent to"
msgstr "são equivalentes às"

#: ../../chapter-07.rst:2449
msgid ""
"Notice, ``first()`` and ``last()`` allow you to obtain obviously the first "
"and last record present in your query, but this won’t mean that these "
"records are going to be the first or last inserted records. In case you "
"want the first or last record inputted in a given table don’t forget to use "
"``orderby=db.table_name.id``. If you forget you will only get the first and "
"last record returned by your query which are often in a random order "
"determined by the backend query optimiser."
msgstr ""
"Observe, `` primeiro () `` e `` última () `` permitem obter, obviamente, o "
"primeiro e último registro presente em sua consulta, mas isso não significa "
"que esses registros estão indo para ser o primeiro ou o último inserido "
"registros. No case de pretender o primeiro ou último registro inserido em "
"uma determinada tabela não se esqueça de usar `` orderby = db.table_name."
"id``. Se você esquecer você só vai conseguir o primeiro eo último registro "
"retornado pela consulta, que são muitas vezes em uma ordem aleatória "
"determinada pelo otimizador de consulta backend."

#: ../../chapter-07.rst:2458
msgid "``as_dict`` and ``as_list``"
msgstr "`` `` As_dict`` e as_list``"

#: ../../chapter-07.rst:2460
msgid ""
"A Row object can be serialized into a regular dictionary using the "
"``as_dict()`` method and a Rows object can be serialized into a list of "
"dictionaries using the ``as_list()`` method. Here are some examples:"
msgstr ""
"Fila objecto pode ser serializados em um dicionário normal usando a `` "
"as_dict () `` método e um objecto de linhas pode ser serializados em uma "
"lista de dicionários usando a `` as_list () `` método. aqui estão alguns "
"exemplos:"

#: ../../chapter-07.rst:2470
msgid ""
"These methods are convenient for passing Rows to generic views and or to "
"store Rows in sessions (since Rows objects themselves cannot be serialized "
"since contain a reference to an open DB connection):"
msgstr ""
"Estes métodos são convenientes para a passagem de linhas de views genéricas "
"e ou armazena registros em sessões (uma vez que linhas objetos em si não "
"pode ser serializado desde incluir uma referência a uma conexão DB aberto):"

#: ../../chapter-07.rst:2481
msgid "Combining rows"
msgstr "Combinando Rows"

#: ../../chapter-07.rst:2483
msgid "Rows objects can be combined at the Python level. Here we assume:"
msgstr ""
"Fileiras objectos podem ser combinadas no nível Python. Aqui assumimos:"

#: ../../chapter-07.rst:2497
msgid "You can do union of the records in two sets of rows:"
msgstr "Você pode fazer a união dos registros em dois conjuntos de linhas:"

#: ../../chapter-07.rst:2509
msgid "You can do union of the records removing duplicates:"
msgstr "Você pode fazer a união dos registros remoção de duplicatas:"

#: ../../chapter-07.rst:2520
msgid "You can do intersection of the records in two sets of rows:"
msgstr ""
"Você pode fazer intersecção dos registros em dois conjuntos de linhas:"

#: ../../chapter-07.rst:2530
msgid "``find``, ``exclude``, ``sort``"
msgstr "`` Find``, `` exclude``, `` sort``"

#: ../../chapter-07.rst:2532
msgid ""
"Some times you need to perform two selects and one contains a subset of a "
"previous select. In this case it is pointless to access the database again. "
"The ``find``, ``exclude`` and ``sort`` objects allow you to manipulate a "
"Rows object and generate another one without accessing the database. More "
"specifically: - ``find`` returns a new set of Rows filtered by a condition "
"and leaves the original unchanged. - ``exclude`` returns a new set of Rows "
"filtered by a condition and removes them from the original Rows. - ``sort`` "
"returns a new set of Rows sorted by a condition and leaves the original "
"unchanged."
msgstr ""
"Algumas vezes você precisa executar duas seleciona e um contém um "
"subconjunto de um seleto anterior. Neste case, é inútil para acessar o "
"banco de dados novamente. Os `` find``, `` exclude`` e `` objetos sort`` "
"permitem manipular fileiras objeto e gerar outro sem acessar o banco de "
"dados. Mais especificamente: - `` retorna find`` um novo conjunto de linhas "
"filtradas por uma condição e deixa o inalterados originais. - `` retornos "
"exclude`` um novo conjunto de linhas filtrados por uma condição e remove-"
"los das linhas originais. - `` retorna sort`` um novo conjunto de linhas "
"classificadas por uma condição e deixa o inalterados originais."

#: ../../chapter-07.rst:2542
msgid ""
"All these methods take a single argument, a function that acts on each "
"individual row."
msgstr ""
"Todos estes métodos dar um único argumento, uma função que age em cada "
"linha individual."

#: ../../chapter-07.rst:2545
msgid "Here is an example of usage:"
msgstr "Aqui está um exemplo de uso:"

#: ../../chapter-07.rst:2576
msgid "They can be combined:"
msgstr "Eles podem ser combinados:"

#: ../../chapter-07.rst:2588
msgid ""
"Sort takes an optional argument ``reverse=True`` with the obvious meaning."
msgstr ""
"Tipo leva um argumento opcional `` reversa = True`` com o significado óbvio."

#: ../../chapter-07.rst:2591
msgid ""
"The ``find`` method has an optional ``limitby`` argument with the same "
"syntax and functionality as the Set ``select`` method."
msgstr ""
"O método `find`` tem um argumento` `limitby`` opcional com a mesma sintaxe "
"e funcionalidade como o conjunto` `método SELECT``."

#: ../../chapter-07.rst:2595
msgid "Other methods"
msgstr "Outros métodos"

#: ../../chapter-07.rst:2598
msgid "``update_or_insert``"
msgstr "`` Update_or_insert``"

#: ../../chapter-07.rst:2600
msgid ""
"Some times you need to perform an insert only if there is no record with "
"the same values as those being inserted. This can be done with"
msgstr ""
"Algumas vezes você precisa executar uma inserção somente se não há nenhum "
"registro com os mesmos valores como aqueles que estão sendo inseridos. Isso "
"pode ser feito com"

#: ../../chapter-07.rst:2611
msgid ""
"The record will be inserted only if there is no other user called John born "
"in Chicago."
msgstr ""
"O registro será inserido somente se não houver nenhum outro usuário chamado "
"John nascido em Chicago."

#: ../../chapter-07.rst:2614
msgid ""
"You can specify which values to use as a key to determine if the record "
"exists. For example:"
msgstr ""
"Você pode especificar quais valores usar como uma chave para determinar se "
"existe o registro. Por exemplo:"

#: ../../chapter-07.rst:2623
msgid ""
"and if there is John his birthplace will be updated else a new record will "
"be created."
msgstr ""
"e se houver John sua terra natal será atualizado então um novo registro "
"será criado."

#: ../../chapter-07.rst:2626
msgid ""
"The selection criteria in the example above is a single field. It can also "
"be a query, such as"
msgstr ""
"Os critérios de selecção no exemplo acima é um único campo. Ele também pode "
"ser uma consulta, tais como"

#: ../../chapter-07.rst:2637
msgid "``validate_and_insert``, ``validate_and_update``"
msgstr "`` Validate_and_insert``, `` validate_and_update``"

#: ../../chapter-07.rst:2639
msgid "The function"
msgstr "A função"

#: ../../chapter-07.rst:2645
msgid "works very much like"
msgstr "funciona muito bem como"

#: ../../chapter-07.rst:2651
msgid ""
"except that it calls the validators for the fields before performing the "
"insert and bails out if the validation does not pass. If validation does "
"not pass the errors can be found in ``ret.errors``. ``ret.errors`` holds a "
"key-value mapping where each key is the field name whose validation failed, "
"and the value of the key is the result from the validation error (much like "
"``form.errors``). If it passes, the id of the new record is in ``ret.id``. "
"Mind that normally validation is done by the form processing logic so this "
"function is rarely needed."
msgstr ""
"exceto que ele chama os validadores para os campos antes de realizar a "
"inserção e fianças se a validação não passa. Se a validação não passa os "
"erros podem ser encontradas em `` ret.errors``. `` Ret.errors`` mantém um "
"mapeamento de valores-chave, onde cada chave é o nome do campo cuja "
"validação falhou, e o valor da chave é o resultado do erro de validação "
"(muito parecido com `` form.errors``). Se passar, o ID do novo registro é "
"em `` ret.id``. Mente que normalmente validação é feita pela lógica de "
"processamento de formulário para essa função é raramente necessária."

#: ../../chapter-07.rst:2660
msgid "Similarly"
msgstr "Similarmente"

#: ../../chapter-07.rst:2666
msgid "works very much the same as"
msgstr "funciona muito da mesma forma como"

#: ../../chapter-07.rst:2672
msgid ""
"except that it calls the validators for the fields before performing the "
"update. Notice that it only works if query involves a single table. The "
"number of updated records can be found in ``ret.updated`` and errors will "
"be in ``ret.errors``."
msgstr ""
"exceto que ele chama os validadores para os campos antes de realizar a "
"atualização. Note que ele só funciona se consulta envolve uma única tabela. "
"O número de registros atualizados podem ser encontrados em `` ret.updated`` "
"e erros será no `` ret.errors``."

#: ../../chapter-07.rst:2678
msgid "Computed fields"
msgstr "Campos computados"

#: ../../chapter-07.rst:2680
msgid ""
"DAL fields may have a ``compute`` attribute. This must be a function (or "
"lambda) that takes a Row object and returns a value for the field. When a "
"new record is modified, including both insertions and updates, if a value "
"for the field is not provided, py4web tries to compute from the other field "
"values using the ``compute`` function. Here is an example:"
msgstr ""
"Campos DAL podem ter um atributo `` compute``. Esta deve ser uma função (ou "
"lambda) que recebe um objeto Row e retorna um valor para o campo. Quando um "
"novo registo é modificado, incluindo inserções e atualizações, se um valor "
"para o campo não é fornecido, py4web tenta calcular a partir dos outros "
"valores de campo utilizando a função `` compute``. Aqui está um exemplo:"

#: ../../chapter-07.rst:2698
msgid ""
"Notice that the computed value is stored in the db and it is not computed "
"on retrieval, as in the case of virtual fields, described next. Two typical "
"applications of computed fields are: - in wiki applications, to store the "
"processed input wiki text as HTML, to avoid re-processing on every request "
"- for searching, to compute normalized values for a field, to be used for "
"searching."
msgstr ""
"Observe que o valor calculado é armazenado no banco de dados e não é "
"computado na recuperação, como no case de campos virtuais, descrito a "
"seguir. Duas aplicações típicas de campos computados são: - em aplicações "
"wiki, para armazenar o texto de entrada wiki processado como HTML, para "
"evitar re-processamento em cada solicitação - para a pesquisa, para "
"calcular os valores normalizados para um campo, a ser usado para pesquisa."

#: ../../chapter-07.rst:2705
msgid ""
"Computed fields are evaluated in the order in which they are defined in the "
"table definition. A computed field can refer to previously defined computed "
"fields (new after v 2.5.1)"
msgstr ""
"Campos computados são avaliadas na ordem em que eles são definidos na "
"definição da tabela. Um campo computado pode referir-se aos campos "
"computados previamente definidos (novo após v 2.5.1)"

#: ../../chapter-07.rst:2710
msgid "Virtual fields"
msgstr "Campos virtuais"

#: ../../chapter-07.rst:2712
msgid ""
"Virtual fields are also computed fields (as in the previous subsection) but "
"they differ from those because they are *virtual* in the sense that they "
"are not stored in the db and they are computed each time records are "
"extracted from the database. They can be used to simplify the user’s code "
"without using additional storage but they cannot be used for searching."
msgstr ""
"Campos virtuais também são computados campos (como na subseção anterior), "
"mas eles diferem daquelas porque são * * virtual no sentido de que não são "
"armazenadas no db e eles são calculados a cada vez registros são extraídos "
"do banco de dados. Eles podem ser usados ​​para simplificar o código do "
"usuário sem usar armazenamento adicional, mas eles não podem ser usados ​​"
"para pesquisa."

#: ../../chapter-07.rst:2720
msgid "New style virtual fields (experimental)"
msgstr "Campos virtuais novo estilo (experimental)"

#: ../../chapter-07.rst:2722
msgid ""
"py4web provides a new and easier way to define virtual fields and lazy "
"virtual fields. This section is marked experimental because the APIs may "
"still change a little from what is described here."
msgstr ""
"py4web fornece uma nova e mais fácil maneira de definir campos virtuais e "
"campos virtuais preguiçosos. Esta seção é marcado experimental porque as "
"APIs ainda podem mudar um pouco do que é descrito aqui."

#: ../../chapter-07.rst:2726
msgid ""
"Here we will consider the same example as in the previous subsection. In "
"particular we consider the following model:"
msgstr ""
"Aqui vamos considerar o mesmo exemplo na subseção anterior. Em particular, "
"considere o seguinte modelo:"

#: ../../chapter-07.rst:2735 ../../chapter-07.rst:2814
msgid "One can define a ``total_price`` virtual field as"
msgstr "Pode-se definir um `` total_price`` campo virtual como"

#: ../../chapter-07.rst:2741
msgid ""
"i.e. by simply defining a new field ``total_price`` to be a ``Field."
"Virtual``. The only argument of the constructor is a function that takes a "
"row and returns the computed values."
msgstr ""
"isto é, simplesmente definindo um novo campo `` total_price`` ser um `` "
"Field.Virtual``. O único argumento do construtor é uma função que recebe "
"uma linha e retorna os valores calculados."

#: ../../chapter-07.rst:2745
msgid ""
"A virtual field defined as the one above is automatically computed for all "
"records when the records are selected:"
msgstr ""
"Um campo virtual definido como o descrito acima é calculado automaticamente "
"para todos os registros quando os registros são selecionados:"

#: ../../chapter-07.rst:2753
msgid ""
"It is also possible to define method fields which are calculated on-demand, "
"when called. For example:"
msgstr ""
"Também é possível definir campos de métodos que são calculados on-demand, "
"quando chamado. Por exemplo:"

#: ../../chapter-07.rst:2762
msgid ""
"In this case ``row.discounted_total`` is not a value but a function. The "
"function takes the same arguments as the function passed to the ``Method`` "
"constructor except for ``row`` which is implicit (think of it as ``self`` "
"for objects)."
msgstr ""
"Neste case, `` row.discounted_total`` não é um valor, mas uma função. A "
"função usa os mesmos argumentos que a função passada para o `` construtor "
"Method`` exceto `` row`` que está implícito (pense nisso como `` self`` "
"para objetos)."

#: ../../chapter-07.rst:2767
msgid ""
"The lazy field in the example above allows one to compute the total price "
"for each ``item``:"
msgstr ""
"O campo preguiçoso no exemplo acima permite uma para calcular o valor total "
"para cada `` item``:"

#: ../../chapter-07.rst:2774
msgid ""
"And it also allows to pass an optional ``discount`` percentage (say 15%):"
msgstr ""
"E também permite passar um `` percentual discount`` opcional (digamos 15%):"

#: ../../chapter-07.rst:2781
msgid ""
"Virtual and Method fields can also be defined in place when a table is "
"defined:"
msgstr ""
"Campos virtuais e de método também podem ser definidos no lugar quando uma "
"tabela é definida:"

#: ../../chapter-07.rst:2794
msgid ""
"Mind that virtual fields do not have the same attributes as regular fields "
"(length, default, required, etc). They do not appear in the list of ``db."
"table.fields`` and in older versions of py4web they require a special "
"approach to display in SQLFORM.grid and SQLFORM.smartgrid. See the "
"discussion on grids and virtual fields in *Chapter 12* ."
msgstr ""
"Mente que campos virtuais não têm os mesmos atributos como campos regulares "
"(comprimento, padrão, exigida, etc). Eles não aparecem na lista de `` db."
"table.fields`` e em versões mais antigas do py4web eles exigem uma "
"abordagem especial para exibição no SQLFORM.grid e SQLFORM.smartgrid. Veja "
"a discussão sobre grades e campos virtuais em * Capítulo 12 *."

#: ../../chapter-07.rst:2802
msgid "Old style virtual fields"
msgstr "Campos virtuais velho antigo"

#: ../../chapter-07.rst:2804
msgid ""
"In order to define one or more virtual fields, you can also define a "
"container class, instantiate it and link it to a table or to a select. For "
"example, consider the following table:"
msgstr ""
"A fim de definir um ou mais virtuais campos, você também pode definir uma "
"classe de contêiner, instanciá-lo e vinculá-lo a uma tabela ou a um seleto. "
"Por exemplo, considere a seguinte tabela:"

#: ../../chapter-07.rst:2824
msgid ""
"Notice that each method of the class that takes a single argument (self) is "
"a new virtual field. ``self`` refers to each one row of the select. Field "
"values are referred by full path as in ``self.item.unit_price``. The table "
"is linked to the virtual fields by appending an instance of the class to "
"the table’s ``virtualfields`` attribute."
msgstr ""
"Observe que cada método da classe que recebe um único argumento (auto) é um "
"novo campo virtual. `` Self`` refere-se a cada linha de uma select. valores "
"de campo são referidos pelo caminho completo como em `` self.item."
"unit_price``. A tabela está ligada aos campos virtuais anexando uma "
"instância da classe para atributo `` virtualfields`` da tabela."

#: ../../chapter-07.rst:2830
msgid "Virtual fields can also access recursive fields as in"
msgstr "Campos virtuais também podem acessar campos recursivos como em"

#: ../../chapter-07.rst:2847
msgid ""
"Notice the recursive field access ``self.order_item.item.unit_price`` where "
"``self`` is the looping record."
msgstr ""
"Observe o acesso de campo recursiva `` self.order_item.item.unit_price`` "
"onde `` self`` é o registro looping."

#: ../../chapter-07.rst:2850
msgid "They can also act on the result of a JOIN"
msgstr "Eles também podem agir sobre o resultado de um JOIN"

#: ../../chapter-07.rst:2865
msgid ""
"Notice how in this case the syntax is different. The virtual field accesses "
"both ``self.item.unit_price`` and ``self.order_item.quantity`` which belong "
"to the join select. The virtual field is attached to the rows of the table "
"using the ``setvirtualfields`` method of the rows object. This method takes "
"an arbitrary number of named arguments and can be used to set multiple "
"virtual fields, defined in multiple classes, and attach them to multiple "
"tables:"
msgstr ""
"Note como neste case, a sintaxe é diferente. O campo virtual acessa tanto "
"`` self.item.unit_price`` e `` self.order_item.quantity`` que pertencem ao "
"juntar-se selecionar. O campo virtual é anexado para as linhas da tabela "
"usando o método `setvirtualfields`` do objecto linhas. Este método leva um "
"número arbitrário de argumentos nomeados e pode ser usado para definir "
"vários campos virtuais, definidos em várias classes, e anexá-los a várias "
"tabelas:"

#: ../../chapter-07.rst:2891
msgid ""
"Virtual fields can be *lazy*; all they need to do is return a function and "
"access it by calling the function:"
msgstr ""
"Campos virtuais podem ser * lazy* ; tudo que eles precisam fazer é retornar "
"uma função e acessá-lo chamando a função:"

#: ../../chapter-07.rst:2911
msgid "or shorter using a lambda function:"
msgstr "ou mais curto utilizando uma função lambda:"

#: ../../chapter-07.rst:2920
msgid "One to many relation"
msgstr "Um para muitos relação"

#: ../../chapter-07.rst:2922
msgid ""
"To illustrate how to implement one to many relations with the DAL, define "
"another table “thing” that refers to the table “person” which we redefine "
"here:"
msgstr ""
"Para ilustrar como implementar um para muitos relação com a DAL, definir "
"outra mesa “coisa” que refere-se à mesa “pessoa” que redefinir aqui:"

#: ../../chapter-07.rst:2942
msgid ""
"Table “thing” has two fields, the name of the thing and the owner of the "
"thing. The “owner_id” field is a reference field, it is intended that the "
"field reference the other table by its id. A reference type can be "
"specified in two equivalent ways, either: ``Field('owner_id', 'reference "
"person')``:python or: ``Field('owner_id', db.person)``:python"
msgstr ""
"Tabela “coisa” tem dois campos, o nome da coisa eo proprietário da coisa. O "
"campo “owner_id” é um campo de referência, pretende-se que a referência de "
"campo outra tabela pelo seu id. Um tipo de referência pode ser especificada "
"em duas formas equivalentes, quer: `` campo ( 'OWNER_ID', 'pessoa de "
"referência') ``: pitão ou: `` campo ( 'OWNER_ID', db.person) ``: pitão"

#: ../../chapter-07.rst:2949
msgid ""
"The latter is always converted to the former. They are equivalent except in "
"the case of lazy tables, self references or other types of cyclic "
"references where the former notation is the only allowed notation."
msgstr ""
"Este último é sempre convertido para o ex. Eles são equivalentes, exceto no "
"case de tabelas preguiçosos, referências auto ou outros tipos de "
"referências cíclicas onde o ex-notação é a notação só é permitido."

#: ../../chapter-07.rst:2953
msgid "Now, insert three things, two owned by Alex and one by Bob:"
msgstr "Agora, insira três coisas, duas de propriedade de Alex e um por Bob:"

#: ../../chapter-07.rst:2964
msgid "You can select as you did for any other table:"
msgstr "Você pode selecionar como você fez para qualquer outra tabela:"

#: ../../chapter-07.rst:2974
msgid ""
"Because a thing has a reference to a person, a person can have many things, "
"so a record of table person now acquires a new attribute thing, which is a "
"Set, that defines the things of that person. This allows looping over all "
"persons and fetching their things easily:"
msgstr ""
"Porque uma coisa tem uma referência a uma pessoa, uma pessoa pode ter "
"muitas coisas, assim que um registro da tabela pessoa agora adquire uma "
"coisa nova atributo, que é um conjunto, que define as coisas dessa pessoa. "
"Isso permite que um loop sobre todas as pessoas e buscar as suas coisas com "
"facilidade:"

#: ../../chapter-07.rst:2994
msgid "Inner joins"
msgstr "Inner joins"

#: ../../chapter-07.rst:2996
msgid ""
"Another way to achieve a similar result is by using a join, specifically an "
"INNER JOIN. py4web performs joins automatically and transparently when the "
"query links two or more tables as in the following example:"
msgstr ""
"Outra forma de conseguir um resultado semelhante é usando uma junção, "
"especificamente um INNER JOIN. executa py4web junta-se automaticamente e de "
"forma transparente quando a consulta liga dois ou mais tabelas como no "
"exemplo a seguir:"

#: ../../chapter-07.rst:3010
msgid ""
"Observe that py4web did a join, so the rows now contain two records, one "
"from each table, linked together. Because the two records may have fields "
"with conflicting names, you need to specify the table when extracting a "
"field value from a row. This means that while before you could do:"
msgstr ""
"Observe que py4web fez uma junção, então as linhas agora contêm dois "
"registros, um de cada mesa, ligados entre si. Porque os dois registros "
"podem ter campos com nomes conflitantes, você precisa especificar a tabela "
"quando se extrai um valor de campo de uma linha. Isto significa que "
"enquanto antes que você poderia fazer:"

#: ../../chapter-07.rst:3020
msgid ""
"and it was obvious whether this was the name of a person or a thing, in the "
"result of a join you have to be more explicit and say:"
msgstr ""
"e era óbvio que se este era o nome de uma pessoa ou uma coisa, em resultado "
"de uma junção que você tem que ser mais explícito e dizer:"

#: ../../chapter-07.rst:3027
msgid "or:"
msgstr "ou:"

#: ../../chapter-07.rst:3033
msgid "There is an alternative syntax for INNER JOINS:"
msgstr "Há uma sintaxe alternativa para associações internas:"

#: ../../chapter-07.rst:3045
msgid ""
"While the output is the same, the generated SQL in the two cases can be "
"different. The latter syntax removes possible ambiguities when the same "
"table is joined twice and aliased:"
msgstr ""
"Enquanto a saída é o mesmo, o SQL gerado nos dois cases, pode ser "
"diferente. O último sintaxe remove as ambiguidades possíveis quando a mesma "
"tabela é unidas duas vezes e alias:"

#: ../../chapter-07.rst:3060
msgid "The value of ``join`` can be list of ``db.table.on(...)`` to join."
msgstr ""
"O valor de `` join`` pode ser lista de `` db.table.on (...) `` para "
"participar."

#: ../../chapter-07.rst:3063
msgid "Left outer join"
msgstr "Left outer join"

#: ../../chapter-07.rst:3065
msgid ""
"Notice that Carl did not appear in the list above because he has no things. "
"If you intend to select on persons (whether they have things or not) and "
"their things (if they have any), then you need to perform a LEFT OUTER "
"JOIN. This is done using the argument “left” of the select. Here is an "
"example:"
msgstr ""
"Observe que Carl não aparecer na lista acima, porque ele não tem as coisas. "
"Se você pretende selecionar sobre as pessoas (se eles têm coisas ou não) e "
"as suas coisas (se tiver algum), então você precisa para realizar um LEFT "
"OUTER JOIN. Isso é feito usando o argumento de “esquerda” da seleção. Aqui "
"está um exemplo:"

#: ../../chapter-07.rst:3083
msgid "where:"
msgstr "Where:"

#: ../../chapter-07.rst:3089
msgid ""
"does the left join query. Here the argument of ``db.thing.on`` is the "
"condition required for the join (the same used above for the inner join). "
"In the case of a left join, it is necessary to be explicit about which "
"fields to select."
msgstr ""
"é que a esquerda se juntar a consulta. Aqui o argumento de `` db.thing.on`` "
"é a condição necessária para a junção (o mesmo utilizado acima para a "
"junção interna). No case de uma associação à esquerda, é necessário ser "
"explícito sobre quais campos para selecionar."

#: ../../chapter-07.rst:3094
msgid ""
"Multiple left joins can be combined by passing a list or tuple of ``db."
"mytable.on(...)`` to the ``left`` parameter."
msgstr ""
"Multiple esquerda junções podem ser combinados, passando uma lista ou tupla "
"de `` db.mytable.on (...) `` para o parâmetro `` left``."

#: ../../chapter-07.rst:3098
msgid "Grouping and counting"
msgstr "Agrupamento e contando"

#: ../../chapter-07.rst:3100
msgid ""
"When doing joins, sometimes you want to group rows according to certain "
"criteria and count them. For example, count the number of things owned by "
"every person. py4web allows this as well. First, you need a count operator. "
"Second, you want to join the person table with the thing table by owner. "
"Third, you want to select all rows (person + thing), group them by person, "
"and count them while grouping:"
msgstr ""
"Ao fazer junta-se, às vezes você quer agrupar linhas de acordo com certos "
"critérios e contá-los. Por exemplo, contar o número de coisas pertencentes "
"a cada pessoa. py4web permite isso também. Primeiro, você precisa de um "
"operador de contagem. Em segundo lugar, você quer se juntar a tabela a "
"pessoa com o quadro de coisa pelo proprietário. Terceiro, você quer "
"selecionar todas as linhas (pessoa + coisa), agrupá-los por pessoa, e contá-"
"los enquanto agrupamento:"

#: ../../chapter-07.rst:3117
msgid ""
"Notice the ``count`` operator (which is built-in) is used as a field. The "
"only issue here is in how to retrieve the information. Each row clearly "
"contains a person and the count, but the count is not a field of a person "
"nor is it a table. So where does it go? It goes into the storage object "
"representing the record with a key equal to the query expression itself."
msgstr ""
"Observe a `` operador count`` (que é incorporado) é usado como um campo. O "
"único problema aqui é em como recuperar a informação. Cada linha contém "
"claramente uma pessoa e a contagem, mas a contagem não é um campo de uma "
"pessoa nem é uma mesa. Então, onde ela vai? Ele vai para o objeto de "
"armazenamento representando o registro com uma chave igual ao próprio "
"expressão de consulta."

#: ../../chapter-07.rst:3124
msgid ""
"The ``count`` method of the Field object has an optional ``distinct`` "
"argument. When set to ``True`` it specifies that only distinct values of "
"the field in question are to be counted."
msgstr ""
"O método `count`` do objeto campo tem um argumento` `distinct`` opcional. "
"Quando ajustado para `` True`` especifica que apenas os valores distintos "
"de campo em questão estão a ser contadas."

#: ../../chapter-07.rst:3129
msgid "Many to many"
msgstr "Muitos para muitos"

#: ../../chapter-07.rst:3131
msgid ""
"In the previous examples, we allowed a thing to have one owner but one "
"person could have many things. What if Boat was owned by Alex and Curt? "
"This requires a many-to-many relation, and it is realized via an "
"intermediate table that links a person to a thing via an ownership relation."
msgstr ""
"Nos exemplos anteriores, que permitiram uma coisa para ter um proprietário, "
"mas uma pessoa pode ter muitas coisas. E se barco era propriedade de Alex e "
"Curt? Isso requer uma relação muitos-para-muitos, e é realizada através de "
"uma tabela intermediária que liga uma pessoa a uma coisa através de uma "
"relação de propriedade."

#: ../../chapter-07.rst:3137
msgid "Here is how to do it:"
msgstr "Aqui está como fazê-lo:"

#: ../../chapter-07.rst:3156
msgid "the existing ownership relationship can now be rewritten as:"
msgstr "a relação de propriedade existente pode agora ser reescrita como:"

#: ../../chapter-07.rst:3167
msgid "Now you can add the new relation that Curt co-owns Boat:"
msgstr ""
"Agora você pode adicionar a nova relação que Curt co-proprietária Barco:"

#: ../../chapter-07.rst:3174
msgid ""
"Because you now have a three-way relation between tables, it may be "
"convenient to define a new set on which to perform operations:"
msgstr ""
"Porque agora você tem uma relação de três vias entre as mesas, pode ser "
"conveniente para definir um novo conjunto no qual executar as operações:"

#: ../../chapter-07.rst:3182
msgid ""
"Now it is easy to select all persons and their things from the new Set:"
msgstr ""
"Agora é fácil para selecionar todas as pessoas e suas coisas da nova Set:"

#: ../../chapter-07.rst:3194
msgid "Similarly, you can search for all things owned by Alex:"
msgstr ""
"Da mesma forma, você pode procurar por todas as coisas pertencentes a Alex:"

#: ../../chapter-07.rst:3204
msgid "and all owners of Boat:"
msgstr "e todos os proprietários de barco:"

#: ../../chapter-07.rst:3214
msgid ""
"A lighter alternative to many-to-many relations is tagging, you can found "
"an example of this in the next section. Tagging works even on database "
"backends that do not support JOINs like the Google App Engine NoSQL."
msgstr ""
"Uma alternativa mais leve para muitos-para-muitos relações é a marcação, "
"encontram-se um exemplo disso na próxima seção. Marcação de obras, mesmo em "
"backends de banco de dados que não suportam JOINs como o Google App Engine "
"NoSQL."

#: ../../chapter-07.rst:3220
msgid "Tagging records"
msgstr "Marcação de registros"

#: ../../chapter-07.rst:3222
msgid ""
"Tags allows to add or find properties attached to records in your database."
msgstr ""
"Etiquetas permite adicionar ou encontrar propriedades anexadas aos "
"registros em seu banco de dados."

#: ../../chapter-07.rst:3252
msgid ""
"It is internally implemented as a table with name: \\ *tags*\\ , which in "
"this example would be db.thing_tags_default, because no path was specified "
"on the Tags(table, path=“default”) constructor"
msgstr ""
"Ele é implementado internamente como uma tabela com o nome: \\ tags * * \\, "
"que neste exemplo seria db.thing_tags_default, porque nenhum caminho foi "
"especificado nas etiquetas (tabela, path = “default”) construtor"

#: ../../chapter-07.rst:3256
msgid ""
"The ``find`` method is doing a search by ``startswith`` of the path passed "
"as parameter. Then find([“color”]) would return id1 and id2 because both "
"records have tags starting with “color”. py4web uses tags as a flexible "
"mechanism to manage permissions."
msgstr ""
"O método `find`` está fazendo uma busca por` `startswith`` do caminho "
"passado como parâmetro. Em seguida, encontrar ([ “cor”]) deve retornar id1 "
"e ID2 porque ambos os registros têm etiquetas que começam com “cor”. py4web "
"utiliza tags como um mecanismo flexível para gerenciar permissões."

#: ../../chapter-07.rst:3262
msgid "``list:<type>`` and ``contains``"
msgstr "`` Lista: <type> `` e `` contains``"

#: ../../chapter-07.rst:3264
msgid "py4web provides the following special field types:"
msgstr "py4web fornece os seguintes tipos de campos especiais:"

#: ../../chapter-07.rst:3272
msgid ""
"They can contain lists of strings, of integers and of references "
"respectively."
msgstr ""
"Eles podem conter listas de cordas, de inteiros e de referências, "
"respectivamente."

#: ../../chapter-07.rst:3275
msgid ""
"On Google App Engine NoSQL ``list:string`` is mapped into "
"``StringListProperty``, the other two are mapped into "
"``ListProperty(int)``. On relational databases they are mapped into text "
"fields which contain the list of items separated by ``|``. For example "
"``[1, 2, 3]`` is mapped into ``|1|2|3|``."
msgstr ""
"No Google App Engine NoSQL `` lista: string`` é mapeado em `` "
"StringListProperty``, os outros dois são mapeados em `` ListProperty (int) "
"``. Em bancos de dados relacionais são mapeados em campos de texto que "
"contém a lista de itens separados por `` | ``. Por exemplo `` [1, 2, 3] `` "
"é mapeado para `` | 1 | 2 | 3 | ``."

#: ../../chapter-07.rst:3281
msgid ""
"For lists of string the items are escaped so that any ``|`` in the item is "
"replaced by a ``||``. Anyway this is an internal representation and it is "
"transparent to the user."
msgstr ""
"Para listas de corda os itens são escapou de modo que qualquer `` | `` no "
"item é substituído por um `` || ``. De qualquer forma esta é uma "
"representação interna e é transparente para o usuário."

#: ../../chapter-07.rst:3285
msgid "You can use ``list:string``, for example, in the following way:"
msgstr "Você pode usar `` lista: string``, por exemplo, da seguinte maneira:"

#: ../../chapter-07.rst:3302
msgid "``list:integer`` works in the same way but the items must be integers."
msgstr ""
"`` Lista: obras integer`` da mesma forma, mas os itens devem ser inteiros."

#: ../../chapter-07.rst:3304
msgid ""
"As usual the requirements are enforced at the level of forms, not at the "
"level of ``insert``."
msgstr ""
"Como de costume, os requisitos são aplicadas ao nível das formas, não no "
"nível de `` insert``."

#: ../../chapter-07.rst:3307
msgid ""
"For ``list:<type>`` fields the ``contains(value)`` operator maps into a non "
"trivial query that checks for lists containing the ``value``. The "
"``contains`` operator also works for regular ``string`` and ``text`` fields "
"and it maps into a ``LIKE '%value%'``."
msgstr ""
"Por `` lista: <type> `` campos de `` contém (valor) `` operador de mapas em "
"uma consulta não trivial que verifica a existência de listas contendo o `` "
"value``. O `` operador contains`` também funciona para regular, `` string`` "
"e `` campos text`` e ele mapeia para um `` LIKE '% value%' ``."

#: ../../chapter-07.rst:3312
msgid ""
"The ``list:reference`` and the ``contains(value)`` operator are "
"particularly useful to de-normalize many-to-many relations. Here is an "
"example:"
msgstr ""
"O `` lista: reference`` eo `` contém (valor) `` operador são "
"particularmente úteis para de-normalize muitos-para-muitos relações. Aqui "
"está um exemplo:"

#: ../../chapter-07.rst:3341
msgid "Notice that a ``list:reference tag`` field get a default constraint"
msgstr ""
"Observe que um `` lista: Campo tag`` referência obter uma restrição padrão"

#: ../../chapter-07.rst:3347
msgid "that produces a ``SELECT/OPTION`` multiple drop-box in forms."
msgstr "que produz um `` / OPTION`` gota-caixa múltipla SELECT formas."

#: ../../chapter-07.rst:3349
msgid ""
"Also notice that this field gets a default ``represent`` attribute which "
"represents the list of references as a comma-separated list of formatted "
"references. This is used in read ``forms``."
msgstr ""
"Além disso, observe que este campo recebe um atributo `represent`` que "
"representa a lista de referências como uma lista separada por vírgulas de "
"referências formatados` padrão. Isto é usado em leitura `` forms``."

#: ../../chapter-07.rst:3353
msgid ""
"While ``list:reference`` has a default validator and a default "
"representation, ``list:integer`` and ``list:string`` do not. So these two "
"need an ``IS_IN_SET`` or an ``IS_IN_DB`` validator if you want to use them "
"in forms."
msgstr ""
"Enquanto `` lista: reference`` tem um validador padrão e uma representação "
"padrão, `` lista: integer`` e `` lista: string`` não. Então, esses dois "
"precisam de um `` IS_IN_SET`` ou um `` validador IS_IN_DB`` se você quiser "
"usá-los em formas."

#: ../../chapter-07.rst:3359
msgid "Other operators"
msgstr "Outros operadores"

#: ../../chapter-07.rst:3361
msgid ""
"py4web has other operators that provide an API to access equivalent SQL "
"operators. Let’s define another table “log” to store security events, their "
"event_time and severity, where the severity is an integer number."
msgstr ""
"py4web tem outros operadores que fornecem uma API para operadores SQL "
"equivalentes de acesso. Vamos definir outra mesa “log” para eventos loja de "
"segurança, sua event_time e gravidade, onde a gravidade é um número inteiro."

#: ../../chapter-07.rst:3372
msgid ""
"As before, insert a few events, a “port scan”, an “xss injection” and an "
"“unauthorized login”. For the sake of the example, you can log events with "
"the same event_time but with different severities (1, 2, and 3 "
"respectively)."
msgstr ""
"Como antes, inserir alguns eventos, a “varredura de portas”, uma “injeção "
"de XSS” e um “login não autorizado”. Por causa do exemplo, você pode "
"registrar eventos com o mesmo event_time mas com diferentes gravidades (1, "
"2, e 3, respectivamente)."

#: ../../chapter-07.rst:3389
msgid ""
"``like``, ``ilike``, ``regexp``, ``startswith``, ``endswith``, "
"``contains``, ``upper``, ``lower``"
msgstr ""
"`` Like``, `` ilike``, `` regexp``, `` startswith``, `` endswith``, `` "
"contains``, `` upper``, `` lower``"

#: ../../chapter-07.rst:3391
msgid "Fields have a ``like`` operator that you can use to match strings:"
msgstr ""
"Campos tem um `` operador like`` que você pode usar para combinar strings:"

#: ../../chapter-07.rst:3400
msgid ""
"Here “port%” indicates a string starting with “port”. The percent sign "
"character, “%”, is a wild-card character that means “any sequence of "
"characters”."
msgstr ""
"Aqui “porta%” indica uma partida string com “porta”. O personagem por cento "
"sinal, “%”, é um personagem wild-card que significa “qualquer sequência de "
"caracteres”."

#: ../../chapter-07.rst:3404
msgid ""
"The ``like`` operator maps to the LIKE word in ANSI-SQL. LIKE is case-"
"sensitive in most databases, and depends on the collation of the database "
"itself. The ``like`` method is hence case-sensitive but it can be made case-"
"insensitive with"
msgstr ""
"O `` operador like`` mapeia para a palavra como em ANSI-SQL. COMO é "
"sensível a maiúsculas na maioria dos bancos de dados, e depende do "
"agrupamento do próprio banco de dados. O método `like`` é, portanto, case-"
"sensível, mas ele pode ser feito de maiúsculas e minúsculas com"

#: ../../chapter-07.rst:3413
msgid "which is the same as using ``ilike``"
msgstr "que é o mesmo que usar `` ilike``"

#: ../../chapter-07.rst:3419
msgid "py4web also provides some shortcuts:"
msgstr "py4web também fornece alguns atalhos:"

#: ../../chapter-07.rst:3427
msgid "which are roughly equivalent respectively to"
msgstr "que são aproximadamente equivalentes, respectivamente, a"

#: ../../chapter-07.rst:3435
msgid ""
"Remember that ``contains`` has a special meaning for ``list:<type>`` "
"fields, as discussed in previous *list: and contains* section."
msgstr ""
"Lembre-se que `` contains`` tem um significado especial para `` lista: "
"<type> `` campos, como discutido na lista anterior *: e contém seção *."

#: ../../chapter-07.rst:3438
msgid ""
"The ``contains`` method can also be passed a list of values and an optional "
"boolean argument ``all`` to search for records that contain all values:"
msgstr ""
"O método `contains`` também pode ser passada uma lista de valores e um "
"argumento booleano opcional` `all`` para procurar registros que contêm "
"todos os valores:"

#: ../../chapter-07.rst:3446
msgid "or any value from the list"
msgstr "ou qualquer valor a partir da lista"

#: ../../chapter-07.rst:3452
msgid ""
"There is a also a ``regexp`` method that works like the ``like`` method but "
"allows regular expression syntax for the look-up expression. It is only "
"supported by MySQL, Oracle, PostgreSQL, SQLite, and MongoDB (with different "
"degree of support)."
msgstr ""
"Há um também um `` método regexp`` que funciona como o método `like`` mas "
"permite sintaxe de expressão regular para a expressão look-up. Ele só é "
"suportado pelo MySQL, Oracle, PostgreSQL, SQLite, e MongoDB (com diferente "
"grau de apoio)."

#: ../../chapter-07.rst:3457
msgid ""
"The ``upper`` and ``lower`` methods allow you to convert the value of the "
"field to upper or lower case, and you can also combine them with the like "
"operator:"
msgstr ""
"O `` upper`` e `` métodos lower`` permitem converter o valor do campo para "
"maiúsculas ou minúsculas, e você também pode combiná-los com o gosto do "
"operador:"

#: ../../chapter-07.rst:3469
msgid "``year``, ``month``, ``day``, ``hour``, ``minutes``, ``seconds``"
msgstr ""
"`` Year``, `` month``, `` day``, `` hour``, `` minutes``, `` seconds``"

#: ../../chapter-07.rst:3471
msgid ""
"The date and datetime fields have ``day``, ``month`` and ``year`` methods. "
"The datetime and time fields have ``hour``, ``minutes`` and ``seconds`` "
"methods. Here is an example:"
msgstr ""
"A data ea data e hora campos têm `` day``, `` month`` e `` métodos year``. "
"Os campos de data e hora e de tempo têm `` hour``, `` `` minutes`` e "
"métodos seconds``. Aqui está um exemplo:"

#: ../../chapter-07.rst:3485
msgid "``belongs``"
msgstr "`` Belongs``"

#: ../../chapter-07.rst:3487
msgid ""
"The SQL IN operator is realized via the ``belongs`` method which returns "
"true when the field value belongs to the specified set (list or tuples):"
msgstr ""
"O operador IN SQL é realizado através do método `belongs`` que devolve "
"verdadeiro quando o valor do campo pertence ao conjunto especificado (lista "
"ou tuplos):"

#: ../../chapter-07.rst:3498
msgid ""
"The DAL also allows a nested select as the argument of the belongs "
"operator. The only caveat is that the nested select has to be a "
"``_select``, not a ``select``, and only one field has to be selected "
"explicitly, the one that defines the set."
msgstr ""
"A DAL também permite que um SELECT aninhada como o argumento do operador "
"pertence. A única limitação é que o seleccione aninhada tem de ser um `` "
"_select``, não um `` SELECT``, e apenas um campo tem de ser seleccionada "
"explicitamente, o que define o conjunto."

#: ../../chapter-07.rst:3513
msgid ""
"In those cases where a nested select is required and the look-up field is a "
"reference we can also use a query as argument. For example:"
msgstr ""
"Nos cases em que um seleto aninhada é necessária e o campo look-up é uma "
"referência também podemos usar uma consulta como argumento. Por exemplo:"

#: ../../chapter-07.rst:3525
msgid ""
"In this case it is obvious that the nested select only needs the field "
"referenced by the ``db.thing.owner_id`` field so we do not need the more "
"verbose ``_select`` notation."
msgstr ""
"Neste case, é óbvio que o SELECT aninhada só precisa do campo referenciado "
"pelo campo `` db.thing.owner_id`` por isso não precisa do `` notação mais "
"detalhado _select``."

#: ../../chapter-07.rst:3529
msgid ""
"A nested select can also be used as insert/update value but in this case "
"the syntax is different:"
msgstr ""
"A selecção pode aninhada também ser usado como insert valor / atualização, "
"mas, neste case, a sintaxe é diferente:"

#: ../../chapter-07.rst:3538
msgid ""
"In this case ``lazy`` is a nested expression that computes the ``id`` of "
"person “Jonathan”. The two lines result in one single SQL query."
msgstr ""
"Neste case, `` lazy`` é uma expressão aninhada que calcula o `` id`` de "
"pessoa “Jonathan”. As duas linhas resultar em uma consulta SQL única."

#: ../../chapter-07.rst:3542
msgid "``sum``, ``avg``, ``min``, ``max`` and ``len``"
msgstr "`` Sum``, `` avg``, `` min``, `` `` max`` e len``"

#: ../../chapter-07.rst:3544
msgid ""
"Previously, you have used the ``count`` operator to count records. "
"Similarly, you can use the ``sum`` operator to add (sum) the values of a "
"specific field from a group of records. As in the case of count, the result "
"of a sum is retrieved via the storage object:"
msgstr ""
"Anteriormente, você usou o `` operador count`` para contar registros. Da "
"mesma forma, você pode usar o `` operador sum`` para adicionar (soma) os "
"valores de um campo específico de um grupo de registros. Tal como no case "
"de contagem, o resultado de uma soma é recuperado através do objecto de "
"armazenamento:"

#: ../../chapter-07.rst:3555
msgid ""
"You can also use ``avg``, ``min``, and ``max`` to the average, minimum, and "
"maximum value respectively for the selected records. For example:"
msgstr ""
"Você também pode usar `` avg``, `` min``, e `` max`` à média, mínimo e "
"valor máximo, respectivamente, para os registros selecionados. Por exemplo:"

#: ../../chapter-07.rst:3564
msgid ""
"``len`` computes the length of field’s value. It is generally used on "
"string or text fields but depending on the back-end it may still work for "
"other types too (boolean, integer, etc)."
msgstr ""
"`` Len`` calcula o comprimento do valor do campo. Ele é geralmente usado em "
"cordas ou texto campos, mas dependendo do back-end que ainda pode funcionar "
"para outros tipos também (boolean, integer, etc)."

#: ../../chapter-07.rst:3575
msgid ""
"Expressions can be combined to form more complex expressions. For example "
"here we are computing the sum of the length of the event strings in the "
"logs plus one:"
msgstr ""
"As expressões podem ser combinados para formar expressões mais complexas. "
"Por exemplo, aqui estamos calculando a soma do comprimento das strings de "
"eventos nos logs de mais um:"

#: ../../chapter-07.rst:3586
msgid "Substrings"
msgstr "Substrings"

#: ../../chapter-07.rst:3588
msgid ""
"One can build an expression to refer to a substring. For example, we can "
"group things whose name starts with the same three characters and select "
"only one from each group:"
msgstr ""
"Pode-se construir uma expressão para se referir a uma substring. Por "
"exemplo, podemos agrupar as coisas cujo nome começa com os mesmos três "
"personagens e selecione apenas um de cada grupo:"

#: ../../chapter-07.rst:3597
msgid "Default values with ``coalesce`` and ``coalesce_zero``"
msgstr "Os valores por defeito com `` `` coalesce`` e coalesce_zero``"

#: ../../chapter-07.rst:3599
msgid ""
"There are times when you need to pull a value from database but also need a "
"default values if the value for a record is set to NULL. In SQL there is a "
"function, ``COALESCE``, for this. py4web has an equivalent ``coalesce`` "
"method:"
msgstr ""
"Há momentos em que você precisa para puxar um valor de banco de dados, mas "
"também precisa de valores padrão se o valor para um registro é definido "
"como NULL. Em SQL existe uma função, `` COALESCE``, para isso. py4web tem "
"um método `coalesce`` equivalente:"

#: ../../chapter-07.rst:3619
msgid ""
"Other times you need to compute a mathematical expression but some fields "
"have a value set to None while it should be zero. ``coalesce_zero`` comes "
"to the rescue by defaulting None to zero in the query:"
msgstr ""
"Outras vezes você precisa para calcular uma expressão matemática, mas "
"alguns campos têm um valor definido para Nenhum quando deveria ser zero. `` "
"Coalesce_zero`` vem para o resgate por falta Nada a zero na consulta:"

#: ../../chapter-07.rst:3641
msgid "Generating raw sql"
msgstr "Gerando SQL puro"

#: ../../chapter-07.rst:3643
msgid ""
"Sometimes you need to generate the SQL but not execute it. This is easy to "
"do with py4web since every command that performs database IO has an "
"equivalent command that does not, and simply returns the SQL that would "
"have been executed. These commands have the same names and syntax as the "
"functional ones, but they start with an underscore:"
msgstr ""
"Às vezes você precisa para gerar o SQL, mas não executá-lo. Isso é fácil de "
"fazer com py4web uma vez que cada comando que executa banco de dados IO tem "
"um comando equivalente que não, e simplesmente retorna o SQL que teriam "
"sido executados. Estes comandos têm os mesmos nomes e sintaxe como os "
"funcionais, mas eles começam com um sublinhado:"

#: ../../chapter-07.rst:3649
msgid "Here is ``_insert``"
msgstr "Aqui é `` _insert``"

#: ../../chapter-07.rst:3656
msgid "Here is ``_count``"
msgstr "Aqui é `` _count``"

#: ../../chapter-07.rst:3663
msgid "Here is ``_select``"
msgstr "Aqui é `` _select``"

#: ../../chapter-07.rst:3670
msgid "Here is ``_delete``"
msgstr "Aqui é `` _delete``"

#: ../../chapter-07.rst:3677
msgid "And finally, here is ``_update``"
msgstr "E, finalmente, aqui é `` _update``"

#: ../../chapter-07.rst:3686
msgid ""
"Moreover you can always use ``db._lastsql`` to return the most recent SQL "
"code, whether it was executed manually using executesql or was SQL "
"generated by the DAL."
msgstr ""
"Além disso, você sempre pode usar `` db._lastsql`` para retornar o código "
"SQL mais recente, se foi executada manualmente usando ExecuteSQL ou foi SQL "
"gerado pelo DAL."

#: ../../chapter-07.rst:3691
msgid "Exporting and importing data"
msgstr "Exportar e importar dados"

#: ../../chapter-07.rst:3694
msgid "CSV (one Table at a time)"
msgstr "CSV (uma tabela de cada vez)"

#: ../../chapter-07.rst:3696
msgid ""
"When a Rows object is converted to a string it is automatically serialized "
"in CSV:"
msgstr ""
"Quando um objeto linhas é convertido para uma string é automaticamente "
"serializado na CSV:"

#: ../../chapter-07.rst:3708
msgid ""
"You can serialize a single table in CSV and store it in a file “test.csv”:"
msgstr ""
"Você pode serializar uma única tabela em formato CSV e armazená-lo em um "
"arquivo “test.csv”:"

#: ../../chapter-07.rst:3718
msgid ""
"Notice that converting a ``Rows`` object into a string using Python 2 "
"produces an utf8 encoded binary string. To obtain a different encoding you "
"have to ask for it explicitly, for example with:"
msgstr ""
"Note-se que a conversão de um objeto `` Rows`` em uma strings utilizando o "
"Python 2 produz um utf8 codificado strings binária. Para obter uma "
"codificação diferente você tem que perguntar para ele explicitamente, por "
"exemplo, com:"

#: ../../chapter-07.rst:3722
msgid "``unicode(str(db(db.person).select()), 'utf8').encode(...)``:pythonn"
msgstr ""
"`` Unicode (str (db (db.person) .Select ()), 'UTF-8') codificar (...) ``:. "
"Pythonn"

#: ../../chapter-07.rst:3724 ../../chapter-07.rst:3787
msgid "Or in Python 3:"
msgstr "Ou em Python 3:"

#: ../../chapter-07.rst:3731
msgid "This is equivalent to"
msgstr "Isto é equivalente a"

#: ../../chapter-07.rst:3739
msgid "You can read the CSV file back with:"
msgstr "Você pode ler o arquivo de volta CSV com:"

#: ../../chapter-07.rst:3746
msgid ""
"Again, when using Python 3, you can be explict about the encoding for the "
"exporting file:"
msgstr ""
"Mais uma vez, ao usar Python 3, você pode ser explict sobre a codificação "
"para o arquivo de exportação:"

#: ../../chapter-07.rst:3755
msgid "and the importing one:"
msgstr "ea importação de um:"

#: ../../chapter-07.rst:3762
msgid ""
"When importing, py4web looks for the field names in the CSV header. In this "
"example, it finds two columns: “person.id” and “person.name”. It ignores "
"the “person.” prefix, and it ignores the “id” fields. Then all records are "
"appended and assigned new ids. Both of these operations can be performed "
"via the appadmin web interface."
msgstr ""
"Ao importar, py4web olha para os nomes de campo no cabeçalho CSV. Neste "
"exemplo, ele encontra duas colunas: “person.id” e “person.name”. Ele ignora "
"o “pessoa”. prefixo, e ignora os campos “ID”. Em seguida, todos os "
"registros são anexados e atribuídos novos ids. Ambas estas operações podem "
"ser realizadas através da interface AppAdmin web."

#: ../../chapter-07.rst:3769
msgid "CSV (all tables at once)"
msgstr "CSV (todas as tabelas ao mesmo tempo)"

#: ../../chapter-07.rst:3771
msgid ""
"In py4web, you can backup/restore an entire database with two commands:"
msgstr ""
"Em py4web, você pode backup / restaurar um banco de dados inteiro com dois "
"comandos:"

#: ../../chapter-07.rst:3773 ../../chapter-07.rst:3789
msgid "To export:"
msgstr "Exportar:"

#: ../../chapter-07.rst:3780 ../../chapter-07.rst:3796
msgid "To import:"
msgstr "Importar:"

#: ../../chapter-07.rst:3803
msgid ""
"This mechanism can be used even if the importing database is of a different "
"type than the exporting database."
msgstr ""
"Este mecanismo pode ser utilizado mesmo se a banco de dados de importação é "
"de um tipo diferente do que a banco de dados de exportação."

#: ../../chapter-07.rst:3806
msgid ""
"The data is stored in “somefile.csv” as a CSV file where each table starts "
"with one line that indicates the tablename, and another line with the "
"fieldnames:"
msgstr ""
"Os dados são armazenados em “somefile.csv” como um arquivo CSV, onde cada "
"mesa começa com uma linha que indica o nome da tabela, e outra linha com os "
"nomes de campos:"

#: ../../chapter-07.rst:3815
msgid ""
"Two tables are separated by ``\\r\\n\\r\\n`` (that is two empty lines). The "
"file ends with the line"
msgstr ""
"Duas tabelas são separados por `` \\ r \\ n \\ r \\ n`` (que é duas linhas "
"vazias). As extremidades de arquivos com a linha"

#: ../../chapter-07.rst:3822
msgid ""
"The file does not include uploaded files if these are not stored in the "
"database. The upload files stored on filesystem must be dumped separately, "
"a zip of the “uploads” folder may suffice in most cases."
msgstr ""
"O arquivo não inclui os arquivos enviados, se estes não são armazenados no "
"banco de dados. Os upload de arquivos armazenados no sistema de arquivos "
"deve ser despejado em separado, um zip dos “uploads” pasta pode ser "
"suficiente na maioria dos cases."

#: ../../chapter-07.rst:3826
msgid ""
"When importing, the new records will be appended to the database if it is "
"not empty. In general the new imported records will not have the same "
"record id as the original (saved) records but py4web will restore "
"references so they are not broken, even if the id values may change."
msgstr ""
"Ao importar, os novos registros serão anexados ao banco de dados se não "
"está vazio. Em geral, os novos registros importados não terão o mesmo ID de "
"registro como os registros originais (salvos), mas py4web irá restaurar "
"referências para que eles não estão quebrados, mesmo que os valores id "
"podem mudar."

#: ../../chapter-07.rst:3831
msgid ""
"If a table contains a field called ``uuid``, this field will be used to "
"identify duplicates. Also, if an imported record has the same ``uuid`` as "
"an existing record, the previous record will be updated."
msgstr ""
"Se uma tabela contém um campo chamado `` uuid``, este campo será utilizado "
"para identificar duplicatas. Além disso, se um registro importado tem o "
"mesmo `` uuid`` como um registro existente, o recorde anterior será "
"atualizada."

#: ../../chapter-07.rst:3836
msgid "CSV and remote database synchronization"
msgstr "CSV e sincronização de banco de dados remoto"

#: ../../chapter-07.rst:3838
msgid "Consider once again the following model:"
msgstr "Considere mais uma vez o seguinte modelo:"

#: ../../chapter-07.rst:3854
msgid ""
"Each record is identified by an identifier and referenced by that id. If "
"you have two copies of the database used by distinct py4web installations, "
"the id is unique only within each database and not across the databases. "
"This is a problem when merging records from different databases."
msgstr ""
"Cada registro é identificado por um identificador e referenciado por esse "
"id. Se você tem duas cópias do banco de dados usado por instalações py4web "
"distintas, o id é único apenas dentro de cada banco de dados e não através "
"das bases de dados. Este é um problema ao mesclar registros de bancos de "
"dados diferentes."

#: ../../chapter-07.rst:3860
msgid ""
"In order to make records uniquely identifiable across databases, they must: "
"- have a unique id (UUID), - have a last modification time to track the "
"most recent among multiple copies, - reference the UUID instead of the id."
msgstr ""
"A fim de fazer registros exclusivamente identificável através de bases de "
"dados, eles devem: - ter um ID único (UUID), - ter uma última modificação "
"para acompanhar o mais recente entre várias cópias, - referência o UUID em "
"vez do id."

#: ../../chapter-07.rst:3865
msgid "This can be achieved changing the above model into:"
msgstr "Isto pode ser conseguido mudando o modelo acima para:"

#: ../../chapter-07.rst:3894
msgid ""
"Notice that in the above table definitions, the default value for the two "
"``uuid`` fields is set to a lambda function, which returns a UUID "
"(converted to a string). The lambda function is called once for each record "
"inserted, ensuring that each record gets a unique UUID, even if multiple "
"records are inserted in a single transaction."
msgstr ""
"Note-se que nas definições da tabela acima, o valor padrão para os dois "
"campos `` uuid`` é definida como uma função de lambda, que retorna um UUID "
"(convertido para uma strings). A função lambda é chamado uma vez para cada "
"registro inserido, garantindo que cada registro recebe um UUID único, mesmo "
"que vários registros são inseridos em uma única transação."

#: ../../chapter-07.rst:3900
msgid "Create a controller action to export the database:"
msgstr "Criar uma ação de controlador para exportar o banco de dados:"

#: ../../chapter-07.rst:3910
msgid ""
"Create a controller action to import a saved copy of the other database and "
"sync records:"
msgstr ""
"Criar uma ação de controlador para importar uma cópia salva dos outros "
"registros de dados e sincronização:"

#: ../../chapter-07.rst:3932
msgid ""
"Optionally you should create an index manually to make the search by uuid "
"faster."
msgstr ""
"Opcionalmente, você deve criar um índice manualmente para fazer a busca por "
"uuid mais rápido."

#: ../../chapter-07.rst:3935
msgid "Alternatively, you can use XML-RPC to export/import the file."
msgstr ""
"Alternativamente, você pode usar XML-RPC para exportar / importar o arquivo."

#: ../../chapter-07.rst:3937
msgid ""
"If the records reference uploaded files, you also need to export/import the "
"content of the uploads folder. Notice that files therein are already "
"labeled by UUIDs so you do not need to worry about naming conflicts and "
"references."
msgstr ""
"Se os registros referência a arquivos enviados, você também precisa "
"exportar / importar o conteúdo da pasta uploads. Observe que os arquivos "
"nele já são rotulados por UUIDs para que você não precisa se preocupar com "
"conflitos de nomes e referências."

#: ../../chapter-07.rst:3943
msgid "HTML and XML (one Table at a time)"
msgstr "HTML e XML (uma tabela de cada vez)"

#: ../../chapter-07.rst:3945
msgid ""
"Rows objects also have an ``xml`` method (like helpers) that serializes it "
"to XML/HTML:"
msgstr ""
"Linhas objetos também têm um método `xml`` (como ajudantes) que serializa-"
"lo para XML / HTML:"

#: ../../chapter-07.rst:3982
msgid ""
"If you need to serialize the Rows in any other XML format with custom tags, "
"you can easily do that using the universal ``TAG`` helper (described in "
"`Chapter 11 <#chapter-08#TAGs>`__ and the Python syntax ``*<iterable>`` "
"allowed in function calls:"
msgstr ""
"Se você precisar serializar as linhas em qualquer outro formato XML com "
"tags personalizadas, você pode facilmente fazer isso usando o universal `` "
"ajudante TAG`` (descrito em `Capítulo 11 <# capítulo 08 # TAGs>` __ ea "
"sintaxe Python `` * <iterable> `` permitida em chamadas de função:"

#: ../../chapter-07.rst:4001
msgid "Data representation"
msgstr "Representação de dados"

#: ../../chapter-07.rst:4003
msgid ""
"The ``Rows.export_to_csv_file`` method accepts a keyword argument named "
"``represent``. When ``True`` it will use the columns ``represent`` function "
"while exporting the data instead of the raw data."
msgstr ""
"O método `Rows.export_to_csv_file`` aceita um argumento de palavra-chave "
"chamada` `represent``. Quando `` True`` ele usará as colunas função `` "
"represent`` ao exportar os dados, em vez dos dados brutos."

#: ../../chapter-07.rst:4007
msgid ""
"The function also accepts a keyword argument named ``colnames`` that should "
"contain a list of column names one wish to export. It defaults to all "
"columns."
msgstr ""
"A função também aceita um argumento de palavra-chave chamada `` colnames`` "
"que deve conter uma lista de nomes de colunas um desejo para exportação. O "
"padrão é todas as colunas."

#: ../../chapter-07.rst:4011
msgid ""
"Both ``export_to_csv_file`` and ``import_from_csv_file`` accept keyword "
"arguments that tell the csv parser the format to save/load the files: - "
"``delimiter``: delimiter to separate values (default ‘,’) - ``quotechar``: "
"character to use to quote string values (default to double quotes) - "
"``quoting``: quote system (default ``csv.QUOTE_MINIMAL``)"
msgstr ""
"Ambos `` export_to_csv_file`` e `` import_from_csv_file`` aceitar "
"argumentos de palavra-chave que contam o analisador CSV o formato para "
"salvar / carregar os arquivos: - `` delimiter``: delimitador para separar "
"valores (padrão '') - `` quotechar ``: personagem para usar para citar "
"valores String (default para aspas) - `` quoting``: sistema de cotação "
"(padrão `` csv.QUOTE_MINIMAL``)"

#: ../../chapter-07.rst:4018
msgid "Here is some example usage:"
msgstr "Aqui estão algumas Exemplo de uso:"

#: ../../chapter-07.rst:4030
msgid "Which would render something similar to"
msgstr "O que tornaria algo semelhante a"

#: ../../chapter-07.rst:4036
msgid "For more information consult the official Python documentation"
msgstr "Para mais informações consulte a documentação oficial do Python"

#: ../../chapter-07.rst:4039
msgid "Caching selects"
msgstr "Selects com cache"

#: ../../chapter-07.rst:4041
msgid ""
"The select method also takes a ``cache`` argument, which defaults to None. "
"For caching purposes, it should be set to a tuple where the first element "
"is the cache model (``cache.get`` when using py4web), and the second "
"element is the expiration time in seconds."
msgstr ""
"O método de seleção também leva um argumento cache`` ``, cujo padrão é "
"None. Para fins de armazenamento em cache, deve ser definido como um tuplo "
"em que o primeiro elemento é o modelo do cache ( `` cache.get``, `` cache."
"disk``, etc), e o segundo elemento é o tempo de validade em segundo ."

#: ../../chapter-07.rst:4046
msgid ""
"In the following example, you see a controller that caches a select on the "
"previously defined db.log table. The actual select fetches data from the "
"back-end database no more frequently than once every 60 seconds and stores "
"the result in memory. If the next call to this controller occurs in less "
"than 60 seconds since the last database IO, it simply fetches the previous "
"data from memory."
msgstr ""
"No exemplo a seguir, você vê um controlador que armazena em cache um seleto "
"sobre a mesa db.log previamente definido. As buscas reais dados "
"selecionados do banco de dados back-end não mais do que uma vez a cada 60 "
"segundos e armazena o resultado na memória. Se a próxima chamada para este "
"controlador ocorre em menos de 60 segundos desde o último banco de dados "
"IO, ele simplesmente vai buscar os dados anteriores da memória."

#: ../../chapter-07.rst:4059
msgid ""
"The ``select`` method has an optional ``cacheable`` argument, normally set "
"to False. When ``cacheable=True`` the resulting ``Rows`` is serializable "
"but The ``Row``\\ s lack ``update_record`` and ``delete_record`` methods."
msgstr ""
"O método `SELECT`` tem um argumento` `cacheable`` opcional, normalmente "
"definido como False. Quando `` cacheável = True`` o resultante `` Rows`` "
"Serializável mas `` A falta row`` \\ s `` `` update_record`` e métodos "
"delete_record``."

#: ../../chapter-07.rst:4064
msgid ""
"If you do not need these methods you can speed up selects a lot by setting "
"the ``cacheable`` attribute:"
msgstr ""
"Se você não precisar destes métodos você pode acelerar seleciona um lote, "
"definindo o atributo `` cacheable``:"

#: ../../chapter-07.rst:4071
msgid ""
"When the ``cache`` argument is set but ``cacheable=False`` (default) only "
"the database results are cached, not the actual Rows object. When the "
"``cache`` argument is used in conjunction with ``cacheable=True`` the "
"entire Rows object is cached and this results in much faster caching:"
msgstr ""
"Quando o argumento `` cache`` está definido, mas `` cacheable = False`` "
"(default), apenas os resultados de banco de dados são armazenados em cache, "
"não as linhas reais objeto. Quando o argumento `` cache`` é usado em "
"conjunto com `` cacheável = True`` as linhas inteiras objecto é cache e "
"isso resulta em muito mais rápido cache:"

#: ../../chapter-07.rst:4082
msgid "Self-Reference and aliases"
msgstr "A auto-referência e aliases"

#: ../../chapter-07.rst:4084
msgid ""
"It is possible to define tables with fields that refer to themselves, here "
"is an example:"
msgstr ""
"É possível definir tabelas com campos que se referem a si mesmos, aqui está "
"um exemplo:"

#: ../../chapter-07.rst:4094
msgid ""
"Notice that the alternative notation of using a table object as field type "
"will fail in this case, because it uses a table before it is defined:"
msgstr ""
"Observe que a notação alternativa de usar um objeto de tabela como tipo de "
"campo irá falhar neste case, porque ele usa uma tabela antes de ser "
"definido:"

#: ../../chapter-07.rst:4105
msgid ""
"In general ``db.tablename`` and ``'reference tablename'`` are equivalent "
"field types, but the latter is the only one allowed for self-references."
msgstr ""
"Em geral `` `db.tablename`` e '` referência tablename'`` são tipos de campo "
"equivalentes, mas o último é o único que tem permissão para auto-"
"referências."

#: ../../chapter-07.rst:4108
msgid ""
"When a table has a self-reference and you have to do join, for example to "
"select a person and its father, you need an alias for the table. In SQL an "
"alias is a temporary alternate name you can use to reference a table/column "
"into a query (or other SQL statement)."
msgstr ""
"Quando uma tabela tem uma auto-referência e você tem que fazer se juntar, "
"por exemplo, para selecionar uma pessoa e seu pai, você precisa de um alias "
"para a tabela. Em SQL um alias é um nome alternativo temporário que você "
"pode usar para fazer referência a uma tabela / coluna em uma consulta (ou "
"outra instrução SQL)."

#: ../../chapter-07.rst:4113
msgid ""
"With py4web you can make an alias for a table using the ``with_alias`` "
"method. This works also for expressions, which means also for fields since "
"``Field`` is derived from ``Expression``."
msgstr ""
"Com py4web você pode fazer um alias para uma tabela usando o método "
"`with_alias``. Isso funciona também para expressões, o que significa também "
"para campos desde `` Field`` é derivada de `` Expression``."

#: ../../chapter-07.rst:4140
msgid ""
"Notice that we have chosen to make a distinction between: - “father_id”: "
"the field name used in the table “person”; - “father”: the alias we want to "
"use for the table referenced by the above field; this is communicated to "
"the database; - “Father”: the variable used by py4web to refer to that "
"alias."
msgstr ""
"Observe que optámos por fazer uma distinção entre: - “father_id”: o nome do "
"campo usado na “pessoa” mesa; - “pai”: o alias que deseja usar para a "
"tabela referenciada pelo campo acima; esta é comunicada ao banco de dados; "
"- “Pai”: a variável usada por py4web para se referir a esse alias."

#: ../../chapter-07.rst:4146
msgid ""
"The difference is subtle, and there is nothing wrong in using the same name "
"for the three of them:"
msgstr ""
"A diferença é sutil, e não há nada de errado em usar o mesmo nome para os "
"três:"

#: ../../chapter-07.rst:4171
msgid ""
"But it is important to have the distinction clear in order to build correct "
"queries."
msgstr ""
"Mas é importante ter a distinção clara, a fim de construir perguntas "
"corretas."

#: ../../chapter-07.rst:4175
msgid "Advanced features"
msgstr "Características avançadas"

#: ../../chapter-07.rst:4178
msgid "Table inheritance"
msgstr "Herança de tabela"

#: ../../chapter-07.rst:4180
msgid ""
"It is possible to create a table that contains all the fields from another "
"table. It is sufficient to pass the other table in place of a field to "
"``define_table``. For example"
msgstr ""
"É possível criar uma tabela que contém todos os campos de outra tabela. É "
"suficiente para passar a outra tabela no lugar de um campo para `` "
"define_table``. Por exemplo"

#: ../../chapter-07.rst:4191
msgid ""
"It is also possible to define a dummy table that is not stored in a "
"database in order to reuse it in multiple other places. For example:"
msgstr ""
"Também é possível definir uma tabela fictícia que não está armazenado em um "
"banco de dados, a fim de reutilizá-la em vários outros lugares. Por exemplo:"

#: ../../chapter-07.rst:4205
msgid "This example assumes that standard py4web authentication is enabled."
msgstr ""
"Este exemplo parte do princípio que a autenticação py4web padrão está "
"activada."

#: ../../chapter-07.rst:4207
msgid ""
"Notice that if you use ``Auth`` py4web already creates one such table for "
"you:"
msgstr ""
"Note que se você usar `` Auth`` py4web já cria uma tal mesa para você:"

#: ../../chapter-07.rst:4215
msgid ""
"When using table inheritance, if you want the inheriting table to inherit "
"validators, be sure to define the validators of the parent table before "
"defining the inheriting table."
msgstr ""
"Ao usar herança de tabela, se você deseja que a tabela herdar a validadores "
"herdar, certifique-se de definir os validadores de tabela pai antes de "
"definir a tabela herdar."

#: ../../chapter-07.rst:4220
msgid "``filter_in`` and ``filter_out``"
msgstr "`` `` Filter_in`` e filter_out``"

#: ../../chapter-07.rst:4222
msgid ""
"It is possible to define a filter for each field to be called before a "
"value is inserted into the database for that field and after a value is "
"retrieved from the database."
msgstr ""
"É possível definir um filtro para cada campo a ser chamada antes de um "
"valor é inserido na banco de dados para esse campo e depois de um valor é "
"recuperado a partir da banco de dados."

#: ../../chapter-07.rst:4226
msgid ""
"Imagine for example that you want to store a serializable Python data "
"structure in a field in the json format. Here is how it could be "
"accomplished:"
msgstr ""
"Imagine por exemplo que você deseja armazenar uma estrutura serializado "
"dados Python em um campo no formato JSON. Aqui está como isso poderia ser "
"feito:"

#: ../../chapter-07.rst:4245
msgid ""
"Another way to accomplish the same is by using a Field of type "
"``SQLCustomType``, as discussed in next `Custom ``Field`` types "
"<#Custom_Field_Types>`__ section."
msgstr ""
"Outra maneira de fazer a mesma é usando um campo do tipo `` "
"SQLCustomType``, como discutido na próxima `personalizado` `tipos Field`` "
"<#Custom_Field_Types>` __ seção."

#: ../../chapter-07.rst:4250
msgid "callbacks on record insert, delete and update"
msgstr "retornos de chamada no registro de inserção, exclusão e atualização"

#: ../../chapter-07.rst:4252
msgid ""
"PY4WEB provides a mechanism to register callbacks to be called before and/"
"or after insert, update and delete of records."
msgstr ""
"PY4WEB fornece um mecanismo para registrar retornos de chamada para ser "
"chamado antes e / ou após a inserção, atualização e exclusão de registros."

#: ../../chapter-07.rst:4255
msgid "Each table stores six lists of callbacks:"
msgstr "Cada tabela armazena seis listas de chamadas de retorno:"

#: ../../chapter-07.rst:4266
msgid ""
"You can register a callback function by appending it to the corresponding "
"list. The caveat is that depending on the functionality, the callback has "
"different signature."
msgstr ""
"Você pode registrar uma função de retorno de chamada, acrescentando-o à "
"lista correspondente. A ressalva é que, dependendo da funcionalidade, o "
"retorno tem assinatura diferente."

#: ../../chapter-07.rst:4270
msgid "This is best explained via some examples."
msgstr "Isto é melhor explicado através de alguns exemplos."

#: ../../chapter-07.rst:4298
msgid ""
"As you can see: - ``f`` gets passed the ``OpRow`` object with data for "
"insert or update. - ``i`` gets passed the id of the newly inserted record. "
"- ``s`` gets passed the ``Set`` object used for update or delete. ``OpRow`` "
"is an helper object specialized in storing (field, value) pairs, you can "
"think of it as a normal dictionary that you can use even with the syntax of "
"attribute notation (that is ``f.name`` and ``f['name']`` are equivalent)."
msgstr ""
"Como você pode ver: - `` f`` é passado o objeto `` OpRow`` com os dados "
"para inserção ou atualização. - `` i`` é passado o id do registro recém-"
"inserido. - `` s`` é passado o objeto `` Set`` usado para atualizar ou "
"excluir. `` OpRow`` é um objeto auxiliar especializada em armazenamento "
"(campo, valor) pares, você pode pensar nisso como um dicionário normal que "
"você pode usar até mesmo com a sintaxe da notação atributo (que é `` f."
"name`` e `` f [ 'nome'] `` são equivalentes)."

#: ../../chapter-07.rst:4306
msgid ""
"The return values of these callback should be ``None`` or ``False``. If any "
"of the ``_before_*`` callback returns a ``True`` value it will abort the "
"actual insert/update/delete operation."
msgstr ""
"Os valores de retorno destes callback deve ser `` None`` ou `` False``. Se "
"qualquer um dos `` _antes_ * `` retorno de chamada retorna um `` valor "
"True`` ele irá abortar a / update / operação de exclusão real de inserção."

#: ../../chapter-07.rst:4310
msgid ""
"Some times a callback may need to perform an update in the same or a "
"different table and one wants to avoid firing other callbacks, which could "
"cause an infinite loop."
msgstr ""
"Algumas vezes uma chamada de retorno pode precisar executar uma atualização "
"na mesma ou em uma tabela diferente e se quer evitar disparar outras "
"chamadas de retorno, o que poderia causar um loop infinito."

#: ../../chapter-07.rst:4314
msgid ""
"For this purpose there the ``Set`` objects have an ``update_naive`` method "
"that works like ``update`` but ignores before and after callbacks."
msgstr ""
"Para este efeito, há os objetos `` Set`` tem um método `update_naive`` que "
"funciona como` `update`` mas ignora antes e depois de retornos de chamada."

#: ../../chapter-07.rst:4319
msgid "Database cascades"
msgstr "Cascades no banco de dados"

#: ../../chapter-07.rst:4321
msgid ""
"Database schema can define relationships which trigger deletions of related "
"records, known as cascading. The DAL is not informed when a record is "
"deleted due to a cascade. So no \\*_delete callaback will ever be called as "
"conseguence of a cascade-deletion."
msgstr ""
"Esquema de banco de dados pode definir relacionamentos que  de disparam "
"exclusão de registros relacionados, conhecidos como cascade. A DAL não é "
"informado quando um registro é excluído devido a um cascade. Portanto, não "
"o callaback  \\*_delete  nunca vai ser chamado como consequência de uma "
"exclusão em cascata."

#: ../../chapter-07.rst:4327
msgid "Record versioning"
msgstr "versionamento recorde"

#: ../../chapter-07.rst:4329
msgid ""
"It is possible to ask py4web to save every copy of a record when the record "
"is individually modified. There are different ways to do it and it can be "
"done for all tables at once using the syntax:"
msgstr ""
"É possível pedir py4web para salvar cada cópia de um registro quando o "
"registro é modificado individualmente. Existem diferentes maneiras de fazer "
"isso e que pode ser feito para todas as tabelas ao mesmo tempo usando a "
"sintaxe:"

#: ../../chapter-07.rst:4337
msgid ""
"this requires ``Auth``. It can also be done for each individual table as "
"discussed below."
msgstr ""
"isso requer `` Auth``. Ele também pode ser feito para cada mesa, como "
"discutido abaixo."

#: ../../chapter-07.rst:4340
msgid "Consider the following table:"
msgstr "Considere a seguinte tabela:"

#: ../../chapter-07.rst:4350
msgid ""
"Notice the hidden boolean field called ``is_active`` and defaulting to True."
msgstr ""
"Observe o campo booleano oculto chamado `` is_active`` e padronizando para "
"True."

#: ../../chapter-07.rst:4353
msgid ""
"We can tell py4web to create a new table (in the same or a different "
"database) and store all previous versions of each record in the table, when "
"modified."
msgstr ""
"Podemos dizer py4web para criar uma nova tabela (no mesmo ou em outro banco "
"de dados) e armazenar todas as versões anteriores de cada registro na "
"tabela, quando modificado."

#: ../../chapter-07.rst:4357
msgid "This is done in the following way:"
msgstr "Isso é feito da seguinte maneira:"

#: ../../chapter-07.rst:4363
msgid "or in a more verbose syntax:"
msgstr "ou em uma sintaxe mais detalhado:"

#: ../../chapter-07.rst:4372
msgid ""
"The ``archive_db=db`` tells py4web to store the archive table in the same "
"database as the ``stored_item`` table. The ``archive_name`` sets the name "
"for the archive table. The archive table has the same fields as the "
"original table ``stored_item`` except that unique fields are no longer "
"unique (because it needs to store multiple versions) and has an extra field "
"which name is specified by ``current_record`` and which is a reference to "
"the current record in the ``stored_item`` table."
msgstr ""
"O `` archive_db = db`` diz py4web para armazenar a tabela de arquivo no "
"mesmo banco de dados como o `` tabela stored_item``. O `` archive_name`` "
"define o nome para a tabela de arquivo. A tabela de arquivo tem os mesmos "
"campos como a tabela original `` stored_item`` exceto que campos exclusivos "
"não são mais exclusivo (porque ele precisa para armazenar várias versões) e "
"tem um campo extra que nome é especificado por `` current_record`` e que é "
"uma referência para o registo atual na tabela `` stored_item``."

#: ../../chapter-07.rst:4380
msgid ""
"When records are deleted, they are not really deleted. A deleted record is "
"copied in the ``stored_item_archive`` table (like when it is modified) and "
"the ``is_active`` field is set to False. By enabling record versioning "
"py4web sets a ``common_filter`` on this table that hides all records in "
"table ``stored_item`` where the ``is_active`` field is set to False. The "
"``is_active`` parameter in the ``_enable_record_versioning`` method allows "
"to specify the name of the field used by the ``common_filter`` to determine "
"if the field was deleted or not."
msgstr ""
"Quando os registros são excluídos, eles não são realmente excluídos. Um "
"registro excluído é copiado na tabela `` stored_item_archive`` (como quando "
"ele é modificado) e do campo `` is_active`` é definido como False. Ao "
"permitir gravar versões conjuntos py4web um `` common_filter`` nesta tabela "
"que esconde todos os registros na tabela `` stored_item`` onde o campo `` "
"is_active`` é definida como falsa. O parâmetro `` is_active`` no método "
"`_enable_record_versioning`` permite especificar o nome do campo usado "
"pelo` `common_filter`` para determinar se o campo foi excluído ou não."

#: ../../chapter-07.rst:4390
msgid ""
"``common_filter``\\ s will be discussed in next `Common filters "
"<#common_filters>`__ section."
msgstr ""
"`` Common_filter`` \\ s será discutido nos próximos `filtros em comum "
"<#common_filters>` seção __."

#: ../../chapter-07.rst:4394
msgid "Common fields and multi-tenancy"
msgstr "campos comuns e multi-tenancy"

#: ../../chapter-07.rst:4396
msgid ""
"``db._common_fields`` is a list of fields that should belong to all the "
"tables. This list can also contain tables and it is understood as all "
"fields from the table."
msgstr ""
"`` Db._common_fields`` é uma lista de campos que devem pertencem a todas as "
"tabelas. Esta lista também pode conter tabelas e entende-se que todos os "
"campos da tabela."

#: ../../chapter-07.rst:4400
msgid ""
"For example occasionally you find yourself in need to add a signature to "
"all your tables but the ``Auth`` tables. In this case, after you ``auth."
"define_tables()`` but before defining any other table, insert:"
msgstr ""
"Por exemplo, ocasionalmente, você se encontra em necessidade de adicionar "
"uma assinatura a todas as suas tabelas, mas os `` tabelas Auth``. Neste "
"case, depois de `` auth.define_tables () ``, mas antes de definir qualquer "
"outra tabela, inserir:"

#: ../../chapter-07.rst:4408
msgid ""
"One field is special: ``request_tenant``, you can set a different name in "
"``db._request_tenant``. This field does not exist but you can create it and "
"add it to any of your tables (or all of them):"
msgstr ""
"Um campo é especial: `` request_tenant``, você pode definir um nome "
"diferente em `` db._request_tenant``. Este campo não existe, mas você pode "
"criá-lo e adicioná-lo a qualquer um dos seus quadros (ou todas elas):"

#: ../../chapter-07.rst:4418
msgid ""
"For every table with such a field, all records for all queries are always "
"automatically filtered by:"
msgstr ""
"Para cada mesa com tal campo um, todos os registros para todas as consultas "
"são sempre filtrados automaticamente por:"

#: ../../chapter-07.rst:4425
msgid ""
"and for every record inserted, this field is set to the default value. In "
"the example above we have chosen:"
msgstr ""
"e para cada registro inserido, este campo é definido como o valor padrão. "
"No exemplo acima, nós escolhemos:"

#: ../../chapter-07.rst:4432
msgid ""
"this means we have chosen to ask our app to filter all tables in all "
"queries with:"
msgstr ""
"Isso significa que temos escolhido para perguntar nosso aplicativo para "
"filtrar todas as tabelas em todas as consultas com:"

#: ../../chapter-07.rst:4439
msgid ""
"This simple trick allow us to turn any application into a multi-tenant "
"application. Even though we run one instance of the application and we use "
"one single database, when the application is accessed under two or more "
"domains the visitors will see different data depending on the domain (in "
"the example the domain name is retrieved from ``request.env.http_host``)."
msgstr ""
"Este truque simples nos permitem transformar qualquer aplicativo em um "
"aplicativo multi-tenant. Mesmo que executar uma instância do aplicativo e "
"usar um único banco de dados, quando o aplicativo é acessado em dois ou "
"mais domínios os visitantes poderão ver dados diferentes dependendo do "
"domínio (no exemplo, o nome de domínio é recuperado do `` pedido. env."
"http_host``)."

#: ../../chapter-07.rst:4446
msgid ""
"You can turn off multi tenancy filters using ``ignore_common_filters=True`` "
"at ``Set`` creation time:"
msgstr ""
"Você pode desativar filtros multi-tenancy usando `` ignore_common_filters = "
"True`` em `` tempo de criação Set``:"

#: ../../chapter-07.rst:4454
msgid "Common filters"
msgstr "filtros comuns"

#: ../../chapter-07.rst:4456
msgid ""
"A common filter is a generalization of the above multi-tenancy idea. It "
"provides an easy way to prevent repeating of the same query. Consider for "
"example the following table:"
msgstr ""
"Um filtro comum é uma generalização da ideia multi-tenancy acima. Ele "
"fornece uma maneira fácil de evitar a repetição da mesma consulta. "
"Considere, por exemplo, a tabela a seguir:"

#: ../../chapter-07.rst:4468
msgid ""
"Any select, delete or update in this table, will include only public blog "
"posts. The attribute can also be modified at runtime:"
msgstr ""
"Qualquer select, DELETE ou UPDATE nesta tabela, vai incluir posts única "
"públicos. O atributo também pode ser modificado em tempo de execução:"

#: ../../chapter-07.rst:4475
msgid ""
"It serves both as a way to avoid repeating the “db.blog_post."
"is_public==True” phrase in each blog post search, and also as a security "
"enhancement, that prevents you from forgetting to disallow viewing of non-"
"public posts."
msgstr ""
"Ela serve tanto como uma forma de evitar a repetição do “db.blog_post."
"is_public == True” frase em cada blog pesquisa post, e também como uma "
"melhoria de segurança, que o impede de esquecer para não permitir a "
"visualização de mensagens não-públicas."

#: ../../chapter-07.rst:4480
msgid ""
"In case you actually do want items left out by the common filter (for "
"example, allowing the admin to see non-public posts), you can either remove "
"the filter:"
msgstr ""
"No case de você realmente quer itens deixados de fora pelo filtro comum "
"(por exemplo, permitindo que o administrador para ver mensagens não-"
"públicas), você pode remover o filtro:"

#: ../../chapter-07.rst:4488
msgid "or ignore it:"
msgstr "ou ignorá-lo:"

#: ../../chapter-07.rst:4496
msgid "Note that common_filters are ignored by the appadmin interface."
msgstr "Note-se que common_filters são ignorados pela interface AppAdmin."

#: ../../chapter-07.rst:4499
msgid "Custom ``Field`` types"
msgstr "Personalizados `` tipos Field``"

#: ../../chapter-07.rst:4501
msgid ""
"Aside for using ``filter_in`` and ``filter_out``, it is possible to define "
"new/custom field types. For example, suppose that you want to define a "
"custom type to store an IP address:"
msgstr ""
"Além de usar o `` filter_in`` e `` filter_out``, é possível definir novos "
"tipos de campos / personalizados. Por exemplo, suponha que você deseja "
"definir um tipo personalizado para armazenar um endereço IP:"

#: ../../chapter-07.rst:4546
msgid ""
"``SQLCustomType`` is a field type factory. Its ``type`` argument must be "
"one of the standard py4web types. It tells py4web how to treat the field "
"values at the py4web level. ``native`` is the type of the field as far as "
"the database is concerned. Allowed names depend on the database engine. "
"``encoder`` is an optional transformation function applied when the data is "
"stored and ``decoder`` is the optional reverse transformation function."
msgstr ""
"`` SQLCustomType`` é uma fábrica tipo de campo. Seu argumento `` type`` "
"deve ser um dos tipos py4web padrão. Diz py4web como tratar os valores de "
"campo no nível py4web. `` Native`` é o tipo do campo, tanto quanto a banco "
"de dados está em causa. nomes permitidos dependem do mecanismo de banco de "
"dados. `` Encoder`` é uma transformação opcional função aplicada quando os "
"dados são armazenados e `` decoder`` é a função de transformação inversa "
"opcional."

#: ../../chapter-07.rst:4554
msgid ""
"This feature is marked as experimental. In practice it has been in py4web "
"for a long time and it works but it can make the code not portable, for "
"example when the native type is database specific."
msgstr ""
"Esta característica é marcado como experimental. Na prática, tem sido no "
"py4web por um longo tempo e ele funciona, mas ele pode fazer o código não é "
"portátil, por exemplo, quando o tipo nativo é específico do banco de dados."

#: ../../chapter-07.rst:4558
msgid "It does not work on Google App Engine NoSQL."
msgstr "Ele não funciona no Google App Engine NoSQL."

#: ../../chapter-07.rst:4561
msgid "Using DAL without define tables"
msgstr "Usando DAL sem definir tabelas"

#: ../../chapter-07.rst:4563
msgid "The DAL can be used from any Python program simply by doing this:"
msgstr ""
"A DAL pode ser usado a partir de qualquer programa Python simplesmente "
"fazendo isso:"

#: ../../chapter-07.rst:4570
msgid ""
"i.e. import the DAL, connect and specify the folder which contains the ."
"table files (the app/databases folder)."
msgstr ""
"ou seja, importar a DAL, conexão e especificar a pasta que contém os "
"arquivos .table (a pasta app / bancos de dados)."

#: ../../chapter-07.rst:4573
msgid ""
"To access the data and its attributes we still have to define all the "
"tables we are going to access with ``db.define_table``."
msgstr ""
"Para acessar os dados e seus atributos ainda temos que definir todas as "
"tabelas que vão de acesso com `` db.define_table``."

#: ../../chapter-07.rst:4576
msgid ""
"If we just need access to the data but not to the py4web table attributes, "
"we get away without re-defining the tables but simply asking py4web to read "
"the necessary info from the metadata in the .table files:"
msgstr ""
"Se nós apenas precisam de acesso aos dados, mas não para os atributos da "
"tabela py4web, nós fugir sem re-definir as tabelas, mas simplesmente "
"pedindo py4web para ler as informações necessárias a partir dos metadados "
"nos ficheiros .table:"

#: ../../chapter-07.rst:4585
msgid "This allows us to access any db.table without need to re-define it."
msgstr ""
"Isso nos permite acessar qualquer db.table sem necessidade de re definir-lo."

#: ../../chapter-07.rst:4588
msgid "PostGIS, SpatiaLite, and MS Geo (experimental)"
msgstr "PostGIS, SpatiaLite, e MS Geo (experimental)"

#: ../../chapter-07.rst:4590
msgid ""
"The DAL supports geographical APIs using PostGIS (for PostgreSQL), "
"SpatiaLite (for SQLite), and MSSQL and Spatial Extensions. This is a "
"feature that was sponsored by the Sahana project and implemented by Denes "
"Lengyel."
msgstr ""
"Os suportes DAL APIs geográficas usando PostGIS (para PostgreSQL), "
"SpatiaLite (para SQLite), e MSSQL e extensões espaciais. Este é um recurso "
"que foi patrocinado pelo projeto Sahana e implementado por Denes Lengyel."

#: ../../chapter-07.rst:4595
msgid ""
"DAL provides geometry and geography fields types and the following "
"functions:"
msgstr ""
"DAL fornece geometria e geografia campos tipos e as seguintes funções:"

#: ../../chapter-07.rst:4613
msgid "Here are some examples:"
msgstr "aqui estão alguns exemplos:"

#: ../../chapter-07.rst:4621
msgid "Below we insert a point, a line, and a polygon:"
msgstr "A seguir, insira um ponto, uma linha, e um polígono:"

#: ../../chapter-07.rst:4632
msgid "Notice that"
msgstr "Notar que"

#: ../../chapter-07.rst:4638
msgid ""
"Always returns the geometry data serialized as text. You can also do the "
"same more explicitly using ``st_astext()``:"
msgstr ""
"Sempre retorna os dados de geometria serializados como texto. Você também "
"pode fazer o mesmo mais explicitamente usando `` ST_AsText () ``:"

#: ../../chapter-07.rst:4649
msgid ""
"You can ask for the native representation by using ``st_asgeojson()`` (in "
"PostGIS only):"
msgstr ""
"Você pode pedir a representação nativa usando `` st_asgeojson () `` (em "
"apenas PostGIS):"

#: ../../chapter-07.rst:4660
msgid ""
"(notice an array is a point, an array of arrays is a line, and an array of "
"array of arrays is a polygon)."
msgstr ""
"(Nota uma matriz é um ponto, uma matriz de matrizes é uma linha, e um "
"conjunto de matriz de matrizes é um polígono)."

#: ../../chapter-07.rst:4663
msgid "Here are example of how to use geographical functions:"
msgstr "Aqui estão exemplo de como usar as funções geográficas:"

#: ../../chapter-07.rst:4674
msgid "Computed distances can also be retrieved as floating point numbers:"
msgstr ""
"distâncias calculadas também pode ser recuperado como números de ponto "
"flutuante:"

#: ../../chapter-07.rst:4686
msgid "Copy data from one db into another"
msgstr "Copiar dados de um para outro db"

#: ../../chapter-07.rst:4688
msgid ""
"Consider the situation in which you have been using the following database:"
msgstr ""
"Considere a situação em que você estiver usando o seguinte banco de dados:"

#: ../../chapter-07.rst:4695
msgid ""
"and you wish to move to another database using a different connection "
"string:"
msgstr ""
"e você deseja mover para outro banco de dados usando uma seqüência de "
"conexão diferente:"

#: ../../chapter-07.rst:4702
msgid ""
"Before you switch, you want to move the data and rebuild all the metadata "
"for the new database. We assume the new database to exist but we also "
"assume it is empty."
msgstr ""
"Antes de mudar, você quer mover os dados e reconstruir todos os metadados "
"para o novo banco de dados. Assumimos o novo banco de dados a existir, mas "
"nós também assumir que é vazio."

#: ../../chapter-07.rst:4706
msgid "PY4WEB provides a script that does this work for you:"
msgstr "PY4WEB fornece um script que faz este trabalho para você:"

#: ../../chapter-07.rst:4717
msgid ""
"After running the script you can simply switch the connection string in the "
"model and everything should work out of the box. The new data should be "
"there."
msgstr ""
"Depois de executar o script, você pode simplesmente mudar a seqüência de "
"conexão no modelo e tudo deve funcionar fora da caixa. Os novos dados devem "
"estar lá."

#: ../../chapter-07.rst:4721
msgid ""
"This script provides various command line options that allows you to move "
"data from one application to another, move all tables or only some tables, "
"clear the data in the tables. For more info try:"
msgstr ""
"Este script fornece várias opções de linha de comando que permite que você "
"mover dados de uma aplicação para outra, mover todas as tabelas ou apenas "
"algumas mesas, limpar os dados nas tabelas. Para mais informações tentativa:"

#: ../../chapter-07.rst:4730
msgid "Note on new DAL and adapters"
msgstr "Nota sobre novo DAL e adaptadores"

#: ../../chapter-07.rst:4732
msgid ""
"The source code of the Database Abstraction Layer was completely rewritten "
"in 2010. While it stays backward compatible, the rewrite made it more "
"modular and easier to extend. Here we explain the main logic."
msgstr ""
"O código fonte do Banco de Dados Camada de Abstração foi completamente "
"reescrito em 2010. Enquanto ele permanece compatível com versões "
"anteriores, a reescrita tornou mais modular e mais fácil de estender. Aqui "
"nós explicamos a lógica principal."

#: ../../chapter-07.rst:4736
msgid "The file “gluon/dal.py” defines, among other, the following classes."
msgstr ""
"O arquivo “glúons / dal.py” define, entre outras, as seguintes classes."

#: ../../chapter-07.rst:4752
msgid ""
"Their use has been explained in the previous sections, except for "
"``BaseAdapter``. When the methods of a ``Table`` or ``Set`` object need to "
"communicate with the database they delegate to methods of the adapter the "
"task to generate the SQL and or the function call."
msgstr ""
"Seu uso tem sido explicado nas seções anteriores, exceto para `` "
"BaseAdapter``. Quando os métodos de um `` Table`` ou `` necessidade objeto "
"Set`` para se comunicar com o banco de dados que confiam aos métodos do "
"adaptador a tarefa para gerar o SQL e ou a chamada de função."

#: ../../chapter-07.rst:4763
msgid "calls"
msgstr "chamadas"

#: ../../chapter-07.rst:4769
msgid "which delegates the adapter by returning:"
msgstr "que delega o adaptador de voltar:"

#: ../../chapter-07.rst:4775
msgid ""
"Here ``db.mytable._listify`` converts the dict of arguments into a list of "
"``(field,value)`` and calls the ``insert`` method of the ``adapter``. ``db."
"_adapter`` does more or less the following:"
msgstr ""
"Aqui `` convertidos db.mytable._listify`` o dict dos argumentos em uma "
"lista de `` (campo, valor) `` e chama o método `insert`` do` `adapter``. `` "
"Db._adapter`` faz mais ou menos o seguinte:"

#: ../../chapter-07.rst:4784
msgid "where the first line builds the query and the second executes it."
msgstr "onde a primeira linha constrói a consulta e o segundo executa."

#: ../../chapter-07.rst:4786
msgid "``BaseAdapter`` defines the interface for all adapters."
msgstr "`` BaseAdapter`` define a interface para todas as placas."

#: ../../chapter-07.rst:4788
msgid ""
"“gluon/dal.py” at the moment of writing this book, contains the following "
"adapters:"
msgstr ""
"“Glúon / dal.py” no momento de escrever este livro, contém os seguintes "
"adaptadores:"

#: ../../chapter-07.rst:4821
msgid "which override the behavior of the ``BaseAdapter``."
msgstr "que substituir o comportamento dos `` BaseAdapter``."

#: ../../chapter-07.rst:4823
msgid "Each adapter has more or less this structure:"
msgstr "Cada adaptador tem mais ou menos a seguinte estrutura:"

#: ../../chapter-07.rst:4860
msgid ""
"Looking at the various adapters as example should be easy to write new ones."
msgstr ""
"Olhando para os vários adaptadores como exemplo deve ser fácil de escrever "
"novos."

#: ../../chapter-07.rst:4863
msgid "When ``db`` instance is created:"
msgstr "Quando `` db`` exemplo é criado:"

#: ../../chapter-07.rst:4869
msgid ""
"the prefix in the uri string defines the adapter. The mapping is defined in "
"the following dictionary also in “gluon/dal.py”:"
msgstr ""
"o prefixo na strings de uri define o adaptador. O mapeamento é definido no "
"seguinte dicionário também em “gluão / dal.py”:"

#: ../../chapter-07.rst:4912
msgid "the uri string is then parsed in more detail by the adapter itself."
msgstr ""
"a string URI é então analisado com mais detalhes pelo próprio adaptador."

#: ../../chapter-07.rst:4914
msgid "For any adapter you can replace the driver with a different one:"
msgstr ""
"Para qualquer adaptador que você pode substituir o motorista com um "
"diferente:"

#: ../../chapter-07.rst:4922
msgid ""
"i.e. ``mysqldb`` has to be *that module* with a .connect() method. You can "
"specify optional driver arguments and adapter arguments:"
msgstr ""
"isto é `` mysqldb`` tem de ser * que * módulo com um método .Connect (). "
"Você pode especificar argumentos motorista opcionais e argumentos adaptador:"

#: ../../chapter-07.rst:4930
msgid "Gotchas"
msgstr "Pegadinhas"

#: ../../chapter-07.rst:4935
msgid ""
"SQLite does not support dropping and altering columns. That means that "
"py4web migrations will work up to a point. If you delete a field from a "
"table, the column will remain in the database but will be invisible to "
"py4web. If you decide to reinstate the column, py4web will try re-create it "
"and fail. In this case you must set ``fake_migrate=True`` so that metadata "
"is rebuilt without attempting to add the column again. Also, for the same "
"reason, **SQLite** is not aware of any change of column type. If you insert "
"a number in a string field, it will be stored as string. If you later "
"change the model and replace the type “string” with type “integer”, SQLite "
"will continue to keep the number as a string and this may cause problem "
"when you try to extract the data."
msgstr ""
"SQLite não apoiar caindo e alterar colunas. Isso significa que as migrações "
"py4web irão trabalhar até certo ponto. Se você excluir um campo de uma "
"tabela, a coluna permanecerá no banco de dados, mas será invisível para "
"py4web. Se você decidir para restabelecer a coluna, py4web vai tentar "
"recriá-la e falhar. Neste case, você deve definir `` fake_migrate = True`` "
"de modo que os metadados é reconstruído sem tentar adicionar a coluna "
"novamente. Além disso, pela mesma razão, ** SQLite ** não tem conhecimento "
"de qualquer mudança de tipo de coluna. Se você inserir um número em um "
"campo string, ele será armazenado como string. Se posteriormente você "
"alterar o modelo e substituir o tipo “string” com o tipo “inteiro”, SQLite "
"continuará a manter o número como uma string e isso pode causar problemas "
"quando você tenta extrair os dados."

#: ../../chapter-07.rst:4947
msgid ""
"SQLite doesn’t have a boolean type. py4web internally maps booleans to a 1 "
"character string, with ‘T’ and ‘F’ representing True and False. The DAL "
"handles this completely; the abstraction of a true boolean value works "
"well. But if you are updating the SQLite table with SQL directly, be aware "
"of the py4web implementation, and avoid using 0 and 1 values."
msgstr ""
"SQLite não tem um tipo booleano. py4web mapeia internamente booleans para "
"uma strings de 1 carácter, com ‘T’ e ‘F’ representar Verdadeiro e Falso. A "
"DAL lida com isso completamente; a abstração de um verdadeiro valor "
"booleano funciona bem. Mas se você estiver atualizando a tabela SQLite com "
"o SQL diretamente, estar ciente da implementação py4web, e evitar o uso de "
"0 e 1 valores."

#: ../../chapter-07.rst:4956
msgid ""
"MySQL does not support multiple ALTER TABLE within a single transaction. "
"This means that any migration process is broken into multiple commits. If "
"something happens that causes a failure it is possible to break a migration "
"(the py4web metadata are no longer in sync with the actual table structure "
"in the database). This is unfortunate but it can be prevented (migrate one "
"table at the time) or it can be fixed a posteriori (revert the py4web model "
"to what corresponds to the table structure in database, set "
"``fake_migrate=True`` and after the metadata has been rebuilt, set "
"``fake_migrate=False`` and migrate the table again)."
msgstr ""
"O MySQL não suporta múltiplos ALTER TABLE em uma única transação. Isto "
"significa que qualquer processo de migração é quebrado em vários commits. "
"Se algo acontece que faz com que uma falha é possível quebrar uma migração "
"(os metadados py4web não estão mais em sincronia com a estrutura da tabela "
"real no banco de dados). Isto é lamentável, mas ela pode ser prevenida "
"(migre uma mesa no tempo) ou pode ser fixado a posteriori (reverter o "
"modelo py4web ao que corresponde à estrutura da tabela na banco de dados, "
"conjunto `` fake_migrate = True`` e depois os metadados foi reconstruído, "
"conjunto `` fake_migrate = False`` e migrar a tabela de novo)."

#: ../../chapter-07.rst:4968
msgid "Google SQL"
msgstr "Google SQL"

#: ../../chapter-07.rst:4970
msgid ""
"Google SQL has the same problems as MySQL and more. In particular table "
"metadata itself must be stored in the database in a table that is not "
"migrated by py4web. This is because Google App Engine has a read-only file "
"system. PY4WEB migrations in Google SQL combined with the MySQL issue "
"described above can result in metadata corruption. Again, this can be "
"prevented (by migrating the table at once and then setting migrate=False so "
"that the metadata table is not accessed any more) or it can fixed a "
"posteriori (by accessing the database using the Google dashboard and "
"deleting any corrupted entry from the table called ``py4web_filesystem``."
msgstr ""
"Google SQL tem os mesmos problemas que o MySQL e muito mais. Em particular "
"metadados da tabela em si deve ser armazenado no banco de dados em uma "
"tabela que não é migrado por py4web. Isso ocorre porque o Google App Engine "
"tem um sistema de arquivos somente leitura. migrações PY4WEB em Google SQL "
"combinadas com a questão MySQL descrito acima pode resultar em corrupção de "
"metadados. Novamente, isso pode ser evitado (através da migração da mesa de "
"uma vez e, em seguida, definindo migrar = False para que a tabela de "
"metadados não é acessado mais) ou pode fixa a posteriori (acessando o banco "
"de dados usando o painel do Google e excluir qualquer entrada corrompido da "
"mesa chamado `` py4web_filesystem``."

#: ../../chapter-07.rst:4982
msgid "MSSQL (Microsoft SQL Server)"
msgstr "MSSQL (Microsoft SQL Server)"

#: ../../chapter-07.rst:4984
msgid ""
"MSSQL < 2012 does not support the SQL OFFSET keyword. Therefore the "
"database cannot do pagination. When doing a ``limitby=(a, b)`` py4web will "
"fetch the first ``a + b`` rows and discard the first ``a``. This may result "
"in a considerable overhead when compared with other database engines. If "
"you’re using MSSQL >= 2005, the recommended prefix to use is ``mssql3://`` "
"which provides a method to avoid the issue of fetching the entire non-"
"paginated resultset. If you’re on MSSQL >= 2012, use ``mssql4://`` that "
"uses the ``OFFSET ... ROWS ... FETCH NEXT ... ROWS ONLY`` construct to "
"support natively pagination without performance hits like other backends. "
"The ``mssql://`` uri also enforces (for historical reasons) the use of "
"``text`` columns, that are superseeded in more recent versions (from 2005 "
"onwards) by ``varchar(max)``. ``mssql3://`` and ``mssql4://`` should be "
"used if you don’t want to face some limitations of the - officially "
"deprecated - ``text`` columns."
msgstr ""
"não MSSQL <2012 não suporta o SQL OFFSET palavra-chave. Portanto, o banco "
"de dados não pode fazer a paginação. Ao fazer um `` limitby = (a, b) `` "
"py4web vai buscar a primeira `` a + b`` linhas e descartar o primeiro `` "
"a``. Isto pode resultar numa sobrecarga considerável quando comparado com "
"outros bancos de dados. Se você estiver usando MSSQL> = 2005, o prefixo "
"recomendado para uso é `` mssql3: // `` que fornece um método para evitar o "
"problema de buscar todo o conjunto de resultados não-paginado. Se você "
"estiver em MSSQL> = 2012, use `` mssql4: // `` que usa o `` OFFSET ... "
"ROWS ... FETCH PRÓXIMO ... ROWS ONLY`` construção para apoiar a paginação "
"nativamente, sem sucessos de desempenho como outros backends. O `` "
"mssql: // `` uri também reforça (por razões históricas) o uso de `` colunas "
"text``, que são superseeded em versões mais recentes (a partir de 2005) por "
"`` varchar (max) ``. `` Mssql3: // `` e `` mssql4: // `` deve ser usado se "
"você não quer enfrentar algumas limitações do - oficialmente obsoleto - `` "
"colunas text``."

#: ../../chapter-07.rst:5000
msgid ""
"MSSQL has problems with circular references in tables that have ONDELETE "
"CASCADE. This is an MSSQL bug and you work around it by setting the "
"ondelete attribute for all reference fields to “NO ACTION”. You can also do "
"it once and for all before you define tables:"
msgstr ""
"MSSQL tem problemas com referências circulares em tabelas que têm onDelete "
"CASCADE. Este é um bug MSSQL e você trabalhar em torno dele, definindo o "
"atributo onDelete para todos os campos de referência a “nenhuma acção”. "
"Você também pode fazê-lo uma vez por todas, antes de definir tabelas:"

#: ../../chapter-07.rst:5012
msgid ""
"MSSQL also has problems with arguments passed to the DISTINCT keyword and "
"therefore while this works,"
msgstr ""
"MSSQL também tem problemas com argumentos passados ​​para a palavra-chave "
"DISTINCT e, portanto Enquanto isso funciona,"

#: ../../chapter-07.rst:5019
msgid "this does not"
msgstr "isso não faz"

#: ../../chapter-07.rst:5028
msgid ""
"Oracle also does not support pagination. It does not support neither the "
"OFFSET nor the LIMIT keywords. PY4WEB achieves pagination by translating a "
"``db(...).select(limitby=(a, b))`` into a complex three-way nested select "
"(as suggested by official Oracle documentation). This works for simple "
"select but may break for complex selects involving aliased fields and or "
"joins."
msgstr ""
"A Oracle também não suporta a paginação. Ele não suporta nem a OFFSET nem "
"as palavras-chave limite. PY4WEB alcança a paginação, traduzindo um `` db "
"(...). Select (limitby = (a, b)) `` em um complexo de três vias SELECT "
"aninhada (como sugerido por documentação oficial Oracle). Isso funciona "
"para simples escolha, mas pode quebrar para seleciona complexos envolvendo "
"campos e ou junta alias."

#: ../../chapter-07.rst:5036
msgid "Google NoSQL (Datastore)"
msgstr "Google NoSQL (Datastore)"

#: ../../chapter-07.rst:5038
msgid ""
"Google NoSQL (Datastore) does not allow joins, left joins, aggregates, "
"expression, OR involving more than one table, the ‘like’ operator searches "
"in “text” fields."
msgstr ""
"Google NoSQL (Datastore) não permite que se junta, deixou junta, agregados, "
"expressão ou envolvendo mais de uma tabela, o ‘como’ pesquisas operador em "
"campos “texto”."

#: ../../chapter-07.rst:5042
msgid ""
"Transactions are limited and not provided automatically by py4web (you need "
"to use the Google API ``run_in_transaction`` which you can look up in the "
"Google App Engine documentation online)."
msgstr ""
"As transações são limitados e não fornecida automaticamente pelo py4web "
"(você precisa usar a API do Google `` run_in_transaction`` que você pode "
"procurar na documentação do Google App Engine online)."

#: ../../chapter-07.rst:5046
msgid ""
"Google also limits the number of records you can retrieve in each one query "
"(1000 at the time of writing). On the Google datastore record IDs are "
"integer but they are not sequential. While on SQL the “list:string” type is "
"mapped into a “text” type, on the Google Datastore it is mapped into a "
"``ListStringProperty``. Similarly “list:integer” and “list:reference” are "
"mapped into ``ListProperty``. This makes searches for content inside these "
"fields types more efficient on Google NoSQL than on SQL databases."
msgstr ""
"O Google também limita o número de registros que você pode recuperar em "
"cada uma consulta (1000, no momento da escrita). No Google armazenamento de "
"dados IDs de registro são inteiro, mas eles não são seqüenciais. Enquanto "
"em SQL “lista: string” tipo é mapeado em um tipo de “texto”, no Google "
"Datastore é mapeado em um `` ListStringProperty``. Da mesma forma “lista: "
"número inteiro” e “lista: referência” são mapeados para `` ListProperty``. "
"Isso faz buscas por conteúdo dentro desses campos tipos mais eficientes no "
"Google NoSQL que em bancos de dados SQL."
