# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, BSDv3 License
# This file is distributed under the same license as the py4web package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: py4web 20251209\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-12-18 20:03+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../chapter-13.rst:3
msgid "Authentication and authorization"
msgstr ""

#: ../../chapter-13.rst:5
msgid "Strong authentication and authorization methods are vital for a modern, multiuser web application. While they are often used interchangeably, authentication and authorization are separate processes:"
msgstr ""

#: ../../chapter-13.rst:10
msgid "Authentication confirms that users are who they say they are"
msgstr ""

#: ../../chapter-13.rst:11
msgid "Authorization gives those users permission to access a resource"
msgstr ""

#: ../../chapter-13.rst:15
msgid "Authentication using Auth"
msgstr ""

#: ../../chapter-13.rst:17
msgid "py4web comes with a an object ``Auth`` and a system of plugins for user authentication. It has the same name as the corresponding web2py one and serves the same purpose but the API and internal design is very different."
msgstr ""

#: ../../chapter-13.rst:22
msgid "The _scaffold application provides a guideline for its standard usage. By default it uses a local SQLite database and allows creating new users, login and logout. Notice that if you don't configure it, you have to manually approve new users (by visiting the link logged on the console or by directly editing the database)."
msgstr ""

#: ../../chapter-13.rst:29
msgid "To use the Auth object, first of all you need to import it, instantiate it, configure it, and enable it."
msgstr ""

#: ../../chapter-13.rst:39
msgid "The import step is obvious. The second step does not perform any operation other than telling the Auth object which session object to use and which database to use. Auth data is stored in ``session['user']`` and, if a user is logged in, the user id is stored in session[‘user’][‘id’]. The db object is used to store persistent info about the user in a table ``auth_user`` which is created if missing. The ``auth_user`` table has the following fields:"
msgstr ""

#: ../../chapter-13.rst:47
msgid "username"
msgstr ""

#: ../../chapter-13.rst:48
msgid "email"
msgstr ""

#: ../../chapter-13.rst:49
msgid "password"
msgstr ""

#: ../../chapter-13.rst:50
msgid "first_name"
msgstr ""

#: ../../chapter-13.rst:51
msgid "last_name"
msgstr ""

#: ../../chapter-13.rst:52
msgid "sso_id (used for single sign on, see later)"
msgstr ""

#: ../../chapter-13.rst:53
msgid "action_token (used to verify email, block users, and other tasks, also see later)."
msgstr ""

#: ../../chapter-13.rst:56
msgid "The ``auth.enable()`` step creates and exposes the following RESTful APIs:"
msgstr ""

#: ../../chapter-13.rst:59
msgid "{appname}/auth/api/register (POST)"
msgstr ""

#: ../../chapter-13.rst:60
msgid "{appname}/auth/api/login (POST)"
msgstr ""

#: ../../chapter-13.rst:61
msgid "{appname}/auth/api/request_reset_password (POST)"
msgstr ""

#: ../../chapter-13.rst:62
msgid "{appname}/auth/api/reset_password (POST)"
msgstr ""

#: ../../chapter-13.rst:63
msgid "{appname}/auth/api/verify_email (GET, POST)"
msgstr ""

#: ../../chapter-13.rst:64
msgid "{appname}/auth/api/logout (GET, POST) (+)"
msgstr ""

#: ../../chapter-13.rst:65
msgid "{appname}/auth/api/profile (GET, POST) (+)"
msgstr ""

#: ../../chapter-13.rst:66
msgid "{appname}/auth/api/change_password (POST) (+)"
msgstr ""

#: ../../chapter-13.rst:67
msgid "{appname}/auth/api/change_email (POST) (+)"
msgstr ""

#: ../../chapter-13.rst:69
msgid "Those marked with a (+) require a logged in user."
msgstr ""

#: ../../chapter-13.rst:72
msgid "Auth UI"
msgstr ""

#: ../../chapter-13.rst:74
msgid "You can create your own web UI to login users using the above APIs but py4web provides one as an example, implemented in the following files:"
msgstr ""

#: ../../chapter-13.rst:77
msgid "\\_scaffold/templates/auth.html"
msgstr ""

#: ../../chapter-13.rst:78
msgid "\\_scaffold/templates/layout.html"
msgstr ""

#: ../../chapter-13.rst:81
msgid "The key section is in ``layout.html`` where (using the no.css framework) the menu actions are defined:"
msgstr ""

#: ../../chapter-13.rst:112
msgid "The menu is dynamic: on line 2 there is a check if the user is already defined (i.e. if the user has already logged on). In this case the email is shown in the top menu, plus the menu options ``Edit Profile``, ``Change Password`` (optional) and ``Logout``. Instead, if the user is not already logged on, from line 15 there are only the corresponding menu options allowed: ``Sign up`` and ``Log in``."
msgstr ""

#: ../../chapter-13.rst:119
msgid "Every menu option then redirects the user to the corresponding standard URL, which in turn activates the Auth action."
msgstr ""

#: ../../chapter-13.rst:124
msgid "Using Auth inside actions"
msgstr ""

#: ../../chapter-13.rst:126
msgid "There two ways to use the Auth object in an action."
msgstr ""

#: ../../chapter-13.rst:128
msgid "The first one does not force a login.  With ``@action.uses(auth)`` we tell py4web that this action should have information about the user, trying to parse the session for a user session."
msgstr ""

#: ../../chapter-13.rst:140
msgid "The second one forces the login if needed:"
msgstr ""

#: ../../chapter-13.rst:150
msgid "Here ``@action.uses(auth.user)`` tells py4web that this action requires a logged in user and should redirect to login if no user is logged in."
msgstr ""

#: ../../chapter-13.rst:154
msgid "Two Factor Authentication"
msgstr ""

#: ../../chapter-13.rst:156
msgid "Two factor authentication (or Two-step verification) is a way of improving authentication security. When activated an extra step is added in the login process. In the first step, users are shown the standard username/password form. If they successfully pass this challenge by submitting the correct username and password, and two factor authentication is enabled for the user, the server will present a second form before logging them in."
msgstr ""

#: ../../chapter-13.rst:162
msgid "There are a few Auth settings available to control how two factor authentication works."
msgstr ""

#: ../../chapter-13.rst:164
msgid "The following can be specified on Auth instantiation:"
msgstr ""

#: ../../chapter-13.rst:166
msgid "``two_factor_required``"
msgstr ""

#: ../../chapter-13.rst:167
msgid "``two_factor_send``"
msgstr ""

#: ../../chapter-13.rst:168
msgid "``two_factor_validate``"
msgstr ""

#: ../../chapter-13.rst:171
msgid "two_factor_required"
msgstr ""

#: ../../chapter-13.rst:173
msgid "When you pass a method name to the ``two_factor_required`` parameter you are telling py4web to call that method to determine whether or not this login should be use or bypass two factor authentication. If your method returns True, then this login requires two factor.  If it returns False, two factor authentication is bypassed for this login."
msgstr ""

#: ../../chapter-13.rst:178
msgid "Sample ``two_factor_required`` method"
msgstr ""

#: ../../chapter-13.rst:180
msgid "This example shows how to allow users that are on a specific network."
msgstr ""

#: ../../chapter-13.rst:200
msgid "two_factor_send"
msgstr ""

#: ../../chapter-13.rst:202
msgid "When two factor authentication is active, py4web can generate a 6 digit code (using random.randint) and makes it possible to send it to the user. How this code is sent, is up to you. The ``two_factor_send`` argument to the Auth class allows you to specify the method that sends the two factor code to the user."
msgstr ""

#: ../../chapter-13.rst:206
msgid "This example shows how to send an email with the two factor code:"
msgstr ""

#: ../../chapter-13.rst:222
msgid "Notice that this method takes two arguments: the current user, and the code to be sent. Also notice this method can override the code and return a new one."
msgstr ""

#: ../../chapter-13.rst:231
msgid "two_factor_validate"
msgstr ""

#: ../../chapter-13.rst:233
msgid "By default, py4web will validate the user input in the two factor form by comparing the code entered by the user with the code generated and sent using ``two_factor_send``. However, sometimes it may be useful to define a custom validation of this user-entered code. For instance, if one would like to use the TOTP (or the Time-Based One-Time-Passwords) as the two factor authentication method, the validation requires comparing the code entered by the user with the value generated at the same time at the server side. Hence, it is not sufficient to generate that value earlier when showing the form (using for instance ``two_factor_send`` method), because by the time the user submits the form, the current valid value may already be different. Instead, this value should be generated when validating the form submitted by the user."
msgstr ""

#: ../../chapter-13.rst:243
msgid "To accomplish such custom validation, the ``two_factor_validate`` method is available. It takes two arguments:"
msgstr ""

#: ../../chapter-13.rst:245
msgid "the current user"
msgstr ""

#: ../../chapter-13.rst:246
msgid "the code that was entered by the user into the two factor authentication form"
msgstr ""

#: ../../chapter-13.rst:248
msgid "The primary use-case for this method is validation of time-based passwords."
msgstr ""

#: ../../chapter-13.rst:250
msgid "This example shows how to validate a time-based two factor code:"
msgstr ""

#: ../../chapter-13.rst:268
msgid "The ``validate_code`` method must return one of three values:"
msgstr ""

#: ../../chapter-13.rst:270
msgid "``True`` - if the validation succeeded,"
msgstr ""

#: ../../chapter-13.rst:271
msgid "``False`` - if the validation failed,"
msgstr ""

#: ../../chapter-13.rst:272
msgid "``None`` - if the validation was not possible for any reason"
msgstr ""

#: ../../chapter-13.rst:274
msgid "Notice that - if defined - this method is _always_ called to validate the two factor authentication form. It is up to you to decide what kind of validation it does. If the returned value is ``True``, the user input will be accepted as valid. If the returned value is ``False`` then the user input will be rejected as invalid, number of tries will be decreased by one, and user will be asked to try again. If the returned value is ``None`` the user input will be checked against the code generated with the use of ``two_factor_send`` method and the final result will depend on that comparison. In this case authentication will fail if ``two_factor_send`` method was not defined, and hence no code was sent to the user."
msgstr ""

#: ../../chapter-13.rst:287
msgid "two_factor_tries"
msgstr ""

#: ../../chapter-13.rst:289
msgid "By default, the user has 3 attempts to pass two factor authentication. You can override this after using:"
msgstr ""

#: ../../chapter-13.rst:295
msgid "Once this is all setup, the flow for two factor authentication is:"
msgstr ""

#: ../../chapter-13.rst:297
msgid "present the login page"
msgstr ""

#: ../../chapter-13.rst:298
msgid "upon successful login and user passes two_factor_required"
msgstr ""

#: ../../chapter-13.rst:299
msgid "redirect to py4web auth/two_factor endpoint"
msgstr ""

#: ../../chapter-13.rst:300
msgid "if ``two_factor_send`` method has been defined:"
msgstr ""

#: ../../chapter-13.rst:301
msgid "generate 6 digit verification code"
msgstr ""

#: ../../chapter-13.rst:302
msgid "call ``two_factor_send`` to send the verification code to the user"
msgstr ""

#: ../../chapter-13.rst:303
msgid "display verification page where user can enter their code"
msgstr ""

#: ../../chapter-13.rst:304
msgid "if ``two_factor_validate`` method has been defined - call it to validate the user-entered code"
msgstr ""

#: ../../chapter-13.rst:305
msgid "upon successful verification, take user to _next_url that was passed to the login page"
msgstr ""

#: ../../chapter-13.rst:307
msgid "Important! If you filtered ``ALLOWED_ACTIONS`` in your app, make sure to whitelist the \"two_factor\" action so not to block the two factor API."
msgstr ""

#: ../../chapter-13.rst:312
msgid "Auth Plugins"
msgstr ""

#: ../../chapter-13.rst:314
msgid "Plugins are defined in “py4web/utils/auth_plugins” and they have a hierarchical structure. Some are exclusive and some are not. For example, default, LDAP, PAM, and SAML are exclusive (the developer has to pick one). Default, Google, Facebook, and Twitter OAuth are not exclusive (the developer can pick them all and the user gets to choose using the UI)."
msgstr ""

#: ../../chapter-13.rst:321
msgid "The ``<auth/>`` components will automatically adapt to display login forms as required by the installed plugins."
msgstr ""

#: ../../chapter-13.rst:324
msgid "In the _scaffold/settings.py and _scaffold/common.py files you can see the default settings for the supported plugins."
msgstr ""

#: ../../chapter-13.rst:328
msgid "PAM"
msgstr ""

#: ../../chapter-13.rst:330
msgid "Configuring PAM is the easiest:"
msgstr ""

#: ../../chapter-13.rst:337
msgid "This one like all plugins must be imported and registered. The constructor of this plugins does not require any arguments (where other plugins do)."
msgstr ""

#: ../../chapter-13.rst:341
msgid "The ``auth.register_plugin(...)`` **must** come before the ``auth.enable()`` since it makes no sense to expose APIs before desired plugins are mounted."
msgstr ""

#: ../../chapter-13.rst:347
msgid "by design PAM authentication using local users works fine only if py4web is run by root. Otherwise you can only authenticate the specific user that runs the py4web process."
msgstr ""

#: ../../chapter-13.rst:352
msgid "LDAP"
msgstr ""

#: ../../chapter-13.rst:354
msgid "This is a common authentication method, especially using Microsoft Active Directory in enterprises."
msgstr ""

#: ../../chapter-13.rst:368
msgid "it needs the python-ldap module. On Ubuntu, you should also install some developer's libraries in advance with ``sudo apt-get install libldap2-dev libsasl2-dev``."
msgstr ""

#: ../../chapter-13.rst:373
msgid "OAuth2 with Google"
msgstr ""

#: ../../chapter-13.rst:383
msgid "The client id and client secret must be provided by Google."
msgstr ""

#: ../../chapter-13.rst:385
msgid "By default, Google OAuth stores the user's first name, last name, and email in the auth_user table—but not the profile picture. You can include the profile picture URL with just few lines of code added to common.py."
msgstr ""

#: ../../chapter-13.rst:399
msgid "Once the profile picture URL is stored in auth_user, you can easily use it along with other user information."
msgstr ""

#: ../../chapter-13.rst:403
msgid "OAuth2 with Facebook"
msgstr ""

#: ../../chapter-13.rst:413
msgid "The client id and client secret must be provided by Facebook."
msgstr ""

#: ../../chapter-13.rst:416
msgid "OAuth2 with Discord"
msgstr ""

#: ../../chapter-13.rst:426
msgid "To obtain a Discord client ID and secret, create an application at https://discord.com/developers/applications. You will also have to register your OAuth2 redirect URI in your created application, in the form of ``http(s)://<your host>/<your app name>/auth/plugin/oauth2discord/callback``"
msgstr ""

#: ../../chapter-13.rst:431
msgid "As Discord users have no concept of first/last name, the user in the auth table will contain the Discord username as the first name and discriminator as the last name."
msgstr ""

#: ../../chapter-13.rst:435
msgid "Auth API Plugins"
msgstr ""

#: ../../chapter-13.rst:437
msgid "There are two types of web APIs, those called by the browser for example by a single page web app, and those designed to be called by a different kind of program. Both of them may need tosupport authentication. The distintion is important because, in the case of the browser, there is no need to manage any authentication token as the browser already provides cookies and py4web uses cookies to handle seesions. If the user operating the browser is logged-in, when an API is called, the corresponding action already knows who the user is. No additional logic is necessary. In this case there there is no need for any kind of additional API token which would only diminuish the security provided by the cookie based session token."
msgstr ""

#: ../../chapter-13.rst:446
msgid "When the API is to be accessed by a different program (for example a script) the story is different. There is no session and we do not want to ask the user for the password every time. The standard way to authenticate in this case is by issuing the user an API token, aka a string, which, when presented along with API request allows py4web to recognize the identity of the caller. This is also referred to as \"Authentication bearer\"."
msgstr ""

#: ../../chapter-13.rst:452
msgid "Py4web provides a plugin system that gives you a lot of flexibility but it also provides two practical plugins that are sufficient in most cases. The two plugins are called: SimpleTokenPlugin and JwtTokenPlugin. The first one of the two is recommended in most of the cases."
msgstr ""

#: ../../chapter-13.rst:456
msgid "What all plugins have in common:"
msgstr ""

#: ../../chapter-13.rst:458
msgid "They have a way for a user to create a token which is a string."
msgstr ""

#: ../../chapter-13.rst:459
msgid "When an HTTP(S) request is made to an action that @actiion.uses(auth) or @action.uses(auth.user) py4web will identify the user if the token is present, as if the user was logged-in."
msgstr ""

#: ../../chapter-13.rst:462
msgid "What SimpleTokenPlugin and JwtTokenPlugin have in common:"
msgstr ""

#: ../../chapter-13.rst:464
msgid "When an HTTP(S) request is made, the token must be put in the \"Authentication\" header. You will need to create your own plugin if you want to pass it in some other manner."
msgstr ""

#: ../../chapter-13.rst:466
msgid "Each user can create as many tokens as desired."
msgstr ""

#: ../../chapter-13.rst:467
msgid "Users can create tokens for other users if the application logic requires/allows it."
msgstr ""

#: ../../chapter-13.rst:469
msgid "Unique features of SimpleTokenPlugin:"
msgstr ""

#: ../../chapter-13.rst:471
msgid "A token is a UUID."
msgstr ""

#: ../../chapter-13.rst:472
msgid "Tokens can be managed serverside (created, deleted, expired, change expiration)."
msgstr ""

#: ../../chapter-13.rst:473
msgid "Current tokens are stored in a adatabase table."
msgstr ""

#: ../../chapter-13.rst:474
msgid "The default table associates token with the owner and a textual description. Users can nevertheless provide their own table and add any desired metadata to tokens which the app can retrieve to distinguish different tokens from the same user. This is done by adding fields to the table."
msgstr ""

#: ../../chapter-13.rst:478
msgid "Under the hood veryfing a token requires a database query."
msgstr ""

#: ../../chapter-13.rst:480
msgid "Unique features of JwtTokenPlugin:"
msgstr ""

#: ../../chapter-13.rst:482
msgid "The token is an encrypted and digitally signed dict that stores the user_id and expiration."
msgstr ""

#: ../../chapter-13.rst:483
msgid "The author of the token can add any metadata to into the token at creation."
msgstr ""

#: ../../chapter-13.rst:484
msgid "The token is not stored anywhere serverside and there is no database table."
msgstr ""

#: ../../chapter-13.rst:485
msgid "Tokens can be created (and there is a function to do so) but they cannot be managed. The server cannot expire tokens or change expiration. This would require the tokens to validated against a database and that is exactely when the JwtTokenPlugin tries to avoid."
msgstr ""

#: ../../chapter-13.rst:488
msgid "The only way to expire a token is by changing the serverside secret using for validation so when a token is expired, all tokens are expired."
msgstr ""

#: ../../chapter-13.rst:491
msgid "SimpleTokenPlugin are the recommended kind of tokens for most applications. JwtTokenPlugin are valuable when the expiration is short and known in advance and when avoiding a database lookup is very important, such as for actions that are very fast and one is willing to sacrifice a bit of security (serverside token expiration capability) in order to avoid database access."
msgstr ""

#: ../../chapter-13.rst:498
msgid "Example of SimpleTokenPlugin"
msgstr ""

#: ../../chapter-13.rst:500
#: ../../chapter-13.rst:540
msgid "In common.py:"
msgstr ""

#: ../../chapter-13.rst:508
msgid "You can optionally a ``table=db.mytable`` to a custom table. Otherwise it will create and use one called \"auth_simple_token\"."
msgstr ""

#: ../../chapter-13.rst:511
msgid "In controllers.py"
msgstr ""

#: ../../chapter-13.rst:520
msgid "Users can access this action if via a browser if they are logged in, without the token, of via API by providing a token."
msgstr ""

#: ../../chapter-13.rst:526
msgid "In order to create and manage tokens you can use a grid. In controllers.py"
msgstr ""

#: ../../chapter-13.rst:538
msgid "Example of JwtTokenPlugin"
msgstr ""

#: ../../chapter-13.rst:549
msgid "In controllers.py it works the same as SimpleTokenPlugin:"
msgstr ""

#: ../../chapter-13.rst:558
msgid "The token is also passed using the same header as in the previous example:"
msgstr ""

#: ../../chapter-13.rst:564
msgid "While you cannot manage tokens you still need a way to create them. You can create an action for example that, when called, gives you a new token. In controllers.py"
msgstr ""

#: ../../chapter-13.rst:577
msgid "Example of custom Token Plugin"
msgstr ""

#: ../../chapter-13.rst:579
msgid "A token plugin is just a class that, given a request, returns an associated user. For example here is a dumb and UNSAFE plugin that authorizes everybody as user 1 as long as the \"Authentication\" header is provided."
msgstr ""

#: ../../chapter-13.rst:583
msgid "from py4web import request"
msgstr ""

#: ../../chapter-13.rst:598
msgid "Authorization using Tags"
msgstr ""

#: ../../chapter-13.rst:600
msgid "As already mentioned, authorization is the process of verifying what specific applications, files, and data a user has access to. This is accomplished in py4web using ``Tags``, that we've already discovered on :ref:`Tagging records` in the DAL chapter."
msgstr ""

#: ../../chapter-13.rst:607
msgid "Tags and Permissions"
msgstr ""

#: ../../chapter-13.rst:609
msgid "Py4web provides a general purpose tagging mechanism that allows the developer to tag any record of any table, check for the existence of tags, as well as checking for records containing a tag. Group membership can be thought of a type of tag that we apply to users. Permissions can also be tags. Developers are free to create their own logic on top of the tagging system."
msgstr ""

#: ../../chapter-13.rst:618
msgid "Py4web does not have the concept of groups as web2py does. Experience showed that while that mechanism is powerful it suffers from two problems: it is overkill for most apps, and it is not flexible enough for very complex apps."
msgstr ""

#: ../../chapter-13.rst:623
msgid "To use the tagging system you first need to import the Tags module from ``pydal.tools``. Then create a Tags object to tag a table:"
msgstr ""

#: ../../chapter-13.rst:631
msgid "The tail_name parameter is optional and if not specified the 'default' value will be used. If you look at the database level, a new table will be created with a name equals to ``tagged_db + '_tag_' + tail_name``, in this case ``auth_user_tag_groups``:"
msgstr ""

#: ../../chapter-13.rst:639
msgid "Then you can add one or more tags to records of the table as well as remove existing tags:"
msgstr ""

#: ../../chapter-13.rst:648
msgid "On the ``auth_user_tagged_groups`` this will produce two records with different groups assigned to the same user.id (the \"Record ID\" field):"
msgstr ""

#: ../../chapter-13.rst:653
msgid "Slashes at the beginning or the end of a tag are optional. All other chars are allowed on equal footing."
msgstr ""

#: ../../chapter-13.rst:657
msgid "A common use case is **group based access control**. Here the developer first checks if a user is a member of the ``'manager'`` group, if the user is not a manager (or no one is logged in) py4web redirects to the ``'not authorized url'``. Else the user is in the correct group and then py4web displays ‘hello manager’:"
msgstr ""

#: ../../chapter-13.rst:672
msgid "Here the developer queries the db for all records having the desired tag(s):"
msgstr ""

#: ../../chapter-13.rst:683
msgid "We've already seen a simple ``requires_membership`` fixture on :ref:``The Condition fixture``. It enables the following syntax:"
msgstr ""

#: ../../chapter-13.rst:704
msgid "We leave it to you as an exercise to create a fixture ``has_membership`` to enable the following syntax:"
msgstr ""

#: ../../chapter-13.rst:714
msgid "**Important:** ``Tags`` are automatically hierarchical. For example, if a user has a group tag ‘teacher/high-school/physics’, then all the following searches will return the user:"
msgstr ""

#: ../../chapter-13.rst:718
msgid "``groups.find('teacher/high-school/physics')``"
msgstr ""

#: ../../chapter-13.rst:719
msgid "``groups.find('teacher/high-school')``"
msgstr ""

#: ../../chapter-13.rst:720
msgid "``groups.find('teacher')``"
msgstr ""

#: ../../chapter-13.rst:722
msgid "This means that slashes have a special meaning for tags."
msgstr ""

#: ../../chapter-13.rst:725
msgid "Multiple Tags objects"
msgstr ""

#: ../../chapter-13.rst:728
msgid "One table can have multiple associated ``Tags`` objects. The name 'groups' here is completely arbitrary but has a specific semantic meaning. Different ``Tags`` objects are independent to each other. The limit to their use is your creativity."
msgstr ""

#: ../../chapter-13.rst:733
msgid "For example you could create a table ``auth_group``:"
msgstr ""

#: ../../chapter-13.rst:739
msgid "and two Tags attached to it:"
msgstr ""

#: ../../chapter-13.rst:746
msgid "Then create a 'zapper' record in ``auth_group``, give it a permission, and make a user member of the group:"
msgstr ""

#: ../../chapter-13.rst:755
msgid "And you can check for a user permission via an explicit join:"
msgstr ""

#: ../../chapter-13.rst:772
msgid "Notice here ``permissions.find(permission)`` generates a query for all groups with the permission and we further filter those groups for those the current user is member of. We count them and if we find any, then the user has the permission."
msgstr ""

#: ../../chapter-13.rst:778
msgid "User Impersonation"
msgstr ""

#: ../../chapter-13.rst:780
msgid "Auth provides API that allow you to impersonate another user. Here is an example of an action to start impersonating and stop impersonating another user."
msgstr ""
