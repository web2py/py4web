# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, BSDv3 License
# This file is distributed under the same license as the py4web package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: py4web 20251209\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-12-18 20:03+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../chapter-15.rst:3
msgid "From web2py to py4web"
msgstr ""

#: ../../chapter-15.rst:5
msgid "This chapter is dedicated to help users for porting old web2py applications to py4web."
msgstr ""

#: ../../chapter-15.rst:7
msgid "Web2py and py4web share many similarities and some differences. For example they share the same database abstraction layer (pyDAL) which means pydal table definitions and queries are identical between the two frameworks. They also share the same template language with the minor caveat that web2py defaults to `{{...}}` delimiters while py4web defaults to `[[...]]` delimiters. They also share the same validators, part of pyDAL, and very similar helpers. The py4web ones are a lighter/faster/minimalist re-implementation but they serve the same purpose and support a very similar syntax. They both provide a `Form` object (equivalent to `SQLFORM` in web2py) and a `Grid` object (equivalent to `SQLFORM.grid` in web2py). They both provide a `XML` object that can sanitize HTML and `URL` helper to generate URL. They both can raise `HTTP` to return non-200 OK pages. They both provide an `Auth` object that can generate register/login/change password/lost password/edit profile forms. Both web2py and py4web track and log all errors."
msgstr ""

#: ../../chapter-15.rst:19
msgid "Some of the main differences are the following:"
msgstr ""

#: ../../chapter-15.rst:21
msgid "web2py works with both Python 2.6+ and 3.6+, while py4web runs on Python 3.7+ only. So, if your old web2py application is still using Python 2, your first step involves migrating it to at least Python 3.7, better if the latest 3.9."
msgstr ""

#: ../../chapter-15.rst:25
msgid "web2py apps consist of collection of files which are executed at every HTTP request (using a custom importer, in a predetermined order). In py4web apps are regular python modules that are imported automatically by the frameworks. By the way, this makes possible the use of standard python debuggers (even inside the most used IDEs)."
msgstr ""

#: ../../chapter-15.rst:30
msgid "In web2py every app has a fixed folder structure. A function is an action if and only if it is defined in a ``controllers/*.py`` file. py4web is much less constraining. In py4web an app must have an entry point ``__init__.py`` and a ``static`` folder. Every other convention such as the location of templates, uploaded files, translation files, sessions, etc. is user specified."
msgstr ""

#: ../../chapter-15.rst:35
msgid "In web2py the scaffolding app (the blue print for creating new apps) is called “welcome”. In py4web it is called “_scaffold”. _scaffold contains a “settings.py” file and a “common.py”. The latter provides an example of how to enable Auth and configure all the options for the specific app. _scaffold has also a “model.py” file and a “controller.py” file but, unlike web2py, those files are not treated in any special manner. Their names follow a convention (not enforced by the framework) and they are imported by the `__init__.py` file as for any regular python module."
msgstr ""

#: ../../chapter-15.rst:43
msgid "In web2py every function in ``controllers/*.py`` is an action. In py4web a function is an action if it has the ``@action(\"...\")`` decorator. That means that actions can be defined anywhere. The admin interface will help you locate where a particular action is defined."
msgstr ""

#: ../../chapter-15.rst:47
msgid "In web2py the mapping between URLs and file/function names is automatic but it can be overwritten in “routes.py” (like in Django). In py4web the mapping is specified in the decorator as in `@action('my_url_path')` (like in Bottle and Flask). Notice that if the path starts with “/” it is assumed to be an absolute path. If not, it is assumed to be relative and prepended by the “/{appname}/” prefix. Also, if the path ends with “/index”, the latter postfix is assumed to be optional."
msgstr ""

#: ../../chapter-15.rst:54
msgid "In web2py the path extension matters and “http://*.html” is expected to return HTML while “http://*.json” is expected to return JSON, etc. In py4web there is no such convention. If the action returns a dict() and has a template, the dict() will be rendered by the template, else it will be rendered in JSON. More complex behavior can be accomplished using decorators."
msgstr ""

#: ../../chapter-15.rst:59
msgid "In web2py there are many wrappers around each action and, for example, they could handle sessions, pluralization, database connections, and more whether the action needs it or not. This makes web2py performances hard to compare with other frameworks. In py4web everything is optional and features must be enabled and configured for each action using the ``@action.uses(...)`` decorator. The arguments of ``@action.uses(...)`` are called fixtures in analogy with the fixtures in a house. They add functionality by providing preprocessing and postprocessing to the action. For example ``@action.uses(session, T, db, flash)`` indicates that the action needs to use session, internationalization/pluralization (T), the database (db), and carry on state for flash messages upon redirection."
msgstr ""

#: ../../chapter-15.rst:69
msgid "web2py uses its own request/response objects. py4web uses the request/response objects from the underlying Ombott library. While this may change in the future we are committed to keep them the interface with the web server, routing, partial requests, if modified since, and file streaming."
msgstr ""

#: ../../chapter-15.rst:74
msgid "Both web2py and py4web use the same pyDAL therefore tables are defined using the same exact syntax, and so do queries. In web2py tables are re-defined at every HTTP request, when the entire models are executed. In py4web only the action is executed for every HTTP request, while the code defined outside of actions is only executed at startup. That makes py4web much faster, in particular when there are many tables. The downside of this approach is that the developer should be careful to never override pyDAL variables inside action or in any way that depends on the content of the request object, else the code is not thread safe. The only variables that can be changed at will are the following field attributes: readable, writable, requires, update, default. All the others are for practical purposes to be considered global and non thread safe. This is also the reason that makes using :ref:`Lazy Tables` with py4web useless and even dangerous."
msgstr ""

#: ../../chapter-15.rst:86
msgid "Both web2py and pyweb have an Auth object which serve the same purpose. Both objects have the ability to generate forms pretty much in the same manner. The py4web ones is defined to be more modular and extensible and support both Forms and APIs, but it lacks the `auth.requires_*` decorators and group membership/permissions. This does not mean that the feature is not available. In fact py4web is even more powerful and that is why the syntax is different. While the web2py Auth objects tries to do everything, the corresponding py4web object is only in charge of establishing the identity of a user, not what the user can do. The latter can be achieved by attaching Tags to users. So group membership is assigned by labeling users with the Tags of the groups they belong to and checking permissions based on the user tags. Py4web provides a mechanism for assigning and checking tags efficiently to any object, including but not limited to, users."
msgstr ""

#: ../../chapter-15.rst:98
msgid "Web2py comes with the Rocket web server. py4web at the time of writing defaults to the `Rocket3 <https://github.com/web2py/rocket3>`__  web server, which is the same multi-threaded web server used by web2py stripped of all the Python2 logic and dependencies. Note that this may change in the future."
msgstr ""

#: ../../chapter-15.rst:105
msgid "Simple conversion examples"
msgstr ""

#: ../../chapter-15.rst:108
msgid "“Hello world” example"
msgstr ""

#: ../../chapter-15.rst:110
#: ../../chapter-15.rst:131
#: ../../chapter-15.rst:156
#: ../../chapter-15.rst:176
#: ../../chapter-15.rst:196
#: ../../chapter-15.rst:222
#: ../../chapter-15.rst:241
#: ../../chapter-15.rst:266
#: ../../chapter-15.rst:316
#: ../../chapter-15.rst:341
#: ../../chapter-15.rst:359
msgid "**web2py**"
msgstr ""

#: ../../chapter-15.rst:118
#: ../../chapter-15.rst:142
#: ../../chapter-15.rst:164
#: ../../chapter-15.rst:185
#: ../../chapter-15.rst:207
#: ../../chapter-15.rst:230
#: ../../chapter-15.rst:252
#: ../../chapter-15.rst:280
#: ../../chapter-15.rst:325
#: ../../chapter-15.rst:348
#: ../../chapter-15.rst:377
msgid "--> **py4web**"
msgstr ""

#: ../../chapter-15.rst:129
msgid "“Redirect with variables” example"
msgstr ""

#: ../../chapter-15.rst:154
msgid "“Returning variables” example"
msgstr ""

#: ../../chapter-15.rst:174
msgid "“Returning args” example"
msgstr ""

#: ../../chapter-15.rst:194
msgid "“Return calling methods” example"
msgstr ""

#: ../../chapter-15.rst:220
msgid "“Setting up a counter” example"
msgstr ""

#: ../../chapter-15.rst:239
msgid "“View” example"
msgstr ""

#: ../../chapter-15.rst:264
msgid "“Form and flash” example"
msgstr ""

#: ../../chapter-15.rst:295
msgid "In the template you can access the flash object with"
msgstr ""

#: ../../chapter-15.rst:301
msgid "or using the more sophisticated"
msgstr ""

#: ../../chapter-15.rst:307
msgid "The latter requires ``utils.js`` from the scaffolding app to render the custom tag into a div with dismissal behavior."
msgstr ""

#: ../../chapter-15.rst:310
msgid "Also notice that ``Flash`` is special: it is a singleton. So if you instantiate multiple Flash objects they share their data."
msgstr ""

#: ../../chapter-15.rst:314
msgid "“grid” example"
msgstr ""

#: ../../chapter-15.rst:339
msgid "“Accessing OS files” example"
msgstr ""

#: ../../chapter-15.rst:357
msgid "“auth” example"
msgstr ""

#: ../../chapter-15.rst:375
msgid "Access with ``http://.../user/login``."
msgstr ""

#: ../../chapter-15.rst:393
msgid "Access with ``http://.../auth/login``. Notice that in web2py ``auth.user`` is the current logged-in user retrieved from session. In py4web instead ``auth.user`` is a fixture which serves the same purpose as ``@requires_login`` in web2py. In py4web only the ``user_id`` is stored in the session and it can be retrieved using ``auth.user_id``. If you need more information about the user, you need to fetch the record from the database with ``auth.get_user()`` The latter returns all readable fields as a Python dictionary."
msgstr ""

#: ../../chapter-15.rst:402
msgid "Also notice there is a big difference between:"
msgstr ""

#: ../../chapter-15.rst:408
msgid "and"
msgstr ""

#: ../../chapter-15.rst:414
msgid "In the first case the decorated action can access the auth object but ``auth.user_id`` may be None if the user is not logged in. In the second case we are requiring a valid logged in user and therefore ``auth.user_id`` is guaranteed to be a valid user id."
msgstr ""

#: ../../chapter-15.rst:419
msgid "Also notice that if an action uses auth, then it automatically uses its session and its flash objects."
msgstr ""
