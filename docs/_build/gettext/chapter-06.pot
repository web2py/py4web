# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, BSDv3 License
# This file is distributed under the same license as the py4web package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: py4web 20251209\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-12-18 20:25+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../chapter-06.rst:3
msgid "Fixtures"
msgstr ""

#: ../../chapter-06.rst:5
msgid "A fixture is defined as “a piece of equipment or furniture which is fixed in position in a building or vehicle”. In our case a fixture is something attached to the action that processes an HTTP request in order to produce a response."
msgstr ""

#: ../../chapter-06.rst:10
msgid "When processing any HTTP requests there are some optional operations we may want to perform. For example parse the cookie to look for session information, commit a database transaction, determine the preferred language from the HTTP header and lookup proper internationalization, etc. These operations are optional. Some actions need them and some actions do not. They may also depend on each other. For example, if sessions are stored in the database and our action needs it, we may need to parse the session cookie from the HTTP header, pick up a connection from the database connection pool, and - after the action has been executed - save the session back in the database if data has changed."
msgstr ""

#: ../../chapter-06.rst:21
msgid "PY4WEB fixtures provide a mechanism to specify what an action needs so that py4web can accomplish the required tasks (and skip non required ones) in the most efficient manner. Fixtures make the code efficient and reduce the need for boilerplate code. Think of fixtures as per action (as opposed to per app) middleware."
msgstr ""

#: ../../chapter-06.rst:27
msgid "PY4WEB fixtures are similar to WSGI middleware and BottlePy plugin except that they apply to individual actions, not to all of them, and can depend on each other."
msgstr ""

#: ../../chapter-06.rst:31
msgid "PY4WEB comes with some pre-defined fixtures: sessions, url signing and flash messages will be fully explained in this chapter. Database connections, internationalization, authentication, and templates will instead be just outlined here since they have dedicated chapters."
msgstr ""

#: ../../chapter-06.rst:37
msgid "The developer is also free to add fixtures, for example, to handle a third party template language or third party session logic; this is explained later in the :ref:`Custom fixtures` paragraph."
msgstr ""

#: ../../chapter-06.rst:42
msgid "Using Fixtures"
msgstr ""

#: ../../chapter-06.rst:44
msgid "As we've seen in the previous chapter, fixtures are the arguments of the decorator ``@action.uses(...)``. You can specify multiple fixtures in one decorator or you can have multiple decorators."
msgstr ""

#: ../../chapter-06.rst:48
msgid "Also, fixtures can be applied in groups. For example:"
msgstr ""

#: ../../chapter-06.rst:54
msgid "Then you can apply all of them at once with:"
msgstr ""

#: ../../chapter-06.rst:63
msgid "Usually, it's not important the order you use to specify the fixtures, because py4web knows well how to manage them if they have explicit dependencies. For example auth depends explicitly on db and session and flash, so you do not even needs to list them."
msgstr ""

#: ../../chapter-06.rst:67
msgid "But there is an important exception: the Template fixture must always be the **first one**. Otherwise, it will not have access to various things it should need from the other fixtures, especially Inject() and Flash() that we'll see later."
msgstr ""

#: ../../chapter-06.rst:73
msgid "The Template fixture"
msgstr ""

#: ../../chapter-06.rst:75
msgid "PY4WEB by default uses the YATL template language and provides a fixture for it."
msgstr ""

#: ../../chapter-06.rst:88
msgid "Note: this example assumes that you created the application from the scaffolding app, so that the template index.html is already created for you."
msgstr ""

#: ../../chapter-06.rst:92
msgid "The Template object is a Fixture. It transforms the ``dict()`` returned by the action into a string by using the ``index.html`` template file. In a later chapter we will provide an example of how to define a custom fixture to use a different template language, for example Jinja2."
msgstr ""

#: ../../chapter-06.rst:97
msgid "Notice that since the use of templates is very common and since, most likely, every action uses a different template, we provide some syntactic sugar, and the two following lines are equivalent:"
msgstr ""

#: ../../chapter-06.rst:107
msgid "Also notice that py4web template files are cached in RAM. The py4web caching object is described later on :ref:`Caching and Memoize`."
msgstr ""

#: ../../chapter-06.rst:111
msgid "If you use multiple fixtures, always place the template as the **first one**."
msgstr ""

#: ../../chapter-06.rst:114
msgid "For example:"
msgstr ""

#: ../../chapter-06.rst:122
msgid "Be careful if you read old documentations that this need was **exactly the opposite** in early py4web experimental versions (until February 2022)!"
msgstr ""

#: ../../chapter-06.rst:126
msgid "As we've already seen in the last paragraph, you can combine many fixtures in one decorator. But you can even extend this decorator by passing different templates as needed. For example:"
msgstr ""

#: ../../chapter-06.rst:136
msgid "And then:"
msgstr ""

#: ../../chapter-06.rst:146
msgid "This syntax has no performance implications: it's just for avoiding to replicate a decorator logic in multiple places. In this way you'll have cleaner code and if needed you'll be able to change it later in one place only."
msgstr ""

#: ../../chapter-06.rst:151
msgid "The Inject fixture"
msgstr ""

#: ../../chapter-06.rst:153
msgid "The Inject fixture is used for passing variables (and even python functions) to templates. Here is a simple example:"
msgstr ""

#: ../../chapter-06.rst:169
msgid "It will be explained later on :ref:`Using Inject` in the YATL chapter."
msgstr ""

#: ../../chapter-06.rst:173
msgid "The Translator fixture"
msgstr ""

#: ../../chapter-06.rst:175
msgid "Here is an example of usage:"
msgstr ""

#: ../../chapter-06.rst:189
msgid "The string ``hello world`` will be translated based on the internationalization file in the specified “translations” folder that best matches the HTTP ``accept-language`` header."
msgstr ""

#: ../../chapter-06.rst:193
msgid "Here ``Translator`` is a py4web class that extends ``pluralize.Translator`` and also implements the ``Fixture`` interface."
msgstr ""

#: ../../chapter-06.rst:196
msgid "We can easily combine multiple fixtures. Here, as example, we make action with a counter that counts “visits”."
msgstr ""

#: ../../chapter-06.rst:218
msgid "If the ``T`` fixture is to be used from inside a template you may want to pass it to the template:"
msgstr ""

#: ../../chapter-06.rst:227
msgid "Or perhaps inject (same effect as above)"
msgstr ""

#: ../../chapter-06.rst:239
msgid "Now create the following translation file ``translations/en.json``:"
msgstr ""

#: ../../chapter-06.rst:253
msgid "When visiting this site with the browser language preference set to English and reloading multiple times you will get the following messages:"
msgstr ""

#: ../../chapter-06.rst:267
msgid "Now try create a file called ``translations/it.json`` which contains:"
msgstr ""

#: ../../chapter-06.rst:281
msgid "Set your browser preference to Italian: now the messages will be automatically translated to Italian."
msgstr ""

#: ../../chapter-06.rst:284
msgid "Notice there is an UI in the Dashboard for creating, updating, and updating translation files. It can be easily reached via the button ``i18n+p11n``:"
msgstr ""

#: ../../chapter-06.rst:289
msgid "that leads to the following interface:"
msgstr ""

#: ../../chapter-06.rst:293
msgid "More details can be found here: https://github.com/web2py/pluralize"
msgstr ""

#: ../../chapter-06.rst:296
msgid "If you want to force an action to use language defined somewhere else, for example from a session variable, you can do:"
msgstr ""

#: ../../chapter-06.rst:306
msgid "If you want all of your action to use the same pre-defined language and ignore browser preferences, you have to redefine the select method for the T instance:"
msgstr ""

#: ../../chapter-06.rst:313
msgid "This is to be done outside any action and will apply to all actions. Action will still need to declare ``action.uses(T)`` else the behavior is undefined."
msgstr ""

#: ../../chapter-06.rst:319
msgid "The Flash fixture"
msgstr ""

#: ../../chapter-06.rst:321
msgid "It is common to want to display “alerts” to the users. Here we refer to them as **flash messages**. There is a little more to it than just displaying a message to the view, because flash messages:"
msgstr ""

#: ../../chapter-06.rst:325
msgid "can have state that must be preserved after redirection"
msgstr ""

#: ../../chapter-06.rst:326
msgid "can be generated both server side and client side"
msgstr ""

#: ../../chapter-06.rst:327
msgid "may have a type"
msgstr ""

#: ../../chapter-06.rst:328
msgid "should be dismissible"
msgstr ""

#: ../../chapter-06.rst:330
msgid "The Flash helper handles the server side of them. Here is an example:"
msgstr ""

#: ../../chapter-06.rst:344
msgid "and in the template:"
msgstr ""

#: ../../chapter-06.rst:350
msgid "By setting the value of the message in the flash helper, a flash variable is returned by the action and this triggers the JS in the template to inject the message in the ``py4web-flash`` DIV which you can position at your convenience. Also the optional class is applied to the injected HTML."
msgstr ""

#: ../../chapter-06.rst:356
msgid "If a page is redirected after a flash is set, the flash is remembered. This is achieved by asking the browser to keep the message temporarily in a one-time cookie. After redirection the message is sent back by the browser to the server and the server sets it again automatically before returning the content, unless it is overwritten by another set."
msgstr ""

#: ../../chapter-06.rst:362
msgid "The client can also set/add flash messages by calling:"
msgstr ""

#: ../../chapter-06.rst:368
msgid "py4web defaults to an alert class called ``info`` and most CSS frameworks define classes for alerts called ``success``, ``error``, ``warning``, ``default``, and ``info``. Yet, there is nothing in py4web that hardcodes those names. You can use your own class names."
msgstr ""

#: ../../chapter-06.rst:373
msgid "You can see the basic usage of flash messages in the **examples** app."
msgstr ""

#: ../../chapter-06.rst:376
msgid "The Session fixture"
msgstr ""

#: ../../chapter-06.rst:378
msgid "Simply speaking, a session can be defined as a way to preserve information that is desired to persist throughout the user's interaction with the web site or web application. In other words, sessions render the stateless HTTP connection a stateful one."
msgstr ""

#: ../../chapter-06.rst:382
msgid "In py4web, the session object is also a fixture. Here is a simple example of its usage to implement a counter."
msgstr ""

#: ../../chapter-06.rst:398
msgid "The counter will start from 0; its value will be remembered and increased every time you reload the page."
msgstr ""

#: ../../chapter-06.rst:403
msgid "Opening the page in a new browser tab will give you the updated counter value. Closing and reopening the browser, or opening a new *private window*, will instead restart the counter from 0."
msgstr ""

#: ../../chapter-06.rst:407
msgid "Usually the information is saved in the session object are related to the user - like its username, preferences, last pages visited, shopping cart and so on. The session object has the same interface as a Python dictionary but in py4web sessions are always stored using JSON (**JWT** specifically, i.e. `JSON Web Token <https://jwt.io/introduction>`__), therefore you should only store objects that are JSON serializable. If the object is not JSON serializable, it will be serialized using the ``__str__`` operator and some information may be lost."
msgstr ""

#: ../../chapter-06.rst:417
msgid "The information composing the session object can be saved:"
msgstr ""

#: ../../chapter-06.rst:419
msgid "client-side, by only using cookies (default)"
msgstr ""

#: ../../chapter-06.rst:420
msgid "server-side, but you'll still need minimal cookies for identifying the clients"
msgstr ""

#: ../../chapter-06.rst:423
msgid "By default py4web sessions never expire (unless they contain login information, but that is another story) even if an expiration can be set. Other parameters can be specified as well:"
msgstr ""

#: ../../chapter-06.rst:436
msgid "Here:"
msgstr ""

#: ../../chapter-06.rst:438
msgid "``secret`` is the passphrase used to sign the information"
msgstr ""

#: ../../chapter-06.rst:439
msgid "``expiration`` is the maximum lifetime of the session, in seconds (default = None, i.e. no timeout)"
msgstr ""

#: ../../chapter-06.rst:441
msgid "``algorithm`` is the algorithm to be used for the JWT token signature ('HS256' by default)"
msgstr ""

#: ../../chapter-06.rst:443
msgid "``storage`` is a parameter that allows to specify an alternate session storage method (for example Redis, or database). If not specified, the default cookie method will be used"
msgstr ""

#: ../../chapter-06.rst:446
msgid "``same_site`` is an option that prevents CSRF attacks (Cross-Site Request Forgery) and is enabled by default with the 'Lax' option. You can read more about it `here <https://owasp.org/www-community/SameSite>`__"
msgstr ""

#: ../../chapter-06.rst:450
msgid "``name`` is the format to use for the session cookie name."
msgstr ""

#: ../../chapter-06.rst:452
msgid "If storage is not provided, session is stored in client-side jwt cookie. Otherwise, we have server-side session: the jwt is stored in storage and only its UUID key is stored in the cookie. This is the reason why the secret is not required with server-side sessions."
msgstr ""

#: ../../chapter-06.rst:459
msgid "Client-side session in cookies"
msgstr ""

#: ../../chapter-06.rst:461
msgid "By default the session object is stored inside a cookie called ``appname_session``. It's a JWT, hence encoded in a URL-friendly string format and signed using the provided secret for preventing tampering."
msgstr ""

#: ../../chapter-06.rst:467
msgid "Data embedded in cookies is signed, not encrypted! In fact it's quite trivial to read its content from http communications or from disk, so do not place any sensitive information inside, and use a complex secret."
msgstr ""

#: ../../chapter-06.rst:472
msgid "If the secret changes existing sessions are invalidated. If the user switches from HTTP to HTTPS or vice versa, the user session is also invalidated. Session in cookies have a small size limit (4 kbytes after being serialized and encoded) so do not put too much into them."
msgstr ""

#: ../../chapter-06.rst:479
msgid "Server-side session in memcache"
msgstr ""

#: ../../chapter-06.rst:481
msgid "Requires memcache installed and configured."
msgstr ""

#: ../../chapter-06.rst:491
msgid "Server-side session in Redis"
msgstr ""

#: ../../chapter-06.rst:493
msgid "Requires `Redis <https://redis.io/>`__ installed and configured."
msgstr ""

#: ../../chapter-06.rst:503
msgid "Notice: a storage object must have ``get`` and ``set`` methods and the ``set`` method must allow to specify an expiration. The redis connection object has a ``ttl`` method to specify the expiration, hence we monkey patch the ``set`` method to have the expected signature and functionality."
msgstr ""

#: ../../chapter-06.rst:510
msgid "Server-side session in database"
msgstr ""

#: ../../chapter-06.rst:520
msgid "the ``'sqlite:memory'`` database used in this example **cannot be used in multiprocess environment**; the quirk is that your application will still work but in non-deterministic and unsafe mode, since each process/worker will have its own independent in-memory database."
msgstr ""

#: ../../chapter-06.rst:526
msgid "This is one case when a fixture (session) requires another fixture (db). This is handled automatically by py4web and the following lines are equivalent:"
msgstr ""

#: ../../chapter-06.rst:536
msgid "Server-side session anywhere"
msgstr ""

#: ../../chapter-06.rst:538
msgid "You can easily store sessions in any place you want. All you need to do is provide to the ``Session`` object a ``storage`` object with both ``get`` and ``set`` methods. For example, imagine you want to store sessions on your local filesystem:"
msgstr ""

#: ../../chapter-06.rst:564
msgid "We leave to you as an exercise to implement expiration, limit the number of files per folder by using subfolders, and implement file locking. Yet we do not recommend storing sessions on the filesystem: it is inefficient and does not scale well."
msgstr ""

#: ../../chapter-06.rst:570
msgid "Sharing sessions"
msgstr ""

#: ../../chapter-06.rst:572
msgid "Imagine you have an app \"app1\" which uses a session and an app \"app2\" that wants to share a session with app1. Assuming they use sessions in cookies, \"app2\" would use:"
msgstr ""

#: ../../chapter-06.rst:580
msgid "The name tells app2 to use the cookie \"app1_session\" from app1. Notice it is important that the secret is the same as app1's secret. If using a session in db, then app2 must be using the same db as app1. It is up to the user to make sure that the data stored in the session and shared between the two apps are consistent and we strongly recommend that only app1 writes to the session, unless the share one and the same database."
msgstr ""

#: ../../chapter-06.rst:584
msgid "Notice that it is possible for one app to handle multiple sessions. For example one session may be its own, and another may be used exclusively to read data from another app (app1) running on the same server:"
msgstr ""

#: ../../chapter-06.rst:597
msgid "The Condition fixture"
msgstr ""

#: ../../chapter-06.rst:599
msgid "Sometimes you want to restrict access to an action based on a given condition. For example to enforce a workflow:"
msgstr ""

#: ../../chapter-06.rst:625
msgid "Notice that the Condition fixtures takes a function as first argument which is called ``on_request`` and must evaluate to True or False."
msgstr ""

#: ../../chapter-06.rst:628
msgid "Also notice that in the above example the Condition depends on the Session therefore it must be listed after ``session`` in ``action.uses``."
msgstr ""

#: ../../chapter-06.rst:631
msgid "If False, by default, the Condition fixture raises 404. It is possible to specify a different exception:"
msgstr ""

#: ../../chapter-06.rst:638
msgid "It is also possible to call a function before the exception is raised, for example, to redirect to another page:"
msgstr ""

#: ../../chapter-06.rst:645
msgid "You can use condition to check permissions. For example, if you are giving group memberships to users using ``Tags`` (it will be explained later on the :ref:`Authorization using Tags` chapter), then you can require that users action have specific group membership:"
msgstr ""

#: ../../chapter-06.rst:662
msgid "The URLsigner fixture"
msgstr ""

#: ../../chapter-06.rst:664
msgid "A signed URL is a URL that provides limited permission and time to make an HTTP request by containing authentication information in its query string. The typical usage is as follows:"
msgstr ""

#: ../../chapter-06.rst:688
msgid "The DAL fixture"
msgstr ""

#: ../../chapter-06.rst:690
msgid "We have already used the ``DAL`` fixture in the context of sessions but maybe you want direct access to the DAL object for the purpose of accessing the database, not just sessions."
msgstr ""

#: ../../chapter-06.rst:694
msgid "PY4WEB, by default, uses the **PyDAL** (Python Database Abstraction Layer) which is documented in the next chapter. Here is an example, please remember to create the ``databases`` folder under your project in case it doesn't exist:"
msgstr ""

#: ../../chapter-06.rst:717
msgid "Notice that the database fixture defines (creates/re-creates) tables automatically when py4web starts (and every time it reloads this app) and picks a connection from the connection pool at every HTTP request. Also each call to the ``index()`` action is wrapped into a transaction and it commits ``on_success`` and rolls back ``on_error``."
msgstr ""

#: ../../chapter-06.rst:724
msgid "The Auth fixture"
msgstr ""

#: ../../chapter-06.rst:726
msgid "``auth`` and ``auth.user`` are both fixtures that depend on ``session`` and ``db``. Their role is to provide the action with authentication information."
msgstr ""

#: ../../chapter-06.rst:730
msgid "Auth is used as follows:"
msgstr ""

#: ../../chapter-06.rst:750
msgid "The constructor of the ``Auth`` object defines the ``auth_user`` table with the following fields: username, email, password, first_name, last_name, sso_id, and action_token (the last two are mostly for internal use)."
msgstr ""

#: ../../chapter-06.rst:755
msgid "If a ``auth_user`` table is defined before calling ``auth.enable()`` the provided table will be used."
msgstr ""

#: ../../chapter-06.rst:758
msgid "It is also possible to add ``extra_fields`` to the ``auth_user`` table, for example:"
msgstr ""

#: ../../chapter-06.rst:768
msgid "In any case, we recommend not to pollute the ``auth_user`` table with extra fields but, instead, to use one of more additional custom tables that reference users and store the required information."
msgstr ""

#: ../../chapter-06.rst:772
msgid "The ``auth`` object exposes the method:``auth.enable()`` which registers multiple actions including ``{appname}/auth/login``. It requires the presence of the ``auth.html`` template and the ``auth`` value component provided by the ``_scaffold`` app. It also exposes the method:"
msgstr ""

#: ../../chapter-06.rst:782
msgid "which returns a python dictionary containing the information of the currently logged in user. If the user is not logged-in, it returns ``None`` and in this case the code of the example redirects to the ``auth/login`` page."
msgstr ""

#: ../../chapter-06.rst:787
msgid "Since this check is very common, py4web provides an additional fixture ``auth.user``:"
msgstr ""

#: ../../chapter-06.rst:798
msgid "This fixture automatically redirects to the ``auth/login`` page if user is not logged-in, hence this example is equivalent to the previous one."
msgstr ""

#: ../../chapter-06.rst:801
msgid "The ``auth`` fixture is plugin based: it supports multiple plugin methods including OAuth2 (Google, Facebook, Twitter), PAM and LDAP. The :ref:`Authentication and authorization` chapter will show you all the related details."
msgstr ""

#: ../../chapter-06.rst:807
msgid "Caveats about fixtures"
msgstr ""

#: ../../chapter-06.rst:809
msgid "Since fixtures are shared by multiple actions you are not allowed to change their state because it would not be thread safe. There is one exception to this rule. Actions can change some attributes of database fields:"
msgstr ""

#: ../../chapter-06.rst:831
msgid "Note that this code will only be able to display a form, to process it after submit, additional code needs to be added, as we will see later on. This example is assuming that you created the application from the scaffolding app, so that a generic.html is already created for you."
msgstr ""

#: ../../chapter-06.rst:836
msgid "The full list of database field attributes which can be changed safely is found here: :ref:`Thread safety and Field attributes`"
msgstr ""

#: ../../chapter-06.rst:840
msgid "Custom fixtures"
msgstr ""

#: ../../chapter-06.rst:842
msgid "A fixture is an object with the following minimal structure:"
msgstr ""

#: ../../chapter-06.rst:853
msgid "For example in the DAL fixture case, ``on_request`` starts a transaction, ``on_success`` commits it, and ``on_error`` rolls it back."
msgstr ""

#: ../../chapter-06.rst:856
msgid "In the case of a template, ``on_request`` and ``on_error`` do nothing but ``on_success`` transforms the output."
msgstr ""

#: ../../chapter-06.rst:859
msgid "In the case of ``auth.user`` fixtures, ``on_request`` does all the work of determining if the user is logged in (from the dependent session fixture) and eventually preventing the request from accessing the inner layers."
msgstr ""

#: ../../chapter-06.rst:863
msgid "Now imagine a request coming in calling an action with three fixtures A, B, and C. Under normal circumstances above methods are executed in this order:"
msgstr ""

#: ../../chapter-06.rst:871
msgid "i.e. the first fixture (A) is the first one to call ``on_request`` and the last one to call ``on_success``. You can think of them as layers of an onion with the action (user code) at the center. ``on_success`` is called when entering a layer from the outside and ``on_success`` is called when exiting a layer from the inside (like WSGI middleware)."
msgstr ""

#: ../../chapter-06.rst:877
msgid "If any point an exception is raised inner layers are not called and outer layers will call ``on_error`` instead of ``on_success``."
msgstr ""

#: ../../chapter-06.rst:880
msgid "Context is a shared object which contains:"
msgstr ""

#: ../../chapter-06.rst:882
msgid "content['fixtures']: the list of all the fixtures for the action."
msgstr ""

#: ../../chapter-06.rst:883
msgid "context['processed']: the list of fixtures that called ``on_request`` previously within the request."
msgstr ""

#: ../../chapter-06.rst:884
msgid "context['exception']: the exception raised by the action or any previous fixture logic (usually None)"
msgstr ""

#: ../../chapter-06.rst:885
msgid "context['output']: the action output."
msgstr ""

#: ../../chapter-06.rst:887
msgid "``on_success`` and ``on_error`` can see the current ``context['exception']`` and transform it. They can see the current ``context['output']`` and transform it as well."
msgstr ""

#: ../../chapter-06.rst:890
msgid "For example here is a fixture that transforms the output text to upper case:"
msgstr ""

#: ../../chapter-06.rst:904
msgid "Notice that this fixture assumes the ``context['output']`` is a string and therefore it must come before the template."
msgstr ""

#: ../../chapter-06.rst:907
msgid "Here is a fixture that logs exceptions tracebacks to a file:"
msgstr ""

#: ../../chapter-06.rst:924
msgid "Fixtures also have a ``__prerequisite__`` attribute. If a fixture takes another fixture as an argument, its value must be appended to the list of ``__prerequisites__``. This guarantees that they are always executed in the proper order even if listed in the wrong order. It also makes it optional to declare prerequisite fixtures in ``action.uses``."
msgstr ""

#: ../../chapter-06.rst:930
msgid "For example ``Auth`` depends on ``db``, ``session``, and ``flash``. ``db`` and ``session`` are indeed arguments. ``flash`` is a special singleton fixture declared within ``Auth``. This means that"
msgstr ""

#: ../../chapter-06.rst:938
msgid "is equivalent to"
msgstr ""

#: ../../chapter-06.rst:944
msgid "Why are fixtures not simply functions that contain a try/except?"
msgstr ""

#: ../../chapter-06.rst:946
msgid "We considered the option but there are some special exceptions that should not be considered errors but success (``py4web.HTTP``, ``bottle.HTTResponse``) while other exceptions are errors. The actual logic can be complicated and individual fixtures do not need to know these details."
msgstr ""

#: ../../chapter-06.rst:951
msgid "They all need to know what the context is and whether they are processing a new request or a response and whether the response is a success or an error. We believe this logic keeps the fixtures easy."
msgstr ""

#: ../../chapter-06.rst:955
msgid "Fixtures should not in general communicate with each other but nothing prevents one fixture to put data in the context and another fixture to retrieve that data."
msgstr ""

#: ../../chapter-06.rst:960
msgid "Fixtures with dependencies"
msgstr ""

#: ../../chapter-06.rst:962
msgid "If a fixture depends on another fixture, it needs to be passed that fixture in the initializer, and the fixture must be listed in the ``__prerequisites__`` attribute. For example, suppose we want to create a fixture that grants access to a controller only to users whose email address is included in an ADMIN_EMAILS list. We can write the following fixture:"
msgstr ""

#: ../../chapter-06.rst:990
msgid "The fixture can be created and used as follows:"
msgstr ""

#: ../../chapter-06.rst:1002
msgid "Using local storage"
msgstr ""

#: ../../chapter-06.rst:1004
msgid "Fixtures can use a thread-local storage for data they need. Here is an example:"
msgstr ""

#: ../../chapter-06.rst:1026
msgid "Notably, the initializer should contain the line:"
msgstr ""

#: ../../chapter-06.rst:1032
msgid "in order to initialize the thread-local storage. Once this is done, the thread-local storage can be used to store and retrieve data using the the ``self.local`` object."
msgstr ""

#: ../../chapter-06.rst:1038
msgid "Multiple fixtures"
msgstr ""

#: ../../chapter-06.rst:1040
msgid "As previously stated, it's generally not important the order you use to specify the fixtures but it's mandatory that you always place the template as the **first one**. Consider this:"
msgstr ""

#: ../../chapter-06.rst:1050
msgid "Pre-processing (``on_request``) in the fixtures happen in the sequence they are listed and then the ``on_success`` or ``on_error`` methods will be executed in reverse order (as an onion)."
msgstr ""

#: ../../chapter-06.rst:1054
msgid "Hence the previous code can be explicitly transformed to:"
msgstr ""

#: ../../chapter-06.rst:1064
msgid "So if A.on_success() is a template and B is an inject fixture that allows you to add some extra variables to your templates, then A must come first."
msgstr ""

#: ../../chapter-06.rst:1067
msgid "Notice that"
msgstr ""

#: ../../chapter-06.rst:1074
msgid "is almost equivalent to"
msgstr ""

#: ../../chapter-06.rst:1080
msgid "but not quite. All fixtures declared in one ``action.uses`` share the same context while fixtures in different ``action.uses`` use different contexts and therefore they cannot communicate with each other. This may change in the future. For now we recommend using a single call to ``action.uses``."
msgstr ""

#: ../../chapter-06.rst:1088
msgid "Caching and Memoize"
msgstr ""

#: ../../chapter-06.rst:1090
msgid "py4web provides a cache in RAM object that implements the last recently used (LRU) algorithm. It can be used to cache any function via a decorator:"
msgstr ""

#: ../../chapter-06.rst:1105
msgid "It will cache (memoize) the return value of the ``hello`` function, as function of the input ``name``, for up to 60 seconds. It will store in cache the 1000 most recently used values. The data is always stored in RAM."
msgstr ""

#: ../../chapter-06.rst:1110
msgid "The ``cache`` object is not a fixture and it should not and cannot be registered using the ``@action.uses`` decorator but we mention it here because some of the fixtures use this object internally. For example, template files are cached in RAM to avoid accessing the file system every time a template needs to be rendered."
msgstr ""

#: ../../chapter-06.rst:1117
msgid "Convenience Decorators"
msgstr ""

#: ../../chapter-06.rst:1119
msgid "The ``_scaffold`` application, in ``common.py`` defines two special convenience decorators using ActionFactory:"
msgstr ""

#: ../../chapter-06.rst:1128
msgid "and"
msgstr ""

#: ../../chapter-06.rst:1136
msgid "They apply all of the decorators below (db, session, T, flash, auth), use a template with the same name as the function (.html), and also register a route with the name of action followed by the number of arguments of the action separated by a slash (/)."
msgstr ""

#: ../../chapter-06.rst:1141
msgid "@unauthenticated does not require the user to be logged in."
msgstr ""

#: ../../chapter-06.rst:1142
msgid "@authenticated required the user to be logged in."
msgstr ""

#: ../../chapter-06.rst:1146
msgid "ActionFactory decorators like these cannot be combined with @action or @action.uses"
msgstr ""

#: ../../chapter-06.rst:1149
msgid "The decorators can be used directly as shown above, which enables all HTTP methods (GET, POST, PUT, ...) but you can also create separate controllers for each HTTP method:"
msgstr ""

#: ../../chapter-06.rst:1165
msgid "The both decorator and its HTTP method calls have the following arguments:"
msgstr ""

#: ../../chapter-06.rst:1167
msgid "``path`` overwrites the path built from the function name with the given string. Does not automatically handle arguments."
msgstr ""

#: ../../chapter-06.rst:1168
msgid "``template`` specifies the template name, instead of using the function name."
msgstr ""

#: ../../chapter-06.rst:1169
msgid "``uses`` specify extra fixtures for this specific controllers."
msgstr ""

#: ../../chapter-06.rst:1181
msgid "As manual ordering of fixtures isn't possible with ``uses``, make sure the fixtures define their dependencies. See: :ref:`Fixtures with dependencies`"
msgstr ""
