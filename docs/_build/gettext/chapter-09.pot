# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, BSDv3 License
# This file is distributed under the same license as the py4web package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: py4web 20251209\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-12-18 20:03+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../chapter-09.rst:3
msgid "YATL Template Language"
msgstr ""

#: ../../chapter-09.rst:5
msgid "py4web uses two distinct template languages for rendering dynamic HTML pages that contain Python code:"
msgstr ""

#: ../../chapter-09.rst:7
msgid "`yatl (Yet Another Template Language) <https://pypi.org/project/yatl/>`__ , which is considered the original reference implementation"
msgstr ""

#: ../../chapter-09.rst:8
msgid "`Renoir <https://pypi.org/project/renoir/>`__, which is a newer and faster implementation of yatl with additional functionality"
msgstr ""

#: ../../chapter-09.rst:11
msgid "Since ``Renoir`` does not include HTML helpers (see next chapter), py4web by default uses the ``Renoir`` module for rendering templates and the ``yatl`` module for helpers, plus some minor trickery to make them work together seamlessly."
msgstr ""

#: ../../chapter-09.rst:14
msgid "py4web also uses double square brackets ``[[ ... ]]`` to escape Python code embedded in HTML, unless specified otherwise."
msgstr ""

#: ../../chapter-09.rst:16
msgid "The advantage of using square brackets instead of angle brackets is that it’s transparent to all common HTML editors. This allows the developer to use those editors to create py4web templates."
msgstr ""

#: ../../chapter-09.rst:21
msgid "Be careful not to mix Python code square brackets with other square brackets! For example, you'll soon see syntax like this:"
msgstr ""

#: ../../chapter-09.rst:30
msgid "It's mandatory to add a space after the first closed bracket for separating the list from the Python code square brackets."
msgstr ""

#: ../../chapter-09.rst:33
msgid "Since the developer is embedding Python code into HTML, the document should be indented according to HTML rules, and not Python rules. Therefore, we allow un-indented Python inside the ``[[ ... ]]`` tags. But since Python normally uses indentation to delimit blocks of code, we need a different way to delimit them; this is why the py4web template language makes use of the Python keyword ``pass``."
msgstr ""

#: ../../chapter-09.rst:40
msgid "A **code block** starts with a line ending with a colon and ends with a line beginning with ``pass``. The keyword ``pass`` is not necessary when the end of the block is obvious from the context."
msgstr ""

#: ../../chapter-09.rst:44
msgid "Here is an example:"
msgstr ""

#: ../../chapter-09.rst:56
msgid "Note that ``pass`` is a Python keyword, not a py4web keyword. Some Python editors, such as Emacs, use the keyword ``pass`` to signify the division of blocks and use it to re-indent code automatically."
msgstr ""

#: ../../chapter-09.rst:60
msgid "The py4web template language does exactly the same. When it finds something like:"
msgstr ""

#: ../../chapter-09.rst:69
msgid "it translates it into a program:"
msgstr ""

#: ../../chapter-09.rst:79
msgid "``response.write`` writes to the response body."
msgstr ""

#: ../../chapter-09.rst:81
msgid "When there is an error in a py4web template, the error report shows the generated template code, not the actual template as written by the developer. This helps the developer debug the code by highlighting the actual code that is executed (which is something that can be debugged with an HTML editor or the DOM inspector of the browser)."
msgstr ""

#: ../../chapter-09.rst:87
msgid "Also note that:"
msgstr ""

#: ../../chapter-09.rst:93
msgid "generates"
msgstr ""

#: ../../chapter-09.rst:99
msgid "Variables injected into the HTML in this way are escaped by default. The escaping is ignored if ``x`` is an ``XML`` object, even if escape is set to ``True`` (see :ref:`XML` later for details)."
msgstr ""

#: ../../chapter-09.rst:103
msgid "Here is an example that introduces the ``H1`` helper:"
msgstr ""

#: ../../chapter-09.rst:109
msgid "which is translated to:"
msgstr ""

#: ../../chapter-09.rst:115
msgid "upon evaluation, the ``H1`` object and its components are recursively serialized, escaped and written to the response body. The tags generated by ``H1`` and inner HTML are not escaped. This mechanism guarantees that all text — and only text — displayed on the web page is always escaped, thus preventing XSS vulnerabilities. At the same time, the code is simple and easy to debug."
msgstr ""

#: ../../chapter-09.rst:122
msgid "The method ``response.write(obj, escape=True)`` takes two arguments, the object to be written and whether it has to be escaped (set to ``True`` by default). If ``obj`` has an ``.xml()`` method, it is called and the result written to the response body (the ``escape`` argument is ignored). Otherwise it uses the object’s ``__str__`` method to serialize it and, if the escape argument is ``True``, escapes it. All built-in helper objects (``H1`` in the example) are objects that know how to serialize themselves via the ``.xml()`` method."
msgstr ""

#: ../../chapter-09.rst:131
msgid "This is all done transparently."
msgstr ""

#: ../../chapter-09.rst:135
msgid "While the response object used inside the controllers is a full ``bottle.response`` object, inside the yatl templates it is replaced by a dummy object (``yatl.template.DummyResponse``). This object is quite different, and much simpler: it only has a write method! Also, you never need to (and never should) call the ``response.write`` method explicitly."
msgstr ""

#: ../../chapter-09.rst:144
msgid "Basic syntax"
msgstr ""

#: ../../chapter-09.rst:146
msgid "The py4web template language supports all Python control structures. Here we provide some examples of each of them. They can be nested according to usual programming practice. You can easily test them by copying the _scaffold app (see :ref:`copying-the-scaffold-app`) and then editing the file ``new_app/template/index.html``."
msgstr ""

#: ../../chapter-09.rst:154
msgid "``for...in``"
msgstr ""

#: ../../chapter-09.rst:156
msgid "In templates you can loop over any iterable object:"
msgstr ""

#: ../../chapter-09.rst:165
#: ../../chapter-09.rst:191
#: ../../chapter-09.rst:217
msgid "which produces:"
msgstr ""

#: ../../chapter-09.rst:175
msgid "Here ``items`` is any iterable object such as a Python list, Python tuple, or Rows object, or any object that is implemented as an iterator. The elements displayed are first serialized and escaped."
msgstr ""

#: ../../chapter-09.rst:180
msgid "``while``"
msgstr ""

#: ../../chapter-09.rst:182
msgid "You can create a loop using the while keyword:"
msgstr ""

#: ../../chapter-09.rst:202
msgid "``if...elif...else``"
msgstr ""

#: ../../chapter-09.rst:204
msgid "You can use conditional clauses:"
msgstr ""

#: ../../chapter-09.rst:225
msgid "Since it is obvious that ``else`` closes the first ``if`` block, there is no need for a ``pass`` statement, and using one would be incorrect. However, you must explicitly close the ``else`` block with a ``pass``."
msgstr ""

#: ../../chapter-09.rst:229
msgid "Recall that in Python “else if” is written ``elif`` as in the following example:"
msgstr ""

#: ../../chapter-09.rst:246
msgid "It produces:"
msgstr ""

#: ../../chapter-09.rst:255
msgid "``try...except...else...finally``"
msgstr ""

#: ../../chapter-09.rst:257
msgid "It is also possible to use ``try...except`` statements in templates with one caveat. Consider the following example:"
msgstr ""

#: ../../chapter-09.rst:272
msgid "It will produce the following output:"
msgstr ""

#: ../../chapter-09.rst:279
msgid "This example illustrates that all output generated before an exception occurs is rendered (including output that preceded the exception) inside the try block. “Hello” is written because it precedes the exception."
msgstr ""

#: ../../chapter-09.rst:284
msgid "``def...return``"
msgstr ""

#: ../../chapter-09.rst:286
msgid "The py4web template language allows the developer to define and implement functions that can return any Python object or a text/html string. Here we consider two examples:"
msgstr ""

#: ../../chapter-09.rst:297
msgid "produces the following output:"
msgstr ""

#: ../../chapter-09.rst:305
msgid "The function ``itemize1`` returns a helper object that is inserted at the location where the function is called."
msgstr ""

#: ../../chapter-09.rst:308
msgid "Consider now the following code:"
msgstr ""

#: ../../chapter-09.rst:319
msgid "It produces exactly the same output as above. In this case, the function ``itemize2`` represents a piece of HTML that is going to replace the py4web tag where the function is called. Notice that there is no ‘=’ in front of the call to ``itemize2``, since the function does not return the text, but it writes it directly into the response."
msgstr ""

#: ../../chapter-09.rst:325
msgid "There is one caveat: functions defined inside a template must terminate with a ``return`` statement, or the automatic indentation will fail."
msgstr ""

#: ../../chapter-09.rst:329
msgid "Information workflow"
msgstr ""

#: ../../chapter-09.rst:331
msgid "For dynamically modifying the workflow of the information there are custom commands available: ``extend``, ``include``, ``block`` and ``super``. Note that they are special template directives, not Python commands."
msgstr ""

#: ../../chapter-09.rst:335
msgid "In addition, you can use normal Python functions inside templates."
msgstr ""

#: ../../chapter-09.rst:339
msgid "``extend`` and ``include``"
msgstr ""

#: ../../chapter-09.rst:341
msgid "Templates can extend and include other templates in a tree-like structure."
msgstr ""

#: ../../chapter-09.rst:343
msgid "For example, we can think of a template “index.html” that extends “layout.html” and includes “body.html”. At the same time, “layout.html” may include “header.html” and “footer.html”."
msgstr ""

#: ../../chapter-09.rst:347
msgid "The root of the tree is what we call a **layout template**. Just like any other HTML template file, you can edit it from the command line or using the py4web Dashboard. The file name “layout.html” is just a convention."
msgstr ""

#: ../../chapter-09.rst:351
msgid "Here is a minimalist page that extends the “layout.html” template and includes the “page.html” template:"
msgstr ""

#: ../../chapter-09.rst:361
msgid "The extended layout file must contain an ``[[include]]`` directive, something like:"
msgstr ""

#: ../../chapter-09.rst:376
msgid "When the template is called, the extended (layout) template is loaded, and the calling template replaces the ``[[include]]`` directive inside the layout. If you don't write the ``[[include]]`` directive inside the layout, then it will be included at the beginning of the file. Also, if you use multiple ``[[extend]]`` directives only the last one will be processed. Processing continues recursively until all ``extend`` and ``include`` directives have been processed. The resulting template is then translated into Python code."
msgstr ""

#: ../../chapter-09.rst:385
msgid "Note, when an application is bytecode compiled, it is this Python code that is compiled, not the original template files themselves. So, the bytecode compiled version of a given template is a single .pyc file that includes the Python code not just for the original template file, but for its entire tree of extended and included templates."
msgstr ""

#: ../../chapter-09.rst:391
msgid "Any content or code that **precedes** the ``[[extend ...]]`` directive will be inserted (and therefore executed) before the beginning of the extended template's content/code. Although this is not typically used to insert actual HTML content before the extended template's content, it can be useful as a means to define variables or functions that you want to make available to the extended template. For example, consider a template “index.html”:"
msgstr ""

#: ../../chapter-09.rst:406
msgid "and an excerpt from “layout.html”:"
msgstr ""

#: ../../chapter-09.rst:418
msgid "Because the ``sidebar_enabled`` assignment in “index.html” comes before the ``extend``, that line gets inserted before the beginning of “layout.html”, making ``sidebar_enabled`` available anywhere within the “layout.html” code."
msgstr ""

#: ../../chapter-09.rst:423
msgid "It is also worth pointing out that the variables returned by the controller function are available not only in the function’s main template, but in all of its extended and included templates as well."
msgstr ""

#: ../../chapter-09.rst:428
msgid "Extending using variables"
msgstr ""

#: ../../chapter-09.rst:430
msgid "The argument of an ``extend`` or ``include`` (i.e., the extended or included template name) can be a Python variable (though not a Python expression). However, this imposes a limitation – templates that use variables in ``extend`` or ``include`` statements cannot be bytecode compiled. As noted above, bytecode-compiled templates include the entire tree of extended and included templates, so the specific extended and included templates must be known at compile time, which is not possible if the template names are variables (whose values are not determined until run time). Because bytecode compiling templates can provide a significant speed boost, using variables in ``extend`` and ``include`` should generally be avoided if possible."
msgstr ""

#: ../../chapter-09.rst:442
msgid "In some cases, an alternative to using a variable in an ``include`` is simply to place regular ``[[include ...]]`` directives inside an ``if...else`` block."
msgstr ""

#: ../../chapter-09.rst:454
msgid "The above code does not present any problem for bytecode compilation because no variables are involved. Note, however, that the bytecode compiled template will actually include the Python code for both “this_template.html” and “that_template.html”, though only the code for one of those templates will be executed, depending on the value of ``some_condition``."
msgstr ""

#: ../../chapter-09.rst:461
msgid "Keep in mind, this only works for ``include`` – you cannot place ``[[extend ...]]`` directives inside ``if...else`` blocks."
msgstr ""

#: ../../chapter-09.rst:464
msgid "Layouts are used to encapsulate page commonality (headers, footers, menus), and though they are not mandatory, they will make your application easier to write and maintain."
msgstr ""

#: ../../chapter-09.rst:469
msgid "Template Functions"
msgstr ""

#: ../../chapter-09.rst:471
msgid "Consider this “layout.html”:"
msgstr ""

#: ../../chapter-09.rst:487
msgid "and this extending template"
msgstr ""

#: ../../chapter-09.rst:497
msgid "Notice the function is defined before the ``[[extend...]]`` statement – this results in the function being created before the “layout.html” code is executed, so the function can be called anywhere within “layout.html”, even before the ``[[include]]``. Also notice the function is included in the extended template without the ``=`` prefix."
msgstr ""

#: ../../chapter-09.rst:503
msgid "The code generates the following output:"
msgstr ""

#: ../../chapter-09.rst:516
msgid "Notice that the function is defined in HTML (although it could also contain Python code) so that ``response.write`` is used to write its content (the function does not return the content). This is why the layout calls the template function using ``[[mysidebar()]]`` rather than ``[[=mysidebar()]]``. Functions defined in this way can take arguments."
msgstr ""

#: ../../chapter-09.rst:523
msgid "``block`` and ``super``"
msgstr ""

#: ../../chapter-09.rst:525
msgid "The main way to make a template more modular is by using ``[[block ...]]``\\ s and this mechanism is an alternative to the mechanism discussed in the previous section."
msgstr ""

#: ../../chapter-09.rst:529
msgid "To understand how this works, consider apps based on the scaffolding app welcome, which has a template layout.html. This template is extended by the template ``default/index.html`` via ``[[extend 'layout.html']]``. The contents of layout.html predefine certain blocks with certain default content, and these are therefore included into default/index.html."
msgstr ""

#: ../../chapter-09.rst:535
msgid "You can override these default content blocks by enclosing your new content inside the same block name. The location of the block in the layout.html is not changed, but the contents is."
msgstr ""

#: ../../chapter-09.rst:539
msgid "Here is a simplified version. Imagine this is “layout.html”:"
msgstr ""

#: ../../chapter-09.rst:554
msgid "and this is a simple extending template ``default/index.html``:"
msgstr ""

#: ../../chapter-09.rst:564
msgid "It generates the following output, where the content is provided by the over-riding block in the extending template, yet the enclosing DIV and class comes from layout.html. This allows consistency across templates:"
msgstr ""

#: ../../chapter-09.rst:579
msgid "The real layout.html defines a number of useful blocks, and you can easily add more to match the layout your desire."
msgstr ""

#: ../../chapter-09.rst:582
msgid "You can have many blocks, and if a block is present in the extended template but not in the extending template, the content of the extended template is used. Also, notice that unlike with functions, it is not necessary to define blocks before the ``[[extend ...]]`` – even if defined after the ``extend``, they can be used to make substitutions anywhere in the extended template."
msgstr ""

#: ../../chapter-09.rst:589
msgid "Inside a block, you can use the expression ``[[super]]`` to include the content of the parent. For example, if we replace the above extending template with:"
msgstr ""

#: ../../chapter-09.rst:602
msgid "we get:"
msgstr ""

#: ../../chapter-09.rst:620
msgid "Page layout standard structure"
msgstr ""

#: ../../chapter-09.rst:624
msgid "Default page layout"
msgstr ""

#: ../../chapter-09.rst:626
msgid "The “templates/layout.html” that currently ships with the py4web **_scaffold** application is quite complex but it has the following structure:"
msgstr ""

#: ../../chapter-09.rst:705
msgid "There are a few features of this default layout that make it very easy to use and customize:"
msgstr ""

#: ../../chapter-09.rst:708
msgid "it is written in HTML5"
msgstr ""

#: ../../chapter-09.rst:709
msgid "on line 7 it's used the ``no.css`` stylesheet, see `here <https://github.com/mdipierro/no.css/>`__"
msgstr ""

#: ../../chapter-09.rst:711
msgid "on line 58 ``[[include]]`` is replaced by the content of the extending template when the page is rendered"
msgstr ""

#: ../../chapter-09.rst:713
msgid "it contains the following blocks: page_head, page_left_menu, page_scripts"
msgstr ""

#: ../../chapter-09.rst:714
msgid "on line 30 it checks if the user is logged on and changes the menu accordingly"
msgstr ""

#: ../../chapter-09.rst:715
msgid "on line 54 it checks for flash alert messages"
msgstr ""

#: ../../chapter-09.rst:718
msgid "Of course you can also completely replace the “layout.html” and the stylesheet with your own."
msgstr ""

#: ../../chapter-09.rst:723
msgid "Mobile development"
msgstr ""

#: ../../chapter-09.rst:725
msgid "Although the default layout.html is designed to be mobile-friendly, one may sometimes need to use different templates when a page is visited by a mobile device."
msgstr ""
