# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, BSDv3 License
# This file is distributed under the same license as the py4web package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: py4web 20251209\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-12-18 20:03+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../chapter-05.rst:3
msgid "Creating an app"
msgstr ""

#: ../../chapter-05.rst:6
msgid "From scratch"
msgstr ""

#: ../../chapter-05.rst:8
msgid "Apps can be created using the dashboard or directly from the filesystem. Here, we are going to do it manually, as the Dashboard is already described in its own chapter."
msgstr ""

#: ../../chapter-05.rst:12
msgid "Keep in mind that an app is a Python module; therefore it needs only a folder and a ``__init__.py`` file in that folder."
msgstr ""

#: ../../chapter-05.rst:16
msgid "An empty *__init__.py* file is not strictly needed since Python 3.3, but it will be useful later on."
msgstr ""

#: ../../chapter-05.rst:19
msgid "Open a command prompt and go to your main py4web folder. Enter the following simple commands in order to create a new empty **myapp** app:"
msgstr ""

#: ../../chapter-05.rst:28
msgid "for Windows, you must use backslashes (i.e. ``\\``) instead of slashes."
msgstr ""

#: ../../chapter-05.rst:33
msgid "If you now restart py4web or press the “Reload Apps” in the Dashboard, py4web will find this module, import it, and recognize it as an app, simply because of its location. By default py4web runs in *lazy watch* mode (see the :ref:`run command option`) for automatic reloading of the apps whenever it changes, which is very useful in a development environment. In production or debugging environment, it's better to run py4web with a command like this:"
msgstr ""

#: ../../chapter-05.rst:47
msgid "A py4web app is not required to do anything. It could just be a container for static files or arbitrary code that other apps may want to import and access. Yet typically most apps are designed to expose static or dynamic web pages."
msgstr ""

#: ../../chapter-05.rst:53
msgid "Static web pages"
msgstr ""

#: ../../chapter-05.rst:55
msgid "To expose static web pages you simply need to create a ``static`` subfolder, and any file in there will be automatically published:"
msgstr ""

#: ../../chapter-05.rst:63
msgid "The newly created file will be accessible at"
msgstr ""

#: ../../chapter-05.rst:69
msgid "Notice that ``static`` is a special path for py4web and only files under the ``static`` folder are served."
msgstr ""

#: ../../chapter-05.rst:74
msgid "Internally py4web uses the `ombott (One More BOTTle) web server <https://github.com/valq7711/ombott>`__, which is a minimal and fast `bottlepy <https://bottlepy.org/>`__ spin-off. It supports streaming, partial content, range requests, and if-modified-since. This is all handled automatically based on the HTTP request headers."
msgstr ""

#: ../../chapter-05.rst:82
msgid "Dynamic Web Pages"
msgstr ""

#: ../../chapter-05.rst:84
msgid "To create a dynamic page, you must create a function that returns the page content. For example edit the ``myapp/__init__.py`` as follows:"
msgstr ""

#: ../../chapter-05.rst:96
msgid "Reload the app, and this page will be accessible at"
msgstr ""

#: ../../chapter-05.rst:102
msgid "or"
msgstr ""

#: ../../chapter-05.rst:108
msgid "(notice that index is optional)"
msgstr ""

#: ../../chapter-05.rst:110
msgid "Unlike other frameworks, we do not import or start the webserver within the ``myapp`` code. This is because py4web is already running, and it may be serving multiple apps. py4web imports our code and exposes functions decorated with ``@action()``. Also notice that py4web prepends ``/myapp`` (i.e. the name of the app) to the url path declared in the action. This is because there are multiple apps, and they may define conflicting routes. Prepending the name of the app removes the ambiguity. But there is one exception: if you call your app ``_default``, or if you create a symlink from ``_default`` to ``myapp``, then py4web will not prepend any prefix to the routes defined inside the app."
msgstr ""

#: ../../chapter-05.rst:123
msgid "On return values"
msgstr ""

#: ../../chapter-05.rst:125
msgid "py4web actions should return a string or a dictionary. If they return a dictionary you must tell py4web what to do with it. By default py4web will serialize it into json. For example edit ``__init__.py`` again and add at the end"
msgstr ""

#: ../../chapter-05.rst:136
#: ../../chapter-05.rst:164
msgid "This page will be visible at"
msgstr ""

#: ../../chapter-05.rst:142
msgid "and returns a JSON object ``{\"colors\": [\"red\", \"blue\", \"green\"]}``. Notice we chose to name the function the same as the route. This is not required, but it is a convention that we will often follow."
msgstr ""

#: ../../chapter-05.rst:146
msgid "You can use any template language to turn your data into a string. PY4WEB comes with yatl, a full chapter will be dedicated later and we will provide an example shortly."
msgstr ""

#: ../../chapter-05.rst:151
msgid "Routes"
msgstr ""

#: ../../chapter-05.rst:153
msgid "It is possible to map patterns in the URL into arguments of the function. For example:"
msgstr ""

#: ../../chapter-05.rst:170
msgid "The syntax of the patterns is the same as the `Bottle routes <https://bottlepy.org/docs/dev/tutorial.html#request-routing>`__. A route wildcard can be defined as"
msgstr ""

#: ../../chapter-05.rst:174
msgid "``<name>`` or"
msgstr ""

#: ../../chapter-05.rst:175
msgid "``<name:filter>`` or"
msgstr ""

#: ../../chapter-05.rst:176
msgid "``<name:filter:config>``"
msgstr ""

#: ../../chapter-05.rst:178
msgid "And these are possible filters (only ``:re`` has a config):"
msgstr ""

#: ../../chapter-05.rst:180
msgid "``:int`` matches (signed) digits and converts the value to integer."
msgstr ""

#: ../../chapter-05.rst:181
msgid "``:float`` similar to :int but for decimal numbers."
msgstr ""

#: ../../chapter-05.rst:182
msgid "``:path`` matches all characters including the slash character in a non-greedy way, and may be used to match more than one path segment."
msgstr ""

#: ../../chapter-05.rst:184
msgid "``:re[:exp]`` allows you to specify a custom regular expression in the config field. The matched value is not modified."
msgstr ""

#: ../../chapter-05.rst:187
msgid "The pattern matching the wildcard is passed to the function under the specified variable ``name``."
msgstr ""

#: ../../chapter-05.rst:190
msgid "Note that the routing is implemented in ombott as radix-tree hybrid router. It is declaration-order-independent and it prioritizes static route-fragment over dynamic one, since this is most expected behavior."
msgstr ""

#: ../../chapter-05.rst:194
msgid "This results in some constraints, such as one cannot have more than one route that has dynamic fragment of different types (int, path) in the same place.. Hence **something like this is incorrect** and will result in errors:"
msgstr ""

#: ../../chapter-05.rst:209
msgid "Instead, to accomplish a simmilar result, one needs to handle all the logic in one action:"
msgstr ""

#: ../../chapter-05.rst:222
msgid "Also, the action decorator takes an optional ``method`` argument that can be an HTTP method or a list of methods:"
msgstr ""

#: ../../chapter-05.rst:229
msgid "You can use multiple decorators to expose the same function under multiple routes."
msgstr ""

#: ../../chapter-05.rst:233
msgid "The ``request`` object"
msgstr ""

#: ../../chapter-05.rst:235
msgid "From py4web you can import ``request``"
msgstr ""

#: ../../chapter-05.rst:248
msgid "This action can be accessed at:"
msgstr ""

#: ../../chapter-05.rst:256
msgid "Notice that the request object is equivalent to a `Bottle request object <https://bottlepy.org/docs/dev/api.html#the-request-object>`__. with one additional attribute:"
msgstr ""

#: ../../chapter-05.rst:263
msgid "Which you can use the code to identify the name and the folder used for the app."
msgstr ""

#: ../../chapter-05.rst:267
msgid "Templates"
msgstr ""

#: ../../chapter-05.rst:269
msgid "In order to use a yatl template you must declare it. For example create a file ``apps/myapp/templates/paint.html`` that contains:"
msgstr ""

#: ../../chapter-05.rst:284
msgid "then modify the paint action to use the template and default to green."
msgstr ""

#: ../../chapter-05.rst:293
msgid "The page will now display the color name on a background of the corresponding color."
msgstr ""

#: ../../chapter-05.rst:296
msgid "The key ingredient here is the decorator ``@action.uses(...)``. The arguments of ``action.uses`` are called **fixtures**. You can specify multiple fixtures in one decorator or you can have multiple decorators. Fixtures are objects that modify the behavior of the action, that may need to be initialized per request, that may filter input and output of the action, and that may depend on each-other (they are similar in scope to Bottle plugins but they are declared per-action, and they have a dependency tree which will be explained later)."
msgstr ""

#: ../../chapter-05.rst:305
msgid "The simplest type of fixture is a template. You specify it by simply giving the name of the file to be used as template. That file must follow the yatl syntax and must be located in the ``templates`` folder of the app. The object returned by the action will be processed by the template and turned into a string."
msgstr ""

#: ../../chapter-05.rst:311
msgid "You can easily define fixtures for other template languages. This is described later."
msgstr ""

#: ../../chapter-05.rst:314
msgid "Some built-in fixtures are:"
msgstr ""

#: ../../chapter-05.rst:316
msgid "the DAL object (which tells py4web to obtain a database connection from the pool at every request, and commit on success or rollback on failure)"
msgstr ""

#: ../../chapter-05.rst:319
msgid "the Session object (which tells py4web to parse the cookie and retrieve a session at every request, and to save it if changed)"
msgstr ""

#: ../../chapter-05.rst:321
msgid "the Translator object (which tells py4web to process the accept-language header and determine optimal internationalization/pluralization rules)"
msgstr ""

#: ../../chapter-05.rst:324
msgid "the Auth object (which tells py4web that the app needs access to the user info)"
msgstr ""

#: ../../chapter-05.rst:327
msgid "They may depend on each other. For example, the Session may need the DAL (database connection), and Auth may need both. Dependencies are handled automatically."
msgstr ""

#: ../../chapter-05.rst:332
msgid "The \\_scaffold app"
msgstr ""

#: ../../chapter-05.rst:334
msgid "Most of the times, you do not want to start writing code from scratch. You also want to follow some sane conventions outlined here, like not putting all your code into ``__init__.py``. PY4WEB provides a Scaffolding (_scaffold) app, where files are organized properly and many useful objects are pre-defined. Also, it shows you how to manage users and their registration. Just like a real scaffolding in a building construction site, scaffolding could give you some kind of a fast and simplified structure for your project, on which you can rely to build your real project."
msgstr ""

#: ../../chapter-05.rst:346
msgid "You will normally find the scaffold app under apps, but you can easily create a new clone of it manually or using the Dashboard."
msgstr ""

#: ../../chapter-05.rst:349
msgid "Here is the tree structure of the ``_scaffold`` app:"
msgstr ""

#: ../../chapter-05.rst:353
msgid "The scaffold app contains an example of a more complex action:"
msgstr ""

#: ../../chapter-05.rst:369
msgid "Notice the following:"
msgstr ""

#: ../../chapter-05.rst:371
msgid "``request``, ``response``, ``abort`` are defined by ``ombott``."
msgstr ""

#: ../../chapter-05.rst:372
msgid "``redirect`` and ``URL`` are similar to their web2py counterparts."
msgstr ""

#: ../../chapter-05.rst:373
msgid "helpers (``A``, ``DIV``, ``SPAN``, ``IMG``, etc) must be imported from ``yatl.helpers`` . They work pretty much as in web2py."
msgstr ""

#: ../../chapter-05.rst:375
msgid "``db``, ``session``, ``T``, ``cache``, ``auth`` are Fixtures. They must be defined in ``common.py``."
msgstr ""

#: ../../chapter-05.rst:377
msgid "``@action.uses(auth.user)`` indicates that this action expects a valid logged-in user retrievable by ``auth.get_user()``. If that is not the case, this action redirects to the login page (defined also in ``common.py`` and using the Vue.js auth.html component)."
msgstr ""

#: ../../chapter-05.rst:382
msgid "When you start from scaffold, you may want to edit ``settings.py``, ``templates``, ``models.py`` and ``controllers.py`` but probably you don’t need to change anything in ``common.py``."
msgstr ""

#: ../../chapter-05.rst:386
msgid "In your html, you can use any JS library that you want because py4web is agnostic to your choice of JS and CSS, but with some exceptions. The ``auth.html`` which handles registration/login/etc. uses a vue.js component. Hence if you want to use that, you should not remove it."
msgstr ""

#: ../../chapter-05.rst:395
msgid "Copying the \\_scaffold app"
msgstr ""

#: ../../chapter-05.rst:397
msgid "The scaffold app is really useful, and you will surely use it a lot as a starting point for testing and even developing full features new apps."
msgstr ""

#: ../../chapter-05.rst:400
msgid "It's better not to work directly on it: always create new apps copying it. You can do it in two ways:"
msgstr ""

#: ../../chapter-05.rst:403
msgid "using the command line: copy the whole apps/_scaffold folder to another one (apps/my_app for example). Then reload py4web and it will be automatically loaded."
msgstr ""

#: ../../chapter-05.rst:405
msgid "using the Dashboard: select the button ``Create/Upload App`` under the \"Installed Applications\" upper section. Just give the new app a name and check that \"Scaffold\" is selected as the source. Finally press the ``Create`` button and the dashboard will be automatically reloaded, along with the new app."
msgstr ""

#: ../../chapter-05.rst:416
msgid "Watch for files change"
msgstr ""

#: ../../chapter-05.rst:418
msgid "As described in the :ref:`run command option`, Py4web facilitates a development server’s setup by automatically reloads an app when its Python source files change (by default). But in fact any other files inside an app can be watched by setting a handler function using the ``@app_watch_handler`` decorator."
msgstr ""

#: ../../chapter-05.rst:424
msgid "Two examples of this usage are reported now. Do not worry if you don’t fully understand them: the key point here is that even non-python code could be reloaded automatically if you explicit it with the ``@app_watch_handler`` decorator."
msgstr ""

#: ../../chapter-05.rst:429
msgid "Watch SASS files and compile them when edited:"
msgstr ""

#: ../../chapter-05.rst:448
msgid "Validate javascript syntax when edited:"
msgstr ""

#: ../../chapter-05.rst:464
msgid "Filepaths passed to ``@app_watch_handler`` decorator must be relative to an app. Python files (i.e. \"\\*.py\") in a list passed to the decorator are ignored since they are watched by default. Handler function’s parameter is a list of filepaths that were changed. All exceptions inside handlers are printed in terminal."
msgstr ""

#: ../../chapter-05.rst:471
msgid "Domain-mapped apps"
msgstr ""

#: ../../chapter-05.rst:473
msgid "In production environments it is often required to have several apps being served by a single py4web server, where different apps are mapped to different domains."
msgstr ""

#: ../../chapter-05.rst:477
msgid "py4web can easily handle running multiple apps, but there is no build-in mechanism for mapping domains to specific applications. Such mapping needs to be done externally to py4web -- for instance using a web reverse-proxy, such as nginx."
msgstr ""

#: ../../chapter-05.rst:482
msgid "While nginx or other reverse-proxies are also useful in production environments for handling SSL termination, caching and other uses, we cover only the mapping of domains to py4web applications here."
msgstr ""

#: ../../chapter-05.rst:486
msgid "An example nginx configuration for an application ``myapp`` mapped to a domain ``myapp.example.com`` might look like that:"
msgstr ""

#: ../../chapter-05.rst:502
msgid "This is an example ``server`` block of nginx configuration. One would have to create a separate such block for **each app/each domain** being served by py4web server. Note some important aspects:"
msgstr ""

#: ../../chapter-05.rst:505
msgid "``server_name`` defines the domain mapped to the app ``myapp``,"
msgstr ""

#: ../../chapter-05.rst:506
msgid "``proxy_http_version 1.1;`` directive is optional, but highly recommended (otherwise nginx uses HTTP 1.0 to talk"
msgstr ""

#: ../../chapter-05.rst:507
msgid "to the backend-server -- here py4web -- and it creates all kinds of issues with buffering and otherwise),"
msgstr ""

#: ../../chapter-05.rst:508
msgid "``proxy_set_header Host $host;`` directive ensures that the correct ``Host`` is passed to py4web -- here ``myapp.example.com``"
msgstr ""

#: ../../chapter-05.rst:509
msgid "``proxy_set_header X-PY4WEB-APPNAME /myapp;`` directive ensures that py4web (and ombott) knows which app to serve"
msgstr ""

#: ../../chapter-05.rst:510
msgid "and **also** that this application is domain-mapped -- pay specific attention to the slash (``/``) in front of the ``myapp`` name -- it is **required** to ensure correct parsing of URLs on ombott level,"
msgstr ""

#: ../../chapter-05.rst:512
msgid "finally ``proxy_pass http://127.0.0.1:8000/myapp$request_uri;`` ensures that the request is passed in its integrity (``$request_uri``)"
msgstr ""

#: ../../chapter-05.rst:513
msgid "to py4web server (here: ``127.0.0.1:8000``) and the correct app (``/myapp``)."
msgstr ""

#: ../../chapter-05.rst:515
msgid "Such configuration ensures that all URL manipulation inside ombott and py4web - especially in modules such as ``Auth``, ``Form``, and ``Grid`` are done correctly using the domain to which the app is mapped to."
msgstr ""

#: ../../chapter-05.rst:519
msgid "Custom error pages"
msgstr ""

#: ../../chapter-05.rst:521
msgid "py4web provides default error pages. For instance, if none of the routes in an app matches the request, a default 404 error page will be shown. By default all HTTP error codes are handled automatically by py4web."
msgstr ""

#: ../../chapter-05.rst:525
msgid "It is however possible to override this behaviour. It can be done either per HTTP error code, or even for all errors."
msgstr ""

#: ../../chapter-05.rst:528
msgid "Here is an example for overriding HTTP code 404 (not found):"
msgstr ""

#: ../../chapter-05.rst:535
msgid "If one wants to replace _all_ default error pages, a special qualifier ``\"*\"`` should be used. Also, the returned value may contain HTML code as well:"
msgstr ""

#: ../../chapter-05.rst:547
msgid "Note that this setup is **global**. This means that it is defined once for all apps on a given py4web instance. This is because, when an error is encountered, it could be because the request has not matched any of the apps. Hence, this configuration should only be done in **one of the apps**."
msgstr ""
